head	1.86;
access;
symbols
	RUSH_ROCK_1_0:1.82
	RUSH_ROCK_1_0epst:1.80
	MACE_1_0e:1.60
	MACE_1_0d:1.60
	RUSH_1_06A:1.56
	AREA_52_00:1.68
	MACE_1_0a:1.60;
locks; strict;
comment	@ * @;


1.86
date	97.12.08.21.15.59;	author shepperd;	state Exp;
branches;
next	1.85;

1.85
date	97.12.06.00.44.12;	author shepperd;	state Exp;
branches;
next	1.84;

1.84
date	97.12.06.00.04.09;	author shepperd;	state Exp;
branches;
next	1.83;

1.83
date	97.10.15.06.07.37;	author shepperd;	state Exp;
branches;
next	1.82;

1.82
date	97.10.06.17.21.49;	author shepperd;	state Exp;
branches;
next	1.81;

1.81
date	97.10.03.21.58.00;	author shepperd;	state Exp;
branches;
next	1.80;

1.80
date	97.09.24.02.54.29;	author shepperd;	state Exp;
branches;
next	1.79;

1.79
date	97.09.23.00.09.23;	author shepperd;	state Exp;
branches;
next	1.78;

1.78
date	97.08.19.21.09.26;	author forrest;	state Exp;
branches;
next	1.77;

1.77
date	97.08.16.23.34.31;	author shepperd;	state Exp;
branches;
next	1.76;

1.76
date	97.08.02.22.09.30;	author shepperd;	state Exp;
branches;
next	1.75;

1.75
date	97.08.02.21.19.52;	author shepperd;	state Exp;
branches;
next	1.74;

1.74
date	97.08.02.00.14.03;	author albaugh;	state Exp;
branches;
next	1.73;

1.73
date	97.08.01.22.06.11;	author albaugh;	state Exp;
branches;
next	1.72;

1.72
date	97.08.01.03.27.14;	author shepperd;	state Exp;
branches;
next	1.71;

1.71
date	97.07.25.03.00.59;	author shepperd;	state Exp;
branches;
next	1.70;

1.70
date	97.07.20.01.51.22;	author shepperd;	state Exp;
branches;
next	1.69;

1.69
date	97.07.17.22.40.50;	author shepperd;	state Exp;
branches;
next	1.68;

1.68
date	97.07.17.16.59.10;	author shepperd;	state Exp;
branches;
next	1.67;

1.67
date	97.07.11.22.39.38;	author shepperd;	state Exp;
branches;
next	1.66;

1.66
date	97.07.11.20.45.32;	author shepperd;	state Exp;
branches;
next	1.65;

1.65
date	97.07.10.18.53.13;	author shepperd;	state Exp;
branches;
next	1.64;

1.64
date	97.07.10.18.15.25;	author shepperd;	state Exp;
branches;
next	1.63;

1.63
date	97.05.30.23.50.02;	author shepperd;	state Exp;
branches;
next	1.62;

1.62
date	97.05.17.19.12.40;	author shepperd;	state Exp;
branches;
next	1.61;

1.61
date	97.05.09.02.20.19;	author shepperd;	state Exp;
branches;
next	1.60;

1.60
date	97.04.06.01.04.19;	author shepperd;	state Exp;
branches;
next	1.59;

1.59
date	97.03.31.23.48.57;	author shepperd;	state Exp;
branches;
next	1.58;

1.58
date	97.02.27.04.04.45;	author shepperd;	state Exp;
branches;
next	1.57;

1.57
date	97.01.31.02.44.02;	author shepperd;	state Exp;
branches;
next	1.56;

1.56
date	96.11.23.05.46.55;	author shepperd;	state Exp;
branches;
next	1.55;

1.55
date	96.11.23.02.22.02;	author shepperd;	state Exp;
branches;
next	1.54;

1.54
date	96.11.22.02.33.55;	author shepperd;	state Exp;
branches;
next	1.53;

1.53
date	96.11.22.01.40.42;	author shepperd;	state Exp;
branches;
next	1.52;

1.52
date	96.11.16.22.31.13;	author shepperd;	state Exp;
branches;
next	1.51;

1.51
date	96.11.15.05.59.24;	author forrest;	state Exp;
branches;
next	1.50;

1.50
date	96.11.14.11.50.32;	author shepperd;	state Exp;
branches;
next	1.49;

1.49
date	96.11.05.23.20.51;	author shepperd;	state Exp;
branches;
next	1.48;

1.48
date	96.11.04.21.23.12;	author shepperd;	state Exp;
branches;
next	1.47;

1.47
date	96.10.14.21.26.19;	author shepperd;	state Exp;
branches;
next	1.46;

1.46
date	96.10.11.19.19.38;	author shepperd;	state Exp;
branches;
next	1.45;

1.45
date	96.10.07.16.44.39;	author shepperd;	state Exp;
branches;
next	1.44;

1.44
date	96.09.30.22.04.21;	author shepperd;	state Exp;
branches;
next	1.43;

1.43
date	96.09.30.21.15.38;	author shepperd;	state Exp;
branches;
next	1.42;

1.42
date	96.09.10.04.35.59;	author shepperd;	state Exp;
branches;
next	1.41;

1.41
date	96.09.06.02.44.43;	author shepperd;	state Exp;
branches;
next	1.40;

1.40
date	96.09.05.02.01.01;	author shepperd;	state Exp;
branches;
next	1.39;

1.39
date	96.08.31.20.06.09;	author shepperd;	state Exp;
branches;
next	1.38;

1.38
date	96.08.30.04.22.13;	author shepperd;	state Exp;
branches;
next	1.37;

1.37
date	96.08.30.00.47.20;	author shepperd;	state Exp;
branches;
next	1.36;

1.36
date	96.08.27.18.58.44;	author shepperd;	state Exp;
branches;
next	1.35;

1.35
date	96.08.27.18.31.19;	author shepperd;	state Exp;
branches;
next	1.34;

1.34
date	96.08.26.22.50.43;	author shepperd;	state Exp;
branches;
next	1.33;

1.33
date	96.08.24.23.39.53;	author shepperd;	state Exp;
branches;
next	1.32;

1.32
date	96.08.24.23.05.12;	author shepperd;	state Exp;
branches;
next	1.31;

1.31
date	96.08.24.21.59.57;	author shepperd;	state Exp;
branches;
next	1.30;

1.30
date	96.08.24.17.37.12;	author shepperd;	state Exp;
branches;
next	1.29;

1.29
date	96.08.08.02.54.37;	author shepperd;	state Exp;
branches;
next	1.28;

1.28
date	96.08.06.00.24.06;	author forrest;	state Exp;
branches;
next	1.27;

1.27
date	96.08.05.22.29.39;	author forrest;	state Exp;
branches;
next	1.26;

1.26
date	96.07.25.02.06.50;	author shepperd;	state Exp;
branches;
next	1.25;

1.25
date	96.07.24.01.23.17;	author shepperd;	state Exp;
branches;
next	1.24;

1.24
date	96.07.17.17.53.49;	author shepperd;	state Exp;
branches;
next	1.23;

1.23
date	96.07.16.18.52.11;	author shepperd;	state Exp;
branches;
next	1.22;

1.22
date	96.07.12.19.06.20;	author forrest;	state Exp;
branches;
next	1.21;

1.21
date	96.07.12.01.24.33;	author shepperd;	state Exp;
branches;
next	1.20;

1.20
date	96.07.11.21.13.34;	author shepperd;	state Exp;
branches;
next	1.19;

1.19
date	96.06.29.20.30.38;	author shepperd;	state Exp;
branches;
next	1.18;

1.18
date	96.06.08.23.12.32;	author shepperd;	state Exp;
branches;
next	1.17;

1.17
date	96.06.08.16.37.03;	author shepperd;	state Exp;
branches;
next	1.16;

1.16
date	96.06.06.03.24.18;	author shepperd;	state Exp;
branches;
next	1.15;

1.15
date	96.05.30.04.32.53;	author shepperd;	state Exp;
branches;
next	1.14;

1.14
date	96.05.30.02.26.24;	author shepperd;	state Exp;
branches;
next	1.13;

1.13
date	96.05.16.20.57.03;	author shepperd;	state Exp;
branches;
next	1.12;

1.12
date	96.05.15.03.31.58;	author shepperd;	state Exp;
branches;
next	1.11;

1.11
date	96.05.14.20.56.26;	author shepperd;	state Exp;
branches;
next	1.10;

1.10
date	96.05.08.02.17.07;	author shepperd;	state Exp;
branches;
next	1.9;

1.9
date	96.05.07.20.18.16;	author shepperd;	state Exp;
branches;
next	1.8;

1.8
date	96.04.27.22.39.28;	author shepperd;	state Exp;
branches;
next	1.7;

1.7
date	96.04.26.20.12.44;	author shepperd;	state Exp;
branches;
next	1.6;

1.6
date	96.04.24.22.11.38;	author shepperd;	state Exp;
branches;
next	1.5;

1.5
date	96.04.24.01.12.40;	author shepperd;	state Exp;
branches;
next	1.4;

1.4
date	96.04.22.22.09.01;	author shepperd;	state Exp;
branches;
next	1.3;

1.3
date	96.04.20.02.36.38;	author shepperd;	state Exp;
branches;
next	1.2;

1.2
date	96.04.16.03.00.54;	author shepperd;	state Exp;
branches;
next	1.1;

1.1
date	96.04.14.18.24.24;	author shepperd;	state Exp;
branches;
next	;


desc
@GUTS shims for the Phoenix board.
@


1.86
log
@Tightened up and combined the FG and AST process loop.
@
text
@/*
 * $Id: phx_shims.c,v 1.85 1997/12/06 00:44:12 shepperd Exp shepperd $
 *
 *		Copyright 1996 Atari Games, Corp.
 *	Unauthorized reproduction, adaptation, distribution, performance or 
 *	display of this computer program or the associated audiovisual work
 *	is strictly prohibited.
 */

#include <config.h>
#include <phx_proto.h>
#include <icelesspkt.h>
#include <intvecs.h>
#include <wms_proto.h>
#include <st_proto.h>

#define DO_STACK_WATERMARK	1

#if ANNOUNCE_BOOT_ACTIONS
# include <ioa_uart.h>
#endif

#define R4K_HOST 1

#if !defined(TIME_EXCEPTIONS) /* See also phx_root.mac */
# define TIME_EXCEPTIONS 0
#endif

#if !defined(SHOW_TIME)
# define SHOW_TIME	0
#endif

#if !defined(TIMER_HISTORY)
# define TIMER_HISTORY	0
#endif

#if !defined(NU_IE)
# define NU_IE		SR_IE
#endif

# define NUM_ELTS(x) (sizeof(x)/sizeof(x[0]))

extern void begin();

#define offsetof(s, m)    (int)(&(((s *)0)->m))

#include <eer_defs.h>
#include <os_proto.h>

extern struct _reent *mainline_reent;
extern struct _reent *interrupt_reent;
extern struct _reent *ast_reent;
extern struct _reent *action_reent;
extern struct _reent *_impure_ptr;

extern struct pconfigb guts_pbase;
const struct pconfigb *pbase;
extern void SelfTest(int cold);
extern void eer_user_purge();

#if !BOOT_FROM_DISK && !EPROM_ST
# define POWERUP (0xC0EDBABE)
extern unsigned long powerUp;
#endif

unsigned short bitshd;

int prc_mod_latch(int new) {
   int old_sr;

   if (new == 0) return bitshd;		/* just report what it currently is */
   old_sr = prc_set_ipl(INTS_OFF);	/* disable interrupts */
   if (new < 0) {		
      bitshd &= new;		/* negative, we AND out the cooresponding bits */
   } else {
      bitshd |= new;		/* positive, we OR in the cooresponding bits */
   }
   prc_set_ipl(old_sr);		/* re-enable interrupts */
   return new;
}

static U32 old_timer_rate;

U32 prc_timer_rate(U32 new) {
#if HOST_BOARD != CHAMELEON
    VU32 *timr, *ctl;
#endif
    U32 old, oldps;
    old = old_timer_rate;

    if (new) {
	oldps = prc_set_ipl(INTS_OFF);

#if HOST_BOARD != CHAMELEON
	timr = (VU32*)GALILEO_TIMER3;
	ctl = (VU32*)GALILEO_TIMER_CTL;
	*ctl &= ~(3<<6);	/* disable the timer/counter */
	*timr = new;
	*ctl |= (3<<6);		/* enable the timer as a timer */
	*(VU32*)GALILEO_INT_CAUSE = ~TM3_NOTES; /* ack any pending timer interrupts */
#else
	prc_set_compare(prc_get_count() + new); /* acks the interrupt */
#endif
	old_timer_rate = new;
	prc_set_ipl(oldps);
    }
    return old;
}

void __main() {
    return;
}


#if ANNOUNCE_BOOT_ACTIONS

int shims_putc_disable;

void (*shims_putc_vec)(char c);

void shims_putc(char c) {

    if (shims_putc_vec) {
	shims_putc_vec(c);		/* do his action */
	return;
    }

    if (!shims_putc_disable) {		/* Only print if it's not disabled */
	prc_putc(c);
    }

}

int shims_puts(const char *str) {
    int c, lastc=0;
    const char *msg = str;

    if (shims_putc_disable) return 0;
    msg = str;
    while ((c=*str++) != 0) {
	if (c == '\n' && lastc != '\r') shims_putc('\r');
	shims_putc(c);
	lastc = c;
    }
    return str-msg;
}

#ifndef BLAB
# define BLAB(x) shims_puts(x)
#endif
#ifndef BLABF
# define BLABF(x) shims_printf x
#endif

#else

#ifndef BLAB
# define BLAB(x)
#endif

#ifndef BLABF
# define BLABF(x)
#endif

#endif			/* ANNOUNCE_BOOT_ACTIONS */

#if MAX_AST_QUEUES 
volatile int _guts_astlvl;
#endif

#if MAX_FG_QUEUES 
volatile int _guts_fglvl;
#endif

#if HOST_BOARD == CHAMELEON
static void cputimerint(void);
#endif

#if INCLUDE_SYSCALL
static void syscall(U32 *);
#endif

const char boot_version[] = 
"\r\nEPROM Boot code. Version: " __DATE__ " " __TIME__ "\r\n"
"Copyright 1996,1997 Atari Games, Corp.\r\n";

void BootUp() {
   extern struct pconfigp PBASE;
   unsigned long cold_boot;
   void (*func)(void);
   struct ROM_VECTOR_STR *romv = (struct ROM_VECTOR_STR *)DRAM_BASEnc;

#if HOST_BOARD == PHOENIX
   *(VU32*)IO_RESET = -1;      /* l=unleash the I/O ASIC */
   *(VU32*)PCI_RESET = -1;     /* unleash the PCI */
#endif
#if (HOST_BOARD == PHOENIX_AD) || (HOST_BOARD == SEATTLE) || (HOST_BOARD == VEGAS)
    /* Un-reset everything */
   *(VU32*)RESET_CTL = (1<<B_RESET_EXP)|(1<<B_RESET_IOASIC)|(1<<B_RESET_IDE)|
    			(1<<B_RESET_3DFX)|(1<<B_RESET_NSS)|(1<<B_RESET_WIDGET);
#endif
#if HOST_BOARD == FLAGSTAFF
    /* Un-reset everything */
   *(VU32*)RESET_CTL = (1<<B_RESET_EXP)|(1<<B_RESET_IOASIC)|(1<<B_RESET_IDE)|
    			(1<<B_RESET_3DFX)|(1<<B_RESET_ENET)|(1<<B_RESET_WIDGET);
#endif
#if (HOST_BOARD == CHAMELEON)
    /* Un-reset everything */
   RESET_CTL_T = RESET_PCI_SLOT_0|RESET_PCI_SLOT_1|RESET_PCI_SLOT_2|
    		 RESET_IDE|RESET_IOASIC|RESET_AUX_UART|RESET_SMC|
    		 RESET_NSS_CONN|RESET_GUN_CONF;
#endif

#if MAX_AST_QUEUES 
    _guts_astlvl = -1;
#endif

#if MAX_FG_QUEUES 
    _guts_fglvl = -1;
#endif

   func=(void (*)(void))romv->ROMV_STUB_INIT;
        
   if (func) {		/* if the stub is loaded, go init it... */
       if (!romv->ROMV_STUB_FLAG) func(); /* ...if not already init'ed */
# if HOST_BOARD == CHAMELEON
#  if defined(DBG_NOTES)
       INTCTL_IE_T |= DBG_NOTES;
#  endif
# else
#  if ICELESS_MANY
       *(VU32*)INTCTL_IE |= ICELESS_MANY;
#  else
#   if ICELESS_LVL
       *(VU32*)INTCTL_IE |= 1<<(ICELESS_LVL-1);
#   endif
#  endif
# endif
   }

# if HOST_BOARD != CHAMELEON
    UnLock();				/* free up the I/O ASIC */
# endif
    prc_wait_n_usecs(100000);		/* wait for the I/O ASIC to come to life */

#if ANNOUNCE_BOOT_ACTIONS
# ifdef IO_DIPSW_T
    if ((IO_DIPSW_T&(IO_DIPSW0|IO_DIPSW1)) != 0) shims_putc_disable = 1;
# else
#  ifdef IO_DIPSW
    if ((*(VU32*)IO_DIPSW&(IO_DIPSW0|IO_DIPSW1)) != 0) shims_putc_disable = 1;
#  endif
# endif

#if !SA_DIAGS
    BLAB(boot_version);
#endif

# if DRAM_BANKS
    BLABF(("Shims: DRAM configuration: %d bank%sof %d megabyte%c\r\n",
    		DRAM_BANKS, DRAM_BANKS > 1 ? "s " : " ",
    		DRAM_BANK_SIZE/0x00100000, DRAM_BANK_SIZE > 0x00100000 ? 's' : ' '));
# endif
# if HOST_BOARD == PHOENIX
    BLAB("Shims: 1 bank of 8 and 1 bank of 32 megabytes\r\n");
# endif
#endif

# if ICELESS_NMI
    if (romv->ROMV_STUB_VECS) {		/* if the iceless has an NMI vector ...*/
	struct IIO_VECTOR_STR *s;

	s = (struct IIO_VECTOR_STR *)romv->ROMV_STUB_VECS;
	if (s->STUBVEC_NMI) {
	    VU32 *ptr = (VU32*)INTCTL_NMI;
	    *ptr = ICELESS_NMI;		/* select the NMI bit */
	}
    }
# endif	

# if HOST_BOARD != CHAMELEON
   BLAB("Shims: Setting Galileo timer...");
   prc_timer_rate(50000);	/* set rate to 1Ms */
#else
   BLABF(("Shims: Setting CPU timer to %d...", CPU_SPEED/2000));
   prc_set_vec(INT5_INTVEC, cputimerint);
   old_timer_rate = CPU_SPEED/2000; 
#endif

   pbase = &guts_pbase;		/* for now, we just use our dummy pconfigb */
   if ( PBASE.p_validate == PB_VALID && PBASE.p_configb ) pbase = PBASE.p_configb;

# if INCLUDE_FEXCP
   {
       extern void init_fpu(void);
       BLAB("\nShims: Installing floating point exception handler...");
       init_fpu();
   }
# endif

# if INCLUDE_SYSCALL
   prc_set_vec(SYSCALL_INTVEC, (void (*)(void))syscall);
# endif

#if !BOOT_FROM_DISK && !EPROM_ST
   cold_boot = powerUp ^ POWERUP;
   powerUp = POWERUP;
#else
   cold_boot = 1;
#endif

   BLAB("\nShims: Finish setting up \"C\" environment...");

   __main();			/* do other startup stuff */

   BLAB("\nShims: Starting selftest code.\r\n");
   SelfTest(cold_boot);		/* now goto selftest */

}

# if !BOOT_FROM_DISK && !EPROM_ST
extern struct pm_general pm_data;
# endif
extern U32 INIT_SP;

extern void flush_cache(void);
void stub_start(void) {
    flush_cache();		/* make sure any variables are written to memory */
    begin();			/* doesn't return from here */
}

void prc_reboot() {		/* reboot */
   int cnt;
   extern void eer_action(void *);

   eer_user_purge();		/* clear any open user recs w/o writing them */
   eer_action(0);		/* purge any pending eeprom writes */
   
   prc_set_ipl(INTS_OFF);	/* disable interrupts */
#if !BOOT_FROM_DISK && !EPROM_ST
   pm_data.pm_cntr = -42;	/* this means something to Mike */
   pm_data.pm_msg = 0;
#endif
   for (cnt=0; cnt < 40; ++cnt) {
#if !BOOT_FROM_DISK && defined(WDOG) && !NO_WDOG && !EPROM_ST
       WDOG = 0;		/* give WDOG a kick */
#endif
       vid_waitvb(0);	/* count frames */ 
   }
   flush_cache();		/* make sure our variables are written to memory */
   prc_reset_hardware();
#if !BOOT_FROM_DISK && defined(WDOG) && !NO_WDOG && !EPROM_ST
   WDOG = 0;			/* give WDOG one more kick to give some additional time */
#endif
   begin();			/* never comes back from here */
}

/*		exit_to_game()
 *	Hack to allow Williams-style momentary-contact TEST button
 *	even when it takes a _long_ time to get through a boot.
 *	The actual hackery involves a variable in the text segment
 *	(S.O.L. if we ever protect memory), which is extern'd here
 *	because it's not real general-case.
 *
 *	The function itself is defined to take a selected menu pointer
 *	and return an int so that it can be called directly from the
 *	game's selftest menu.
 */
extern int go_to_self_test;
int exit_to_game( const struct menu_d *smp ) {
    (void) smp;
#if (BOOT_FROM_DISK == 0) && (EPROM_ST == 0)
    go_to_self_test = 0;
#endif
    prc_reboot();
    return 0;
}

void prc_cache_init(int cache_on) {	/* cache is always on on this processor */
   return;
}

void (*ms4vec)(void);

extern int adj_usclock();

static U32 *his_zclock;

U32 *prc_timer_ptr(U32 *ptr) {
    U32 *old;
    old = his_zclock;
    his_zclock = ptr;
    return old;
}

#if TIMER_HISTORY
static U32 timer_history[TIMER_HISTORY];
static int timer_history_nxt;
#endif

#if SHOW_TIME
typedef struct dow {
    int days;
    int hours;
    int mins;
    int secs;
    int subsec;
} Dow;

static Dow act;
static struct tq dow_q;

#include <nsprintf.h>

static void upd_dow(Dow *dow, int row) {
    ++dow->subsec;
    *(VU32*)XBUSMON_BASE = dow->subsec&1;
    if (dow->subsec >= 920) {
	U32 oldpos;
	dow->subsec = 0;
	++dow->secs;
	if (dow->secs > 59) {
	    dow->secs = 0;
	    ++dow->mins;
	    if (dow->mins > 59) {
		dow->mins = 0;
		++dow->hours;
		if (dow->hours > 23) {
		    dow->hours = 0;
		    ++dow->days;
		}
	    }
	}
	oldpos = txt_setpos(0);
	txt_decnum((AN_VIS_COL-12)/2, row, dow->days, 3, RJ_BF, WHT_PALB);
	txt_cstr(" ", WHT_PALB);
	txt_cdecnum(dow->hours, 2, RJ_ZF, WHT_PALB);
	txt_cstr(":", WHT_PALB);
	txt_cdecnum(dow->mins, 2, RJ_ZF, WHT_PALB);
	txt_cstr(":", WHT_PALB);
	txt_cdecnum(dow->secs, 2, RJ_ZF, WHT_PALB);
	txt_setpos(oldpos);
    }
    return;
}

static void timer_act(void *arg) {
    dow_q.delta = 1000;
    tq_ins(&dow_q);
    upd_dow(&act, AN_VIS_ROW-1);
    return;
}
#endif

static U32 timer_ints;		/* number of cputimer interrupts */

U32 prc_timer_ints(void) {
    return timer_ints;
}

#define COUNTS_PER_USEC (CPU_SPEED/2000000)

void prc_timer_jobs(int how) {
    U32 lt;
    static U32 last_time;

    ++timer_ints;
#if TIMER_HISTORY
     start = prc_get_count();
     timer_history[timer_history_nxt] = start - timer_history[timer_history_nxt];
     ++timer_history_nxt;
     if (timer_history_nxt >= n_elts(timer_history)) timer_history_nxt = 0;
     timer_history[timer_history_nxt] = start;
#endif
#if SHOW_TIME
     if (!dow_q.func) {
	dow_q.func = timer_act;
	dow_q.delta = 1000;
	tq_ins(&dow_q);
     }
#endif
    lt = 1000;				/* assume 1000 usecs since last time */
    if (last_time && CPU_SPEED) {	/* as long as there was a last time */
	lt = (prc_get_count() - last_time)/COUNTS_PER_USEC; /* compute usecs since last time */
    }
    last_time = prc_get_count();	/* remember this */
    tq_maint(lt);			/* update and launch any timers */

    if (his_zclock) *his_zclock += 1;
    if (tpllvec) tpllvec();
    if (timervec) timervec();		/* call game's interrupt */
}

#if HOST_BOARD == CHAMELEON
static
#endif
void cputimerint() {
#if HOST_BOARD != CHAMELEON
   VU32 *cause  = (VU32*)GALILEO_INT_CAUSE;
# if TIMER_HISTORY
   U32 start;
# endif

   if (!(*cause&TM3_NOTES)) return;	/* not us, just exit */

   *cause = ~TM3_NOTES;			/* ack the interrupt */
#else
   prc_timer_rate(prc_timer_rate(0));	/* ack the timer and set for next time */
#endif

   prc_timer_jobs(1);			/* from h/w interrupt */
}

/* prc_add_q takes a pointer to an "action" structure and puts it at the
 * end of the specified queue, provided it is not already on a queue.
 * Otherwise, it returns a pointer to the "queue head" for the queue
 * it is already on (including the specified one).
 */

struct act_q *prc_add_q(struct act_q *head, struct act_q *new) {
   int old_sr;
   struct act_q *ans = 0;	/* assume success */
   if (!new) return 0;		/* cover bonehead move */
   if (!head) return 0;		/* cover bonehead move */
   old_sr = prc_set_ipl(INTS_OFF); /* has to work w/o interrupts */
   if (new->que == 0) {		/* not currently on any queue */
      ans = head;		/* point to head of action queue */
      while (ans) {		/* while the pointer is not empty */
	 if (ans->next == new ) {
	    new->que = head;	/* fix what got us here */
	    ans = head;		/* already in this queue */
	    break;
	 }
	 if (ans->next == 0) {	/* found the last member */
	    new->next = 0;
	    new->que = head;	/* say what queue we're on */
	    ans->next = new;	/* we're the new last member */
	    ans = 0;		/* return 0 to say it worked */
	    break;
	 }
	 ans = ans->next;
      }
   } else {
      if (new->que != head) {
	 ans= new->que;
      }
   }
   prc_set_ipl(old_sr);
   return (struct act_q *)ans;
}

void prc_swint0() {		/* signal software interrupt 0 */
    __asm__("mfc0 $2, $13; li $3, 0x100; or $2, $3; mtc0 $2, $13");
}
    
void prc_swint1() {		/* signal software interrupt 1 */
    __asm__("mfc0 $2, $13; li $3, 0x200; or $2, $3; mtc0 $2, $13");
}

struct act_q irq_action;
struct act_q *(*prc_q_action_vec)(struct act_q *new);
void (*process_action_q_vec)(int, int);

struct act_q *prc_q_action(struct act_q *new) {
    if (prc_q_action_vec) return prc_q_action_vec(new);
    return prc_add_q(&irq_action, new);
}

void process_action_q(int old_ps, int new_ps) {
      struct act_q * volatile act;
      void (*rtn)(void *);
      static void (*savrtn)(void *);

      _impure_ptr = action_reent;
      while ((act=irq_action.next) != 0) {
         void *param;
	 irq_action.next = act->next;	/* pluck this entry from the queue */
	 act->next = 0;			/* make sure we don't get in too big of a loop */
	 act->que = 0;			/* timer action seems to want this cleared too */
	 savrtn = rtn = (void (*)(void *))act->action;	/* remember the function */
         param = act->param;		/* remember the parameter */
	 if (rtn) {
	     prc_set_ipl(new_ps);
	     if (rtn != savrtn) {
		prc_panic("Act_q_rtn clobbered");
	     }
	     rtn(param);		/* call his function if there is one */
	     prc_set_ipl(old_ps);	/* restore the SR to pre-action schedule */
	 }
      } 				/* continue until the queue is empty */
      return;
}

#if MAX_AST_QUEUES || MAX_FG_QUEUES
typedef struct astfg {
    struct act_q *top;
    struct _reent *reent;
    volatile int *level;
    int old_ps;
    int new_ps;
    int num_q;
} AstFG;

static void process_astfg_q(AstFG *fg) {
    struct act_q *act, *actp;
    void (*rtn)(void *);
    int ii, didit;

    _impure_ptr = fg->reent;
    do {				/* everytime a function runs, we start over */
	didit = 0;			/* assume we did nothing */
	actp = fg->top;
	for (ii=0; ii < fg->num_q; ++ii, ++actp) {
	    while ((act=actp->next) != 0) {
		void *param;
		actp->next = act->next;	/* pluck this entry from the queue */
		act->next = 0;
		act->que = 0;
		rtn = (void (*)(void *))act->action;	/* remember the function */
		param = act->param;	/* remember the parameter */
		if (rtn) {		/* if there's a function */
		    int prev_lvl = *fg->level;
		    *fg->level = ii;	/* new level */
		    prc_set_ipl(fg->new_ps);
		    rtn(param);		/* call his function if there is one */
		    prc_set_ipl(fg->old_ps);	/* restore the SR to pre-action schedule */
		    *fg->level = prev_lvl;
		    didit = 1;
		    break;
		}
	    } 				/* continue until the queue is empty */
	    if (didit) break;
	}
    } while (didit);
    return;
}
#endif

#if MAX_AST_QUEUES 
int prc_get_astlvl(void) {
    return _guts_astlvl;
}

struct act_q ast_action[MAX_AST_QUEUES];
int (*prc_q_ast_vec)(int level, struct act_q *new);
void (*process_ast_q_vec)(int, int);

int prc_q_ast(int level, struct act_q *new) {
    if (prc_q_ast_vec) return prc_q_ast_vec(level, new);
    if (level < 0) return 1;
    if (level >= MAX_AST_QUEUES) return 2;
    if (prc_add_q(ast_action+level, new)) return 3;
    if (!prc_get_actlvl() && _guts_astlvl < 0) prc_swint1();
    return 0;
}

void process_ast_q(int old_ps, int new_ps) {
    AstFG fg;
    fg.top = ast_action;
    fg.reent = ast_reent;
    fg.level = &_guts_astlvl;
    fg.old_ps = old_ps;
    fg.new_ps = new_ps;
    fg.num_q = MAX_AST_QUEUES;
    
    process_astfg_q(&fg);
    return;
}
#endif			/* MAX_AST_QUEUES > 0 */

#if defined(MAX_FG_QUEUES) && MAX_FG_QUEUES 
int prc_get_fglvl(void) {
    return _guts_fglvl;
}

struct act_q fg_action[MAX_FG_QUEUES];
int (*prc_q_fg_vec)(int level, struct act_q *new);
void (*process_fg_q_vec)(int, int);

int prc_q_fg(int level, struct act_q *new) {
    if (prc_q_fg_vec) return prc_q_fg_vec(level, new);
    if (level < 0) return 1;
    if (level >= MAX_FG_QUEUES) return 2;
    if (prc_add_q(fg_action+level, new)) return 3;
    if (!prc_get_actlvl() && prc_get_astlvl() < 0 && prc_get_fglvl() < 0) prc_swint1();
    return 0;
}

void process_fg_q(int old_ps, int new_ps) {
    AstFG fg;

    fg.top = fg_action;
    fg.reent = fg_reent;
    fg.level = &_guts_fglvl;
    fg.old_ps = old_ps;
    fg.new_ps = new_ps;
    fg.num_q = MAX_FG_QUEUES;
    process_astfg_q(&fg);
    return;
}
#endif			/* MAX_FG_QUEUES > 0 */

extern struct ROM_VECTOR_STR romv_tbl;

#if GAL_NOTES

#define G_MRE	(1<<12)		/* master read error */
#define G_SWE	(1<<13)		/* slave write error */
#define G_MWE	(1<<14)		/* master write error */
#define G_SRE	(1<<15)		/* slave read error */
#define G_ADE	(1<<16)		/* address error */
#define G_MEE	(1<<17)		/* memory error */
#define G_MAB	(1<<18)		/* master abort */
#define G_TAB	(1<<19)		/* target abort */
#define G_RTY	(1<<20)		/* retry counter expired */

void galileoint(U32 *regs) {
    U32 which;
    struct IIO_VECTOR_STR *s;
    void (*f)(U32 *regs);
    struct ROM_VECTOR_STR *romv;

    which = *(VU32*)GALILEO_INT_CAUSE & GALILEO_INTCTL_MASK & 
    		(G_MRE|G_SWE|G_MWE|G_SRE|G_ADE|G_MEE|G_MAB|G_TAB|G_RTY);
    if (!which) return;		/* not our error */

    romv = (struct ROM_VECTOR_STR *)(DRAM_BASE);
    s = (struct IIO_VECTOR_STR *)romv->ROMV_STUB_VECS;
    if (s) {
	f = (void (*)(U32*))s->STUBVEC_FAKE_EH;	/* get pointer to stub's handler */
	if (f) {
	    romv->ROMV_STUB_REASON = (U32)"Galileo reported bus error";
	    f(regs);		/* jump to stub */
	    *(VU32*)GALILEO_INT_CAUSE = ~(G_MRE|G_SWE|G_MWE|G_SRE|G_ADE|G_MEE|G_MAB|G_TAB|G_RTY);
	    return;
	}
    }	    
    while (1) {
	__asm__("BREAK");
    }
    return;
}
#endif

#if TIME_EXCEPTIONS
extern U32 exception_time[2];
U32 prc_get_exception_time( int clear )
{
 U32 tmp = exception_time[0];
 if ( clear ) exception_time[0] = 0;
 return tmp;
}
#endif

int _ice_pkts;

volatile int _guts_inest;

int prc_get_actlvl(void) {
    return _guts_inest;
}

#if (ICELESS_AST && ICELESS_LVL) || (HOST_BOARD == CHAMELEON)
static struct IIO_VECTOR_STR *check_for_iceless_int(U32 *regs) {
   struct ROM_VECTOR_STR *romv = (struct ROM_VECTOR_STR *)DRAM_BASEnc;
   struct IIO_VECTOR_STR *stub_vecs;
# ifndef TWI_THREAD
#  define TWI_THREAD 0
# endif
   int disab=1;

# if HOST_BOARD == CHAMELEON
#  ifdef B_PIC_DBG
#   define IS_ICELESS_INTERRUPT() (INTCTL_CAUSE_T&(1<<B_PIC_DBG))
#  else
#   error Need to define DBG_ASN in config.mac
#   define IS_ICELESS_INTERRUPT() (0)
#  endif
# else
#  define IS_ICELESS_INTERRUPT() (prc_get_cause() & 0x8000)
# endif
   stub_vecs = (struct IIO_VECTOR_STR *)romv->ROMV_STUB_VECS;
   if ( stub_vecs ) {
      if ( IS_ICELESS_INTERRUPT() ) {
	 int (*pfunc)(int);

	 pfunc = (int (*)(int))stub_vecs->STUBVEC_GOT_ATTEN;	/* point to attention handler */
	 if (pfunc) {				/* if there is one */
	    int ans;
	    ans = pfunc(TWI_THREAD);		/* poll for a packet */
	    if (ans) {				/* got a GDB packet */
	       U32 (*efunc)(U32 *);		/* ptr to stub's exception handler */
	       efunc = (U32 (*)(U32*))stub_vecs->STUBVEC_FAKE_EH;
	       efunc(regs);			/* go to stub's exception handler */
	    } else {
	       ++_ice_pkts;			/* something to do to break on */
	    } 
	    disab = 0;				/* don't disable interrupts */
	 }
      } else {
	 disab = 0;				/* don't disable interrupts */
      }
   }
# if HOST_BOARD == CHAMELEON
   if (disab) {
      INTCTL_IE_T &= ~(1<<B_PIC_DBG);	/* disable future iceless interrupts */
   } else {
      void (*pfunc)(int);
      pfunc = (void (*)(int))stub_vecs->STUBVEC_PKTSCAN; /* and we can scan */
      if (pfunc) pfunc(1);		/* scan and call completion routines if any */
   }
# endif
   return stub_vecs;
}
#endif

VU32 pc_at_interrupt;

#if HOST_BOARD == CHAMELEON
# define IH_TYPE void
#else
# define IH_TYPE unsigned long *regs
#endif
    
volatile int exception_count;
volatile int interrupt_count;

void interrupt_handler(IH_TYPE) {
   int which;
   int new, ii, start, did;
   void (*func)(void);
   U32 *ramv;
   struct IIO_VECTOR_STR *stub_vecs;
#if !(ICELESS_AST && ICELESS_LVL)
   struct ROM_VECTOR_STR *romv = (struct ROM_VECTOR_STR *)DRAM_BASEnc;
   stub_vecs = (struct IIO_VECTOR_STR *)romv->ROMV_STUB_VECS;
#endif

   ramv = (U32*)romv_tbl.ROMV_RAMVBR;

   ++interrupt_count;

#if (ICELESS_AST && ICELESS_LVL)
   stub_vecs = check_for_iceless_int(regs);
#endif

#if GAL_NOTES
   if (prc_get_cause()&regs[PS_REGNUM_W]&(0x400<<GALILEO_LVL)) {
	galileoint(regs);
   }
#endif

   ++_guts_inest;

   start = 0;
   do {
       did = 0;			/* and assume we didn't do anything */
#if HOST_BOARD == CHAMELEON
       which = prc_get_cause() & SR_IMASK;
#else
       which = prc_get_cause() & regs[PS_REGNUM_W] &SR_IMASK;
#endif
       for (ii=start, new=0x100<<ii; ii < 8; ++ii, new += new) {
	  if ((new&which) != 0) {
	     if (ii < 2) {
		prc_set_cause(prc_get_cause()&~new);
#if HOST_BOARD != CHAMELEON
		regs[CAUSE_REGNUM_W] &= ~new;	/* ACK the s/w interrupt */
#endif
	     }
	     func = (void (*)(void))ramv[VN_IRQ0 + ii];
	     if (func == 0) {
#if ICELESS_AST && ICELESS_LVL
		if (stub_vecs && ii == 7) continue; /* leave ICELESS interrupts alone */
#endif
		if (ii > 1) {		/* legal to have swint's with no vector */
#if HOST_BOARD != CHAMELEON
		   regs[PS_REGNUM_W] &= ~new; /* don't allow this interrupt anymore */
#endif
		   prc_set_ipl(prc_get_ipl()&~new); /* remember the local value too */
		}
	     } else {
#if HOST_BOARD == CHAMELEON
    		if (!stub_vecs) did = 1;
#else
		if (!stub_vecs || ii != 7) did = 1;
#endif
		func();		/* go to user's interrupt routine */
	     }
	  }
       }
       start = 2;		/* next time we skip the s/w interrupt check */
#if (ICELESS_AST && ICELESS_LVL)
       if (stub_vecs) check_for_iceless_int(regs); /* check again for iceless ints */
#endif
   } while (did);
#if ICELESS_AST && ICELESS_LVL
   if (stub_vecs) {		/* if there was an ICELESS interrupt */
      void (*pfunc)(int);
      pfunc = (void (*)(int))stub_vecs->STUBVEC_PKTSCAN; /* and we can scan */
      if (pfunc) pfunc(1);	/* scan and call completion routines if any */
   }
#endif
   if (_guts_inest == 1) {
      int old_ps, new_ps;
#if HOST_BOARD != CHAMELEON
      pc_at_interrupt = regs[PC_REGNUM_W];
#endif
      old_ps = prc_get_ipl();	/* interrupts are disabled at this point */
      new_ps = old_ps | NU_IE;	/* allow interrupts for action routine execution */
      if (process_action_q_vec) {
	  process_action_q_vec(old_ps, new_ps);
      } else {
	  process_action_q(old_ps, new_ps);
      }
   }
   --_guts_inest;
#if MAX_AST_QUEUES 
   if (!_guts_inest && _guts_astlvl < 0) { /* If no actions and no AST level */
      int old_ps, new_ps;
      old_ps = prc_get_ipl();	/* interrupts are disabled at this point */
      new_ps = old_ps | NU_IE;	/* allow interrupts for ast routine execution */
      if (process_ast_q_vec) {
	  process_ast_q_vec(old_ps, new_ps);
      } else {
	  process_ast_q(old_ps, new_ps);
      }
   }
#endif
#if MAX_FG_QUEUES 
   if (!_guts_inest && _guts_astlvl < 0 && _guts_fglvl < 0) { /* If no actions and no AST level */
      int old_ps, new_ps;
      old_ps = prc_get_ipl();	/* interrupts are disabled at this point */
      new_ps = old_ps | NU_IE;	/* allow interrupts for ast routine execution */
      if (process_fg_q_vec) {
	  process_fg_q_vec(old_ps, new_ps);
      } else {
	  process_fg_q(old_ps, new_ps);
      }
   }
#endif
#if !NO_BLINKING_LED && defined(LED_OUT)
   if (_guts_inest) {
	*(VU32*)LED_OUT &= ~(1<<B_LED_YEL);
   } else {
	*(VU32*)LED_OUT |= 1<<B_LED_YEL;
   }
#endif
   return;
}

extern void wait_forever();

static const char * const pm_cause_msgs[] = {
      "Interrupt",
      "Write to read-only memory",
      "Read from non-existant memory",
      "Write to non-existant memory",
      "Address alignment error on read",
      "Address alignment error on write",
      "Bus error on I fetch",
      "Bus error on D fetch",
      "SYCALL",
      "Breakpoint",			/* breakpoint */
      "Reserved Instruction",
      "CoProcessor unusable",
      "Arithmetic Overflow",
      "Trap exception",
      "Reserved exception",
      "Floating point exception",
      "Undefined exception"
};

#if 0
/*************************************************************************
 * gcc has assigned the following numbers on the BREAK instruction to report
 * various conditions at runtime. We have also assigned one for "unhandled
 * interrupt" for use on the RISQ, HCR4K and MB4600 boards. Some of these
 * breakpoints are not likely to be used by the 4K compiler.
 *
 * If you want to add more, stick them just before "Multiply overflow".
 *************************************************************************/

static const char * const pm_break_msgs[] = {
      "Debug breakpoint",			/* BREAK 0 */
      "Kernel breakpoint",			/* BREAK 1 */
      "Abort",					/* BREAK 2 */
      "Taken BD emulation",			/* BREAK 3 */
      "Not taken BD emulation",			/* BREAK 4 */
      "Single step breakpoint",			/* BREAK 5 */
      "Overflow check",				/* BREAK 6 */
      "Divide by zero",				/* BREAK 7 */
      "Range check",				/* BREAK 8 */
      "Unhandled interrupt",			/* BREAK 9 */
      "Multiply overflow",			/* BREAK 1023 (this MUST be second to last) */
      "Breakpoint"				/* any other break (this MUST be last) */
};
#endif

#define NUM_ELEMS(array) (sizeof(array)/sizeof(array[0]))
#define MAX_CAUSE_MSG (NUM_ELEMS(pm_cause_msgs) - 1)
#define MAX_BREAK_MSG (NUM_ELEMS(pm_break_msgs) - 2)
#define MULOVF_MSG    (NUM_ELEMS(pm_break_msgs) - 2)
#define BREAK_MSG     (NUM_ELEMS(pm_break_msgs) - 1)

const char *get_pm_msg(int cause) {
   int ii;
   const char *ans;

   ii = (cause&0x7C)/4;
   if (ii > MAX_CAUSE_MSG) ii = MAX_CAUSE_MSG;
#if 0
   if (ii == 9) {		/* if breakpoint */
      U32 jj, lpc;
      lpc = regs[PC_REGNUM_W]|0x20000000;
      if ( ((lpc&3) == 0) && 
	  ( (lpc >= DRAM_BASEnc && lpc < (DRAM_BASEnc+0x08000000)) ||
            (lpc >= EXPAN2_BASE && lpc < (EXPAN2_BASE+0x00800000)) ) ) {
	  jj = *(VU32*)lpc;	/* get the failing instruction */
	  jj >>= 16;		/* get the code bits */
	  jj &= 0x3FF;		/* isolate them */
	  if (jj == 1023) {
	     jj = MULOVF_MSG;
	  } else if (jj >= MAX_BREAK_MSG) {
	     jj = BREAK_MSG;
	  }
      } else {
         jj = BREAK_MSG;
      }
      ans = pm_break_msgs[jj];
   } else {
      ans = pm_cause_msgs[ii];
   }
#else
   ans = pm_cause_msgs[ii];
#endif
   return ans;
}

static void update_pm(U32 *regs) {
#if !BOOT_FROM_DISK && !EPROM_ST
# if REGISTER_SIZE == 4
    memcpy((char *)(pm_data.pm_regs+1), (char *)(regs+1), 31*4);
# else
    {
       int jj, kk;
       for (jj=1, kk=AT_REGNUM_W; jj<32; ++jj, kk += 2) {
  	  pm_data.pm_regs[jj] = regs[kk];
       }
    }
# endif
    pm_data.pm_regs[0] = 0;		/* r0 is always 0 */
    pm_data.pm_cause = regs[CAUSE_REGNUM_W];	/* remember the cause */
    pm_data.pm_stack = (U32*)regs[SP_REGNUM_W];
    pm_data.pm_stkupper = &INIT_SP;
    pm_data.pm_stklower = (U32*)prc_extend_bss(0);
    pm_data.pm_stkrelative = pm_data.pm_stack;
    pm_data.pm_badvaddr = regs[BADVADDR_REGNUM_W];
    pm_data.pm_pc = regs[PC_REGNUM_W];
    pm_data.pm_sr = regs[PS_REGNUM_W];
    ++pm_data.pm_cntr;
    pm_data.pm_msg = get_pm_msg(regs[CAUSE_REGNUM_W]);
#endif			/* !BOOT_FROM_DISK && !EPROM_ST */
}

#if DO_STACK_WATERMARK
U32 stack_watermark;
#endif

#if INCLUDE_SYSCALL
# ifndef MAX_SYSCALLS
#  define MAX_SYSCALLS	16
# endif

static int (*syscall_vectors[MAX_SYSCALLS])(void *a, ...);

int (*prc_set_syscall(int which, int (*func)(void *a, ...)))(void *a, ...) {
    int (*f)(void *,...);
    
    if (which < 0 || which >= MAX_SYSCALLS) return 0;
    f = syscall_vectors[which];
    syscall_vectors[which] = func;
    return f;
}

static void syscall(U32 *regs) {
    void *a, *b, *c;
    int which;
    int (*f)(void *,...)=0;

    which = regs[A0_REGNUM_W];
    if (which >= MAX_SYSCALLS || !(f=syscall_vectors[which]) ) {
	update_pm(regs);
	wait_forever();
    }
    a = (void *)regs[A0_REGNUM_W+1*REGISTER_SIZE/4];
    b = (void *)regs[A0_REGNUM_W+2*REGISTER_SIZE/4];
    c = (void *)regs[A0_REGNUM_W+3*REGISTER_SIZE/4];
    which = f(a, b, c);
    regs[V0_REGNUM_W] = which;	/* return result to caller */
    regs[EPC_REGNUM_W] += 4;	/* advance PC over SYSCALL instruction */
    return;
}
#endif

unsigned long *exception_handler(unsigned long *regs) {
   int ii;
   U32 *ramv;
   struct _reent *save_impure;

   save_impure = _impure_ptr;
   _impure_ptr = interrupt_reent;

#if DO_STACK_WATERMARK
   if ((U32)&ramv  > ((U32)&INIT_SP - 1024*1024)) { /* if not Nucleus stack */
	if ( (U32)&ramv < ((U32)&INIT_SP-stack_watermark) ) {
	    stack_watermark = (U32)&INIT_SP - (U32)&ramv;
	}
   }
#endif

   ramv = (U32*)romv_tbl.ROMV_RAMVBR;

   ++exception_count;
   if ((ii=(prc_get_cause()>>2)&0x1F) != 0) {
      void (*func)(U32 *);
      func = (void (*)(U32*))ramv[ii+VN_TLBM-1];
      if (func) {
	  func(regs);
      } else {	 
	  if (ii == 6 || ii == 7) {	/* if a bus error */
	     struct IIO_VECTOR_STR *s;
	     s = (struct IIO_VECTOR_STR *)romv_tbl.ROMV_STUB_VECS;
	     if (s) {
		 func = (void (*)(U32*))s->STUBVEC_FAKE_EH;	/* get pointer to stub's handler */
		 if (func) {
		    func(regs);	/* if there is one, go to the stub */
		    _impure_ptr = save_impure;
		    return regs; /* if he continues, he must have patched it */
		 }
	     }
	  }	     
          update_pm(regs);
	  wait_forever();
      }
   } else {
#if HOST_BOARD != CHAMELEON
      interrupt_handler(regs);
#else
      check_for_iceless_int(regs);
      interrupt_handler();
#endif
   }

   _impure_ptr = save_impure;
   return regs;
}

#if (HOST_BOARD == PHOENIX_AD) || (HOST_BOARD == FLAGSTAFF) || (HOST_BOARD == SEATTLE) || (HOST_BOARD == VEGAS)
# define EE_TYPE VU32 *
#else
# define EE_TYPE VU8 *
#endif

void eer_write_byte( EE_TYPE where, EE_TYPE unlock, int what) {
#if !BOOT_FROM_DISK && !NO_EER_WRITE && !EPROM_ST
   int old_sr;

   old_sr = prc_set_ipl(INTS_OFF);
   *unlock = 0;
   *where = what;
# ifdef FLUSH_WB
   FLUSH_WB();
# endif
   prc_set_ipl(old_sr);
#endif
   return;
}

int pktQueRecv(PktIOStruct *pkt) {
    struct ROM_VECTOR_STR *romv = (struct ROM_VECTOR_STR *)DRAM_BASEnc;
    struct IIO_VECTOR_STR *s;
    int (*func)(PktIOStruct *);
    int sts=0;

    s = (struct IIO_VECTOR_STR *)romv->ROMV_STUB_VECS;
    if (s) {
	func = (int (*)(PktIOStruct *))s->STUBVEC_PKTQRECV;
	if (func) {
	    sts = func(pkt);
	}
    }
    return sts;
}

int pktQueSend(PktIOStruct *pkt, int flag) {
    struct ROM_VECTOR_STR *romv = (struct ROM_VECTOR_STR *)DRAM_BASEnc;
    struct IIO_VECTOR_STR *s;
    int (*func)(PktIOStruct *);
    int sts=0;

    s = (struct IIO_VECTOR_STR *)romv->ROMV_STUB_VECS;
    if (s) {
	func = (int (*)(PktIOStruct *))s->STUBVEC_PKTQSEND;
	if (func) {
	    sts = func(pkt);
	}
    }
    return sts;
}

void *pktInit(void) {
    struct ROM_VECTOR_STR *romv = (struct ROM_VECTOR_STR *)DRAM_BASEnc;
    struct IIO_VECTOR_STR *s;
    void *(*func)(void);

    s = (struct IIO_VECTOR_STR *)romv->ROMV_STUB_VECS;
    
    if (s) {
	func = (void *(*)(void))s->STUBVEC_PKTINIT;
	if (func) {
	    return func();
	}
    }
    return 0;
}

PktIOStruct *pktPoll(int board, int flag, int channel, int thread) {
    struct ROM_VECTOR_STR *romv = (struct ROM_VECTOR_STR *)DRAM_BASEnc;
    struct IIO_VECTOR_STR *s;
    PktIOStruct *(*func)(int, int, int, int);

    s = (struct IIO_VECTOR_STR *)romv->ROMV_STUB_VECS;
    if (s) {
	func = (PktIOStruct *(*)(int, int, int, int))s->STUBVEC_PKTPOLL;
	if (func) {
	    return func(board, flag, channel, thread);
	}
    }
    return 0;
}

#if !defined(EXTERN_GETENV)
char *getenv(const char *arg) {
    return 0;
}
#endif
@


1.85
log
@Updated a comment.
@
text
@d2 1
a2 1
 * $Id: phx_shims.c,v 1.84 1997/12/06 00:04:09 shepperd Exp shepperd $
d594 45
d658 9
a666 33
    struct act_q * volatile act;
    void (*rtn)(void *);
    static void (*savrtn)(void *);
    int ii, didit;

    _impure_ptr = ast_reent;
    do {				/* everytime a function runs, we start over */
	didit = 0;			/* assume we did nothing */
	for (ii=0; ii < MAX_AST_QUEUES; ++ii) {
	    while ((act=ast_action[ii].next) != 0) {
		void *param;
		ast_action[ii].next = act->next; /* pluck this entry from the queue */
		act->next = 0;			/* make sure we don't get in too big of a loop */
		act->que = 0;			/* timer action seems to want this cleared too */
		savrtn = rtn = (void (*)(void *))act->action;	/* remember the function */
		param = act->param;		/* remember the parameter */
		if (rtn) {
		    int prev_lvl = _guts_astlvl;
		    _guts_astlvl = ii;		/* new AST level */
		    prc_set_ipl(new_ps);
		    if (rtn != savrtn) {
			prc_panic("Ast_q_rtn clobbered");
		    }
		    rtn(param);		/* call his function if there is one */
		    prc_set_ipl(old_ps);	/* restore the SR to pre-action schedule */
		    _guts_astlvl = prev_lvl;
		    didit = 1;
		    break;
		}
	    } 				/* continue until the queue is empty */
	    if (didit) break;
	}
    } while (didit);
d690 1
a690 4
    struct act_q * volatile act;
    void (*rtn)(void *);
    static void (*savrtn)(void *);
    int ii, didit;
d692 7
a698 28
    _impure_ptr = fg_reent;
    do {				/* everytime a function runs, we start over */
	didit = 0;			/* assume we did nothing */
	for (ii=0; ii < MAX_FG_QUEUES; ++ii) {
	    while ((act=fg_action[ii].next) != 0) {
		void *param;
		fg_action[ii].next = act->next; /* pluck this entry from the queue */
		act->next = 0;			/* make sure we don't get in too big of a loop */
		act->que = 0;			/* timer action seems to want this cleared too */
		savrtn = rtn = (void (*)(void *))act->action;	/* remember the function */
		param = act->param;		/* remember the parameter */
		if (rtn) {
		    int prev_lvl = _guts_fglvl;
		    _guts_fglvl = ii;		/* new FG level */
		    prc_set_ipl(new_ps);
		    if (rtn != savrtn) {
			prc_panic("FG_q_rtn clobbered");
		    }
		    rtn(param);		/* call his function if there is one */
		    prc_set_ipl(old_ps);	/* restore the SR to pre-action schedule */
		    _guts_fglvl = prev_lvl;
		    didit = 1;
		    break;
		}
	    } 				/* continue until the queue is empty */
	    if (didit) break;
	}
    } while (didit);
@


1.84
log
@Added a prc_q_fg() function to add a game 'foreground'
task independent of AST and action and is interruptable
by AST and action functions.
@
text
@d2 1
a2 1
 * $Id: phx_shims.c,v 1.83 1997/10/15 06:07:37 shepperd Exp shepperd $
d687 1
a687 1
		    _guts_fglvl = ii;		/* new AST level */
@


1.83
log
@Moved the UART output function (putc) to phx_root.
Shims_putc() now calls prc_putc() which is in root.
@
text
@d2 1
a2 1
 * $Id: phx_shims.c,v 1.82 1997/10/06 17:21:49 shepperd Exp shepperd $
d171 4
d218 4
a594 1
    
d650 56
d930 12
@


1.82
log
@Renamed extend_bss to prc_extend_bss.
@
text
@d2 1
a2 1
 * $Id: phx_shims.c,v 1.81 1997/10/03 21:58:00 shepperd Exp shepperd $
a118 6
#define PUTC_BLINK_TIME (0x40000)
#ifndef BR9600
# define BR9600  IO_UART_CTL_9600_BAUD
#endif
#define SHIMS_UART_ENAB (UART_ENABLE | IO_UART_CTL_IGNORE_CTS_IN | BR9600)

a121 2
    U32 oldio;
    int blink, uinit;
d124 1
a124 1
	shims_putc_vec(c);
d128 3
a130 1
    if (shims_putc_disable) return;	/* don't do anything if we've been cut off */
a131 50
    blink = 0;
    oldio = IO_CONTROL;
#ifdef LED_OUT
    *(VU32 *)LED_OUT &= ~(1<<B_LED_YEL); /* turn on YEL LED */
#endif
    IO_CONTROL = 0;			/* disable other interrupts */
    uinit = SHIMS_UART_ENAB;
#if defined(IO_DIPSW)
    if (!(*(VU32*)IO_DIPSW&IO_DIPSW2)) uinit &= ~IO_UART_CTL_IGNORE_CTS_IN;
#endif
    if ((UART_CONTROL&0xFFFF) != uinit) {
	UART_CONTROL = uinit;		/* init the uart, set baud rate */
	prc_wait_n_usecs(100000);	/* give it time to settle */
	if ((UART_CONTROL&0xFFFF) != uinit) {
	    while (1) {
#ifdef LED_OUT
	        prc_blink_led((1<<B_LED_RED)|(1<<B_LED_YEL), 0);
#endif
	    }
	}
    }
    while (!(IO_STATUS&UART_XMT)) {
	++blink;
	if ((blink&(PUTC_BLINK_TIME-1)) == 0) {
#ifdef LED_OUT
	    if ((blink&PUTC_BLINK_TIME)) {
		*(VU32*)LED_OUT |= (1<<B_LED_YEL);	/* blink the the YEL led */
	    } else {
		*(VU32*)LED_OUT &= ~(1<<B_LED_YEL);	/* blink the the YEL led */
	    }
#endif
	}
    }
    UART_XMITTER = c;			/* send the character */
    while (!(IO_STATUS&UART_XMT)) {
	++blink;
#ifdef LED_OUT
	if ((blink&(PUTC_BLINK_TIME-1)) == 0) {
	    if ((blink&PUTC_BLINK_TIME)) {
		*(VU32*)LED_OUT |= (1<<B_LED_YEL);	/* blink the the YEL led */
	    } else {
		*(VU32*)LED_OUT &= ~(1<<B_LED_YEL);	/* blink the the YEL led */
	    }
	}
#endif
    }
#ifdef LED_OUT
    *(VU32 *)LED_OUT |= (1<<B_LED_YEL); /* turn off YEL LED */
#endif
    IO_CONTROL = oldio;
d179 4
d247 3
a249 1
    BLAB("\r\nEPROM Boot code. Version: " __DATE__ " " __TIME__ "\r\n");
a250 1
    BLAB("Copyright 1996,1997 Atari Games, Corp.\r\n");
@


1.81
log
@Removed references to xxx_REENT_SIZE.
Replaced reference to bss_end with extend_bss(0).
@
text
@d2 1
a2 1
 * $Id: phx_shims.c,v 1.80 1997/09/24 02:54:29 shepperd Exp shepperd $
d1035 1
a1035 1
    pm_data.pm_stklower = (U32*)extend_bss(0);
@


1.80
log
@Fixed bug where iceless wasn't being called enough in
the interrupt routine.
@
text
@d2 1
a2 1
 * $Id: phx_shims.c,v 1.79 1997/09/23 00:09:23 shepperd Exp shepperd $
d50 2
a51 2
extern struct _reent *mainline_reent, *interrupt_reent, *_impure_ptr;
#if defined(AST_REENT_SIZE)
a52 2
#endif
#if defined(ACTION_REENT_SIZE)
d54 1
a54 1
#endif
a367 1
extern U32 bss_end;
a616 1
#if defined(ACTION_REENT_SIZE)
a617 1
#endif
a661 1
#if defined(ACTION_REENT_SIZE)
a662 1
#endif
d1035 1
a1035 1
    pm_data.pm_stklower = &bss_end;
@


1.79
log
@Added reents for ast, action, interrupt and mainline.
_impure_ptr is bent at interrupt and restored at return.
@
text
@d2 1
a2 1
 * $Id: phx_shims.c,v 1.78 1997/08/19 21:09:26 forrest Exp shepperd $
d891 3
@


1.78
log
@Added a line to prc_add_q which sets the new->que field if
the structure is already on the queue but this field is 0.
@
text
@d2 1
a2 1
 * $Id: phx_shims.c,v 1.77 1997/08/16 23:34:31 shepperd Exp forrest $
d50 8
a112 2
    extern void reent_init(void);
    reent_init();
d620 3
d667 3
d1092 4
d1121 1
d1138 1
@


1.77
log
@Allowed for shims_putc to be vectored.
@
text
@d2 1
a2 1
 * $Id: phx_shims.c,v 1.76 1997/08/02 22:09:30 shepperd Exp shepperd $
d570 1
@


1.76
log
@Globaled ast_action[].
@
text
@d2 1
a2 1
 * $Id: phx_shims.c,v 1.75 1997/08/02 21:19:52 shepperd Exp shepperd $
d121 2
d126 5
@


1.75
log
@Added some Xinu interface functions and vectors. Namely,
prc_q_action_vec, prc_q_ast_vec, process_action_q_vec,
process_ast_q_vec and prototyped _guts_inest and _guts_astlvl.
@
text
@d2 1
a2 1
 * $Id: phx_shims.c,v 1.74 1997/08/02 00:14:03 albaugh Exp shepperd $
d631 1
a631 1
static struct act_q ast_action[MAX_AST_QUEUES];
@


1.74
log
@Protected smashing of go_to_self_test, as it is not
always declared in phx_root.mac.
@
text
@d2 1
a2 1
 * $Id: phx_shims.c,v 1.73 1997/08/01 22:06:11 albaugh Exp albaugh $
d212 2
a213 2
#if MAX_AST_QUEUES
int _guts_astlvl;
d251 1
a251 1
#if MAX_AST_QUEUES
d584 8
d593 2
d597 1
a600 3
volatile int exception_count;
volatile int interrupt_count;

d625 1
a625 9
void prc_swint0() {		/* signal software interrupt 0 */
    __asm__("mfc0 $2, $13; li $3, 0x100; or $2, $3; mtc0 $2, $13");
}
    
void prc_swint1() {		/* signal software interrupt 1 */
    __asm__("mfc0 $2, $13; li $3, 0x200; or $2, $3; mtc0 $2, $13");
}

#if MAX_AST_QUEUES
d632 2
d636 1
d733 1
a733 1
volatile int _guts_inest, _ice_pkts;
d735 2
d803 3
d886 5
a890 1
      process_action_q(old_ps, new_ps);
d893 1
a893 1
# if MAX_AST_QUEUES
d898 5
a902 1
      process_ast_q(old_ps, new_ps);
d904 1
a904 1
# endif
@


1.73
log
@Add function exit_to_game() to this file, rather than
having it implemented in gamedefs.c, where changes tend
not to propogate, or in selftest.c, where the wierdness
of doing this function on any particular hardware does
not belong.
@
text
@d2 1
a2 1
 * $Id: phx_shims.c,v 1.72 1997/08/01 03:27:14 shepperd Exp albaugh $
d405 1
d407 1
@


1.72
log
@DBE and IBE exceptions will transfer to stub if appropriate.
@
text
@d2 1
a2 1
 * $Id: phx_shims.c,v 1.71 1997/07/25 03:00:59 shepperd Exp shepperd $
d389 19
@


1.71
log
@Added code to handle syscall exceptions.
@
text
@d2 1
a2 1
 * $Id: phx_shims.c,v 1.70 1997/07/20 01:51:22 shepperd Exp shepperd $
d1053 11
@


1.70
log
@Paren out of place in decode of cause register in
exception_handler.
@
text
@d2 1
a2 1
 * $Id: phx_shims.c,v 1.69 1997/07/17 22:40:50 shepperd Exp shepperd $
d220 4
d333 4
d994 36
@


1.69
log
@Made _guts_astlvl global instead of static so the exception
timer can get at it.
./
@
text
@d2 1
a2 1
 * $Id: phx_shims.c,v 1.68 1997/07/17 16:59:10 shepperd Exp shepperd $
d1003 1
a1003 1
   if (((ii=prc_get_cause()>>2)&0x1F) != 0) {
@


1.68
log
@Protected reference to B_PIC_DBG.
@
text
@d2 1
a2 1
 * $Id: phx_shims.c,v 1.67 1997/07/11 22:39:38 shepperd Exp shepperd $
d213 1
a213 1
static int _guts_astlvl;
@


1.67
log
@Ok, it seems to work for gdb on non-Chameleon boards.
@
text
@d2 1
a2 1
 * $Id: phx_shims.c,v 1.66 1997/07/11 20:45:32 shepperd Exp shepperd $
d717 6
a722 1
#  define IS_ICELESS_INTERRUPT() (INTCTL_CAUSE_T&(1<<B_PIC_DBG))
@


1.66
log
@Numerous fixes to support iceless on Chameleon boards.
These changes might have broken iceless ints on non
Chameleon boards. Don't use it until I say it's ok.
@
text
@d2 1
a2 1
 * $Id: phx_shims.c,v 1.65 1997/07/10 18:53:13 shepperd Exp shepperd $
d780 1
a780 1
   stub_vecs = check_for_iceless_int(IH_TYPE);
@


1.65
log
@Protected reference to FLUSH_WB().
@
text
@d2 1
a2 1
 * $Id: phx_shims.c,v 1.64 1997/07/10 18:15:25 shepperd Exp shepperd $
d255 6
a260 1
# if ICELESS_MANY
d262 2
a263 2
# else
#  if ICELESS_LVL
d265 1
d707 49
d769 2
a770 1
#if ICELESS_LVL 
d772 1
a772 4
 #if ICELESS_AST
   struct IIO_VECTOR_STR *stub_vecs = 0;
   U32 (*efunc)(U32 *);			/* ptr to stub's exception handler */
 #endif
d779 2
a780 22
#if ICELESS_AST && ICELESS_LVL
# ifndef TWI_THREAD
#  define TWI_THREAD 0
# endif
# define IS_ICELESS_INTERRUPT() (prc_get_cause() & 0x8000)
   if ( IS_ICELESS_INTERRUPT() ) {			/* if iceless interrupt */
      stub_vecs = (struct IIO_VECTOR_STR *)romv->ROMV_STUB_VECS;
      if (stub_vecs) {				/* if the iceless is loaded ...*/
          int (*pfunc)(int);
	  pfunc = (int (*)(int))stub_vecs->STUBVEC_GOT_ATTEN;	/* point to attention handler */
	  if (pfunc) {				/* if there is one */
	     int ans;
	     ans = pfunc(TWI_THREAD);		/* poll for a packet */
	     if (ans) {				/* got a GDB packet */
		efunc = (U32 (*)(U32*))stub_vecs->STUBVEC_FAKE_EH;
		efunc(regs);			/* go to stub's exception handler */
	     } else {
		++_ice_pkts;			/* something to do to break on */
	     } 
	 }
      }
   }
d819 2
a820 2
#if !ICELESS_LVL
    		did = 1;
d822 1
a822 5
		{
		    if (!romv->ROMV_STUB_EH) {	/* if the iceless is not loaded ...*/
			if (ii != 7) did = 1;	/* iceless interrupts don't count */
		    }
		}
d998 1
a998 1
   if ((ii=(regs[CAUSE_REGNUM_W]>>2)&0x1F) != 0) {
d1011 1
@


1.64
log
@Added $Id$. Added support for chameleon iceless.
@
text
@d2 1
a2 1
 * $Id$
d1002 1
d1004 1
@


1.63
log
@Protected references to BLABx().
@
text
@d2 1
a2 1
 *	phx_shims.c
d714 1
a714 1
#if ICELESS_LVL
d730 2
a731 1
   if (prc_get_cause() & 0x8000) {		/* if iceless interrupt */
@


1.62
log
@Added Chameleon support.
@
text
@d196 3
d204 4
@


1.61
log
@Added code to set new variable pc_at_interrupt.
@
text
@d79 1
d81 1
d84 1
d87 2
d94 4
a98 1
	*(VU32*)GALILEO_INT_CAUSE = ~TM3_NOTES; /* ack any pending timer interrupts */
d208 5
a212 1
    
a215 1

d233 6
d257 1
d259 1
a259 1

d263 4
a266 1
# ifdef IO_DIPSW
d268 1
d270 1
d272 2
a273 1
    BLAB("Copyright 1996 Atari Games, Corp.\r\n");
d296 1
d299 5
d324 1
d485 3
d489 1
d491 1
a491 1
#if TIMER_HISTORY
d493 1
a493 1
#endif
d498 3
d695 6
d702 1
a702 1
void interrupt_handler(unsigned long *regs) {
d753 3
d757 1
a757 1
       prc_set_cause(which&~0x300);	/* zap swint bits */
d760 6
a765 1
	     if (ii < 2) regs[CAUSE_REGNUM_W] &= ~new;	/* ACK the s/w interrupt */
d772 1
d774 1
d802 1
d804 1
d814 1
a814 1
      new_ps = old_ps | NU_IE;	/* allow interrupts for action routine execution */
d971 1
d973 3
d977 1
@


1.60
log
@Removed redundant check for BLAB mode.
@
text
@d655 2
d748 1
@


1.59
log
@Corrected call to tq_maint to use correct time.
@
text
@a119 3
#ifdef IO_DIPSW
    if ((*(VU32*)IO_DIPSW&(IO_DIPSW0|IO_DIPSW1)) != 0) return;
#endif
@


1.58
log
@Allowed for dynamic resolution. I.E. AN_VIS_COL et. al. can be made
into ints instead of #defines. On 3dfx systems this is accompolished
by defining the following in config.mac:
DEC_CONST DYNAMIC_VIS_PIX 1
DEC_CONST VIS_H_PIX_MAX whatever
DEC_CONST VIS_V_PIX_MAX whatever
After this, AN_VIS_COL, AN_VIS_ROW, VIS_V_PIX, VIS_H_PIX and
SST_RESOLUTION become "extern int" instead of #defines.
The new #defines AN_VIS_ROW_MAX and AN_VIS_COL_MAX are
created (computed from VIS_H_PIX_MAX, VIS_V_PIX_MAX) so
local arrays can be declared and this is the principle changed
to this file.
@
text
@d424 2
d427 2
a428 1
   ++timer_ints;
d430 1
d432 5
a436 5
    start = prc_get_count();
    timer_history[timer_history_nxt] = start - timer_history[timer_history_nxt];
    ++timer_history_nxt;
    if (timer_history_nxt >= n_elts(timer_history)) timer_history_nxt = 0;
    timer_history[timer_history_nxt] = start;
d439 1
a439 1
    if (!dow_q.func) {
d443 5
d449 2
a450 4
#endif
   if (his_zclock) *his_zclock += 1;
   if (tpllvec) tpllvec();
   if (timervec) timervec();		/* call game's interrupt */
d452 3
a454 5
   /* maintain the timer queue by running tq_maint() with an
    * argument that says it has been 1087 microseconds since the
    * last call.
    */
   tq_maint(1087);			/* at 60HZ */
@


1.57
log
@Added !EPROM_ST and !NO_WODG to various places.
@
text
@d245 2
a247 1
    prc_wait_n_usecs(100000);
@


1.56
log
@Fixed bug in exception dispatching.
@
text
@d55 1
a55 1
#if !BOOT_FROM_DISK
d288 1
a288 1
#if !BOOT_FROM_DISK
d303 1
a303 1
# if !BOOT_FROM_DISK
d323 1
a323 1
#if !BOOT_FROM_DISK
d328 1
a328 1
#if !BOOT_FROM_DISK && defined(WDOG)
d335 1
a335 1
#if !BOOT_FROM_DISK && defined(WDOG)
d855 1
a855 1
#if !BOOT_FROM_DISK
d877 1
a877 1
#endif			/* !BOOT_FROM_DISK */
d921 1
a921 1
#if !BOOT_FROM_DISK && !NO_EER_WRITE
@


1.55
log
@Added a stack_watermark record.
@
text
@d900 2
a901 2
      void (*func)();
      func = (void (*)())ramv[ii+VN_TLBM-1];
d903 1
a903 1
	  func();
@


1.54
log
@Added space in version number.
@
text
@d17 2
d880 4
d887 8
@


1.53
log
@shims_putc now is turned off by setting global shims_putc_disable.
Added a BLAB copyright and version number message.
@
text
@d248 1
a248 1
    BLAB("\r\nEPROM Boot code. Version: " __DATE__ __TIME__ "\r\n");
@


1.52
log
@Added some BLAB messages.
@
text
@d100 1
d102 3
d113 5
a117 1
    int blink = 0, uinit;
d175 3
a177 3
#ifdef IO_DIPSW
    if ((*(VU32*)IO_DIPSW&(IO_DIPSW0|IO_DIPSW1)) != 0) return 0;
#endif
d245 5
a249 1
    BLAB("Shims: Finished unlock.\r\n");
@


1.51
log
@Added NU_IE definition for Nucleus patch.
@
text
@d238 8
@


1.50
log
@Fixed ICELESS_LVL references to be accurate for both AD and Phoenix.
@
text
@d35 4
d722 1
a722 1
      new_ps = old_ps | SR_IE;	/* allow interrupts for action routine execution */
d730 1
a730 1
      new_ps = old_ps | SR_IE;	/* allow interrupts for action routine execution */
@


1.49
log
@Added call to prc_set_cause to zap swint bits in interrupt_handler.
@
text
@d648 1
a648 1
   if (prc_get_cause() & (0x100<<ICELESS_LVL)) { /* if iceless interrupt */
d686 1
a686 1
		if (stub_vecs && ii == ICELESS_LVL) continue; /* leave ICELESS interrupts alone */
@


1.48
log
@Added support and detection for SEATTLE and VEGAS host boards.
@
text
@d679 1
@


1.47
log
@Keyed ICELESS interrupt detection on variable ICELESS_AST instead
of HOST_BOARD == PHOENIX_AD. Corrected compile time error if
ICELESS_AST == 0.
@
text
@d201 1
a201 1
#if HOST_BOARD == PHOENIX_AD
d875 1
a875 1
#if (HOST_BOARD == PHOENIX_AD) || (HOST_BOARD == FLAGSTAFF)
@


1.46
log
@Fixed Galileo interrupt ACK.
Added code to handle ICELESS interrupts and scan for iceless
packets (on AD boards only; these changes need to be added to
Flagstaff boards too shortly).
@
text
@d632 1
a632 1
#if (HOST_BOARD == PHOENIX_AD) && ICELESS_LVL
d634 1
d637 1
d644 1
a644 1
#if (HOST_BOARD == PHOENIX_AD) && ICELESS_LVL
d684 1
a684 1
#if ICELESS_LVL
d707 1
a707 1
#if (HOST_BOARD == PHOENIX_AD) && ICELESS_LVL
@


1.45
log
@Allowed for blinking GREEN led to be conditionalled out.
@
text
@d84 1
a84 1
	*(VU32*)GALILEO_INT_CAUSE &= ~TM3_NOTES; /* ack any pending timer interrupts */
d433 1
a433 1
   *cause &= ~TM3_NOTES;		/* ack the interrupt */
d598 1
d600 1
a600 1
	    *(VU32*)GALILEO_INT_CAUSE &= ~(G_MRE|G_SWE|G_MWE|G_SRE|G_ADE|G_MEE|G_MAB|G_TAB|G_RTY);
d621 1
a621 1
volatile int _guts_inest;
d632 5
d642 23
d670 1
d682 3
a693 1
		    struct ROM_VECTOR_STR *romv = (struct ROM_VECTOR_STR *)DRAM_BASEnc;
d705 7
@


1.44
log
@Corrected conditional around a LED_OUT.
@
text
@d688 1
a688 1
#ifdef LED_OUT
@


1.43
log
@Removed all references to ICLESS_STUB. The stub does not
use this module anymore.
@
text
@d688 1
d694 1
@


1.42
log
@Added a WDOG kick to proc_reboot.
..
@
text
@a34 4
#if !defined(ICELESS_STUB)
#define ICELESS_STUB 0
#endif

d39 1
a39 6
#if ICELESS_STUB == 0
#  define offsetof(s, m)    (int)(&(((s *)0)->m))

#  if HOST_BOARD != MB4600
#   include <eer_defs.h>
#  endif
d41 2
a42 1
#  include <os_proto.h>
a48 2
# endif			/* ICELESS_STUB == 0 */

a190 1
#if ICELESS_STUB == 0
a246 3
#else			/* ICELESS_STUB == 0 */
   extern int main();
#endif			/* ICELESS_STUB == 0 */
a250 2
#if ICELESS_STUB == 0

a274 5
#else		/* ICELESS_STUB == 0 */

   main();

#endif		/* ICELESS_STUB == 0 */
a276 1
#if ICELESS_STUB == 0
a281 1
#endif
a282 1
#if ICELESS_STUB == 0
a331 40
# if 0 				/* this function lives in sst_vid on the phoenix */
static struct pll {
    int millisecs;
    int prev_eerrtc;
    int ticks;
} pll_data;

void (*volatile tpllvec)(void);

void timer_pll() {
    struct pll *pll;
    pll =  &pll_data;
    if (pll->prev_eerrtc == 0) {
	if (eer_rtc < 5*60) return;
	pll->prev_eerrtc = eer_rtc;
	pll->millisecs = 0;
	pll->ticks = 0;
	return;
    }
    ++pll->millisecs;
    if (eer_rtc == pll->prev_eerrtc) return;
    pll->prev_eerrtc = eer_rtc;
    ++pll->ticks;
    if (pll->ticks < 60) return;
    pll->ticks = 0;
    if (pll->millisecs == 1000) {
	pll->prev_eerrtc = 0;			/* enable ourself to re-execute */
	if (tpllvec == timer_pll) tpllvec = 0;	/* and remove ourself from execution */
	return;
    } else {
	int new_rate;
	new_rate = (prc_timer_rate(0)*pll->millisecs)/1000;
	prc_timer_rate(new_rate);
    }
    pll->millisecs = 0;
    return;
}
# endif				/* */
#endif				/* ICELESS_STUB == 0 */

a413 1
#if ICELESS_STUB == 0
a422 1
#endif
a437 1
#if ICELESS_STUB == 0 
a480 2
#endif		/* ICELESS_STUB == 0 */

a483 2
#if ICELESS_STUB == 0 

d516 1
a516 1
# if MAX_AST_QUEUES
d567 1
a567 2
# endif			/* MAX_AST_QUEUES > 0 */
#endif			/* ICELESS_STUB == 0 */
d571 1
a571 3
#if ICELESS_STUB == 0

# if GAL_NOTES
d608 1
a608 1
# endif
d610 1
a610 1
# if TIME_EXCEPTIONS
d618 1
a618 1
# endif
a634 1
   ++_guts_inest;
d641 1
d660 6
a665 1
    		if (ii != 7) did = 1;	/* iceless interrupts don't count */
d688 5
a694 1
#endif
a695 4
#if ICELESS_STUB
extern void handle_exception(unsigned long *);
extern int got_attention(int);
#else
a696 1
#endif
a783 1
#if ICELESS_STUB == 0 
d785 2
a786 2
# if !BOOT_FROM_DISK
#  if REGISTER_SIZE == 4
d788 1
a788 1
#  else
d795 1
a795 1
#  endif
d807 1
a807 1
# endif			/* !BOOT_FROM_DISK */
a808 1
#endif			/* ICELESS_STUB == 0 */
a810 1
#if ICELESS_STUB == 0
a828 48
#else			/* ICELESS_STUB == 0 */
   ++exception_count;
   if ((regs[CAUSE_REGNUM_W]&0x7C) == 0) {	/* if IRQ */
      int which, sts;
      which = (regs[CAUSE_REGNUM_W]&SR_IMASK) & (regs[PS_REGNUM_W]&SR_IMASK);
      if ((which&0x400) != 0) {			/* if ICELESS IRQ */
#   if !NO_INTS
	 prc_set_ipl((regs[PS_REGNUM_W]&0xFB00)|1); /* re-enable other interrupts */
#   endif
	 sts = got_attention(TWI_THREAD);	/* read a packet, reset the attention flag */
#   if !NO_INTS
	 prc_set_ipl(regs[PS_REGNUM_W]);	/* restore the PS */
#   endif
	 if (sts) handle_exception(regs);	/* pretend we got an exception */
      } else {
	  int ii, new;
	  U32 *rv;

	  rv = (U32*)romv_tbl.ROMV_RAMVBR;

	  for (new = 0x100, ii = 0; ii < 8; ++ii, new += new) {
	     if ((new&which) != 0) {
	         void (*func)();
		 func = (void (*)())rv[ii];	/* yep. Have a handler? */
		 if (func == 0) {
		    regs[PS_REGNUM_W] &= ~new; /* don't allow this interrupt anymore */
		 } else {
		    func();		/* go to user's interrupt routine */
		 }
	      }
	  }
      }      
      return regs;
   }	 
   if ((regs[CAUSE_REGNUM_W]&0x7C) == (15<<2)) {	/* Floating point exception? */
      void (*func)();
      U32 *rv;

      rv = (U32*)romv_tbl.ROMV_RAMVBR;

      func = (void (*)())rv[VN_FPE];	/* yep. Have a handler? */
      if (func) {
	 func(regs);			/* yep, call it */
	 return regs;			/* and exit */
      }
   }
   handle_exception(regs);
#endif					/* ICELESS_STUB == 0 */
d832 5
a836 6
#if ICELESS_STUB == 0
# if (HOST_BOARD == PHOENIX_AD) || (HOST_BOARD == FLAGSTAFF)
#  define EE_TYPE VU32 *
# else
#  define EE_TYPE VU8 *
# endif
d839 1
a839 1
# if !BOOT_FROM_DISK && !NO_EER_WRITE
d847 1
a847 1
# endif
a849 1
#endif			/* 1 || ICELESS_STUB == 0 */
d914 1
d918 1
a918 1

@


1.41
log
@Kicked the WDOG in a few more places.
@
text
@d325 6
a330 1
   for (cnt=0; cnt < 40; ++cnt) vid_waitvb(0);	/* count frames */ 
@


1.40
log
@Added check for inest being 0 before signalling AST.
@
text
@d328 3
@


1.39
log
@Added AST interrupt dispatcher.
@
text
@d591 1
a591 1
    if (_guts_astlvl < 0) prc_swint1();
@


1.38
log
@Added functions prc_add_q(), prc_swint0, prc_swint1() and
prc_get_actlvl().
@
text
@d196 4
d223 4
d498 3
a500 3
 * end of the queue, provided it is not already on a queue. Otherwise, it
 * returns a pointer to the "queue head" for the queue it is already on
 * (including this one).
d570 62
a631 1
#endif
a687 8
void prc_swint0() {		/* signal software interrupt 0 */
    __asm__("mfc0 $2, $13; li $3, 0x100; or $2, $3; mtc0 $2, $13");
}
    
void prc_swint1() {		/* signal software interrupt 1 */
    __asm__("mfc0 $2, $13; li $3, 0x200; or $2, $3; mtc0 $2, $13");
}

d741 8
@


1.37
log
@Conditionalled out references to LED_OUT where appropriate.
@
text
@d489 1
a489 1
/* prc_q_action takes a pointer to an "action" structure and puts it at the
d495 1
a495 3
volatile struct act_q irq_action;

struct act_q *prc_q_action(struct act_q *new) {
d497 1
a497 1
   volatile struct act_q *ans = 0;	/* assume success */
d499 1
d502 1
a502 1
      ans = &irq_action;	/* point to head of action queue */
d505 1
a505 1
	    ans = &irq_action;	/* already in this queue */
d510 1
a510 1
	    new->que = (struct act_q *)&irq_action; /* say what queue we're on */
d518 1
a518 1
      if (new->que != &irq_action) {
d526 6
d619 12
d657 4
a660 2
	       regs[PS_REGNUM_W] &= ~new; /* don't allow this interrupt anymore */
	       prc_set_ipl(prc_get_ipl()&~new); /* remember the local value too */
@


1.36
log
@DIPSW 1 and 2 need to be ON to enable boot text squawking.
@
text
@d108 3
d120 1
d122 1
d132 5
a136 1
	   while (1) prc_blink_led((1<<B_LED_RED)|(1<<B_LED_YEL), 0);
d142 1
d148 1
d154 1
d162 1
d164 1
d166 1
@


1.35
log
@More diags fixes.
@
text
@d113 3
d158 3
@


1.34
log
@Now blinks the red LED if there is an error sending out the
UART in ANNOUNCE_BOOT_ACTIONS mode.
@
text
@d112 1
a112 1
    int blink = 0;
d116 6
a121 2
    if ((UART_CONTROL&0xFFFF) != SHIMS_UART_ENAB) {
	UART_CONTROL = SHIMS_UART_ENAB ; /* init the uart, set baud rate */
d123 2
a124 3
	if ((UART_CONTROL&0xFFFF) != SHIMS_UART_ENAB) {
	   *(VU32 *)LED_OUT |= (1<<B_LED_YEL)|(1<<B_LED_GRN)|(1<<B_LED_RED); /* turn off all LEDS */
	   while (1) prc_blink_led(1<<B_LED_RED, 50000);
@


1.33
log
@Disabled CTS_IN during BLAB's.
@
text
@d114 1
d119 4
a123 1
    *(VU32 *)LED_OUT &= ~(1<<B_LED_YEL); /* turn on GRN LED's */
d128 1
a128 1
		*(VU32*)LED_OUT |= (1<<B_LED_YEL);	/* blink the the GRN led */
d130 1
a130 1
		*(VU32*)LED_OUT &= ~(1<<B_LED_YEL);	/* blink the the GRN led */
d139 1
a139 1
		*(VU32*)LED_OUT |= (1<<B_LED_YEL);	/* blink the the GRN led */
d141 1
a141 1
		*(VU32*)LED_OUT &= ~(1<<B_LED_YEL);	/* blink the the GRN led */
d145 1
a145 1
    *(VU32 *)LED_OUT |= (1<<B_LED_YEL); /* turn off GRN LED's */
@


1.32
log
@Changed the text in the BLAB statements slightly.
@
text
@d108 1
d115 2
a116 2
    if ((UART_CONTROL&0xFFFF) != (UART_ENABLE|BR9600)) {
	UART_CONTROL = UART_ENABLE | BR9600; /* init the uart, set baud rate */
@


1.31
log
@Added some boot up message code that uses the Ioasic Uart.
Enabled with config flags ANNOUNCE_BOOT_ACTIONS and BLAB
@
text
@d107 2
d121 2
a122 2
	if ((blink&0x7FFFF) == 0) {
	    if ((blink&0x80000)) {
d132 2
a133 2
	if ((blink&0x7FFFF) == 0) {
	    if ((blink&0x80000)) {
d207 1
a207 1
    BLAB("Finished unlock.\r\n");
d225 1
a225 1
   BLAB("Setting Galileo timer...");
d236 1
a236 1
       BLAB("\nInstalling floating point exception handler...");
d248 1
a248 1
   BLAB("\nFinish setting up \"C\" environment...");
d251 1
a251 1
   BLAB("\nStarting selftest code.\r\n");
@


1.30
log
@Added a NO_EER_WRITE cpp variable.
/
@
text
@d17 4
d106 59
d187 1
d202 4
a205 8
#if 0
    UARTInit(0, ASIC_UART_INIT);	/* Init the UARTS */
    UARTInit(1, 0);
    UARTInit(2, 0);

    UARTputs(0, "This is UART 0. Messages appear on UART 2\r\n");
    UARTputs(1, "This is UART 1. Messages appear on UART 2\r\n");
    UARTputs(2, "This is UART 2\r\n");
d223 1
d234 1
d246 1
d249 1
@


1.29
log
@Removed all references to pm_xx and powerUp in DISK BOOT code.
@
text
@d770 1
a770 1
# if !BOOT_FROM_DISK
@


1.28
log
@More support for Flagstaff.
@
text
@d55 1
d58 1
d177 1
d180 3
d196 1
d198 1
d218 1
d221 1
d663 1
a663 1
#if ICELESS_STUB == 0
d665 2
a666 1
# if REGISTER_SIZE == 4
d668 1
a668 1
# else
d675 1
a675 1
# endif
d687 1
@


1.27
log
@Fixed support for Phoenix_ad and Flagstaff boards.
@
text
@d751 1
a751 1
# if HOST_BOARD == PHOENIX_AD
@


1.26
log
@Moved some timer functions into a prc_timer_jobs() so they
could be executed from the Vsync routine.
@
text
@d111 2
a112 1
#else
d116 5
@


1.25
log
@Moved the hardware reset code to phx_root.mac.
@
text
@d334 1
a334 12
extern int prc_adj_msclock(void);

void cputimerint() {
   VU32 *cause  = (VU32*)GALILEO_INT_CAUSE;
#if TIMER_HISTORY
   U32 start;
#endif

   if (!(*cause&TM3_NOTES)) return;	/* not us, just exit */

   *cause &= ~TM3_NOTES;		/* ack the interrupt */

d362 13
@


1.24
log
@Fixed AD's prc_reboot().
@
text
@d208 1
a208 18
#if HOST_BOARD == PHOENIX
   *(VU32*)NSS_FIFO_RST = 0;	/* reset all the hardware */
   *(VU32*)MISC_CONFIG = MISC_CONFIG_NSS_RESET;
   *(VU32*)IO_RESET = 0;
   *(VU32*)PCI_RESET = 0;
#else
    /* Reset all the hardware */
   *(VU32*)NSS_CTL = 0;		/* hit this just in case */
   *(VU32*)INTCTL_NMI = 0;	/* clear all the interrupt registers */
   *(VU32*)INTCTL_IE = 0;
   *(VU32*)INTCTL_MAPA = 0;
   *(VU32*)INTCTL_STS = 0;
   *(VU32*)INTCTL_VSY_ACK = 0;
   *(VU32*)ARB_CTL = 0;
   *(VU32*)LED_OUT = 0;
   *(VU32*)RESET_CTL = 0; /* (1<<B_RESET_EXP)|(1<<B_RESET_IOASIC)|(1<<B_RESET_IDE)|
    			(1<<B_RESET_3DFX)|(1<<B_RESET_NSS)|(1<<B_RESET_WIDGET); */
#endif
@


1.23
log
@Working on prc_reboot which doesn't work on PHX_AD boards.
.,
@
text
@d215 8
@


1.22
log
@Changed "inest" to "_guts_inest" and made it available externally.
Added function "prc_get_exception_time".
@
text
@d198 1
d201 1
a201 5
   if (eer_busy()) {		/* eeprom needs updating */
	vid_clear();		/* clear screen */
	txt_str(-1, AN_VIS_ROW/2, "Waiting for EEPROM to finish updating", RED_PAL);
	while (eer_busy()) prc_delay(0);
   }
@


1.21
log
@Gutted eer_write_byte if BOOT_FROM_DISK is set.
@
text
@d19 4
d501 11
a511 1
static volatile int inest;
d522 1
a522 1
   ++inest;
d553 1
a553 1
   if (inest == 1) {
d559 1
a559 1
   --inest;
@


1.20
log
@Added a h/w reset at prc_reboot().
@
text
@d748 1
d756 1
@


1.19
log
@Forced the read/write of eeprom to be VU32 instead of VU8.
@
text
@d207 10
@


1.18
log
@Added support for Phoenix_ad and Flagstaff boards.
@
text
@d731 7
a737 1
void eer_write_byte(volatile unsigned char *where, volatile unsigned char *unlock, int what) {
@


1.17
log
@Added support for PHOENIX_AD and Flagstaff boards.
@
text
@d104 1
d107 5
a111 1

@


1.16
log
@Added better Galileo error interrupt support.
@
text
@d222 1
a222 1
# if HOST_BOARD != PHOENIX		/* this function lives in sst_vid on the phoenix */
d259 1
a259 1
# endif				/* HOST_BOARD != PHOENIX */
@


1.15
log
@Added a special vector to handle galileo error interrupts. The
process will jump to the stub if one of those interrupts occur.
@
text
@d19 2
a20 6
#if 0
#define TIMER_HISTORY	128
#define SHOW_TIME	1
#else
#define TIMER_HISTORY	0
#define SHOW_TIME	0
d23 3
d283 2
a284 1
    if (dow->subsec >= 1000) {
d361 1
a361 1
    * argument that says it has been 1000 microseconds since the
d364 1
a364 1
   tq_maint(1000);
d443 2
d461 2
a462 1
    which = *(VU32*)GALILEO_INT_CAUSE & (G_MRE|G_SWE|G_MWE|G_SRE|G_ADE|G_MEE|G_MAB|G_TAB|G_RTY);
d480 1
d495 1
a495 1
#if defined(GALILEO_LVL)
d798 4
@


1.14
log
@Corrected the bobble of the dispatch of ICELESS functions with no stub loaded.
@
text
@d443 35
d483 1
a483 1
   void (*func)();
d491 6
d504 1
a504 1
	     func = (void (*)())ramv[VN_IRQ0 + ii];
d514 1
a514 1
		func();			/* go to user's interrupt routine */
@


1.13
log
@*** empty log message ***
@
text
@d697 1
a697 1
    int sts;
d700 5
a704 5
    func = (int (*)(PktIOStruct *))s->STUBVEC_PKTQRECV;
    if (func) {
	sts = func(pkt);
    } else {
	sts = 0;
d713 1
a713 1
    int sts;
d716 5
a720 5
    func = (int (*)(PktIOStruct *))s->STUBVEC_PKTQSEND;
    if (func) {
	sts = func(pkt);
    } else {
	sts = 0;
d731 6
a736 3
    func = (void *(*)(void))s->STUBVEC_PKTINIT;
    if (func) {
	return func();
d747 5
a751 3
    func = (PktIOStruct *(*)(int, int, int, int))s->STUBVEC_PKTPOLL;
    if (func) {
	return func(board, flag, channel, thread);
@


1.12
log
@Added conditional code to verify that it is not my timer that
is screwing up hockey. It wasn't. It was Hockey's code that
was nfg.
@
text
@d21 1
d24 1
d27 1
d266 3
a274 1
    float ftime;
d277 1
a277 1
static Dow master, act;
a282 1
    char msg[40];
a283 1
    dow->ftime += 0.001;
d301 7
a307 9
	txt_decnum((AN_VIS_COL-12)/2, row, dow->days, 3, RJ_BF, RED_PALB);
	txt_cstr(" ", RED_PALB);
	txt_cdecnum(dow->hours, 2, RJ_ZF, RED_PALB);
	txt_cstr(":", RED_PALB);
	txt_cdecnum(dow->mins, 2, RJ_ZF, RED_PALB);
	txt_cstr(":", RED_PALB);
	txt_cdecnum(dow->secs, 2, RJ_ZF, RED_PALB);
	nsprintf(msg, sizeof(msg)-1, " %f", dow->ftime);
	txt_cstr(msg, RED_PALB);
d316 1
a316 1
    upd_dow(&act, AN_VIS_ROW-2);
a318 1

d347 2
a348 1
    upd_dow(&master, AN_VIS_ROW-1);
@


1.11
log
@Added some timer error tracking code.
@
text
@d19 1
d21 3
d263 56
d320 1
d343 10
a363 5
#endif
#if TIMER_HISTORY
   timer_history[timer_history_nxt] = prc_get_count() - start;
   ++timer_history_nxt;
   if (timer_history_nxt >= n_elts(timer_history)) timer_history_nxt = 0;
@


1.10
log
@Protected ICELESS interrupts from recursion.
@
text
@d19 2
d256 4
d270 3
d280 3
d293 5
@


1.9
log
@*** empty log message ***
@
text
@d384 6
a389 2
		did = 1;
		func();	/* go to user's interrupt routine */
@


1.8
log
@Added call to __main in BootUp.
@
text
@d113 1
a117 1
#if 0
a118 1
#endif
d121 1
@


1.7
log
@Added ICELESS to _all_ expansion port interrupts.
@
text
@d82 6
d155 2
a603 6

void __main() {
    extern void reent_init(void);
    reent_init();
    return;
}
@


1.6
log
@Called timervec() if there is one.
@
text
@d97 4
a100 1
# if ICELESS_LVL
d102 1
@


1.5
log
@Added ICELESS I/O functions.
@
text
@d262 1
@


1.4
log
@Called reent_init in __main().
@
text
@d36 1
a36 1
extern struct pconfigb def_pbase;
d76 1
d132 1
a132 1
   pbase = &def_pbase;		/* for now, we just use our dummy pconfigb */
d597 59
@


1.3
log
@Misc fixes for Phoenix and SST.
@
text
@d592 3
a594 1
   return;
@


1.2
log
@cputimer now uses Galileo timer 3 instead of cputimer
@
text
@d14 2
a16 9
extern U32 UARTputchar(int, U8);
extern void UARTInit(int, int);
#define ASIC_UART_INIT  (0x0633)
extern void UnLock(void);

#if !defined(NO_PRC_DELAY)
# define NO_PRC_DELAY 0
#endif

d37 1
a37 1
struct pconfigb *pbase;
d106 6
d169 7
a178 5
   eer_user_purge();		/* clear any open user recs w/o writing them */
   while(1) {
      prc_delay(0);		/* wait until next vblank */
      if (eer_busy() == 0) break; /* keep looping until all eeprom is written */
   }
a183 23
# if !NO_PRC_DELAY

void (*prc_delay_vec)(void);

void prc_delay(int cnt)
{
 do
  if (prc_delay_vec) (*prc_delay_vec)();
  else
   if (vid_waitvb(0) == 0)
   {
    eer_hwt();
    ctl_upd_sw();
   }
 while (cnt-- > 0);
}

void prc_delay0() {
   prc_delay(0);
}

# endif

d201 1
d238 1
a238 1

a259 1
# if VIDEO_BOARD && (VIDEO_BOARD != THREEDFX_V)
a260 10
# else
   if ((timer_ints&3) == 0) {
      ctl_upd_sw();
      if ((timer_ints&15) == 0) {
	  eer_hwt();
	  if (gameint) gameint();	/* call fake vb routine */
          if (framevec) framevec();	/* this is also a fake frame end */
      }
   }
# endif
@


1.1
log
@Initial revision
@
text
@d13 1
d15 5
d69 19
d92 32
d128 1
a128 1
  prc_timer_rate(65536);
d216 1
a216 1
U32 *set_timer_ptr(U32 *ptr) {
d253 2
a254 2
	new_rate = (set_timer_rate(0)*pll->millisecs)/1000;
	set_timer_rate(new_rate);
d271 3
a273 1
   int adj;
d275 1
a275 2
   adj = prc_adj_msclock();
   timer_ints += adj;
d277 2
d280 2
a281 1
   if (his_zclock) *his_zclock += adj;
d283 10
d298 1
a298 1
   tq_maint(1000*adj);
a345 10
#if ICELESS_STUB == 0

static volatile int inest;

#else		/* ICELESS_STUB == 0 */

U32 last_int_disabl;

#endif		/* ICELESS_STUB == 0 */

a375 1
static int inest;
d377 2
d383 1
a383 1
   U32 *rv;
a514 1
    U32 lpc;
d542 1
a542 1
   void (*(*ramv)[VN_MAX])();
d544 1
a544 1
   ramv = (void (*(*)[])())romv_tbl.ROMV_VBR;
d549 1
a549 1
      func = ramv[ii+VN_TLBM-1];
a564 1
	 last_int_disabl = (U32)exception_handler;
@
