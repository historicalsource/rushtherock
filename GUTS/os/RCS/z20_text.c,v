head	1.18;
access;
symbols;
locks; strict;
comment	@ * @;


1.18
date	96.05.08.21.07.26;	author albaugh;	state Exp;
branches;
next	1.17;

1.17
date	96.05.03.15.42.27;	author forrest;	state Exp;
branches;
next	1.16;

1.16
date	96.04.25.17.49.35;	author albaugh;	state Exp;
branches;
next	1.15;

1.15
date	96.04.15.21.17.10;	author albaugh;	state Exp;
branches;
next	1.14;

1.14
date	96.02.29.03.13.01;	author albaugh;	state Exp;
branches;
next	1.13;

1.13
date	96.02.14.01.40.21;	author shepperd;	state Exp;
branches;
next	1.12;

1.12
date	96.02.14.01.20.26;	author albaugh;	state Exp;
branches;
next	1.11;

1.11
date	96.02.06.21.46.53;	author albaugh;	state Exp;
branches;
next	1.10;

1.10
date	96.01.31.20.37.38;	author albaugh;	state Exp;
branches;
next	1.9;

1.9
date	96.01.23.20.54.42;	author albaugh;	state Exp;
branches;
next	1.8;

1.8
date	96.01.17.00.25.40;	author albaugh;	state Exp;
branches;
next	1.7;

1.7
date	96.01.09.01.36.46;	author shepperd;	state Exp;
branches;
next	1.6;

1.6
date	95.12.22.23.21.42;	author albaugh;	state Exp;
branches;
next	1.5;

1.5
date	95.12.22.22.53.57;	author shepperd;	state Exp;
branches;
next	1.4;

1.4
date	95.12.21.04.07.29;	author shepperd;	state Exp;
branches;
next	1.3;

1.3
date	95.12.11.16.41.00;	author albaugh;	state Exp;
branches;
next	1.2;

1.2
date	95.12.07.00.57.06;	author albaugh;	state Exp;
branches;
next	1.1;

1.1
date	95.12.06.02.39.07;	author albaugh;	state Exp;
branches;
next	;


desc
@Text output routines (a variety thereof) for Zoid 20.
A work-in-progress.
@


1.18
log
@added txt_setpos(), which went missing some time ago...
@
text
@/*		z20_text.c
 *	Switchable method text-output routines for Zoid20.
 *
 *	This includes the "fallback" routines that draw alphanumrics directly
 *	into the bitmap of the Zoid20 ZTV2 board. These routines are
 *	derived, in part, from the Jaguar text routines written by
 *	Robert Birmingham.
 *
 *	It also includes the ZRE-driven routines formerly in zre_text.c
 *	This first version uses the XBUS port to zre to cause one trap
 *	per character to be written.
 *
 *	The (probably) last revision is really an attempt to further
 *	generalize to any system with a single "plane" of video, which
 *	would therefore need to maintain a "fake screen" for purposes
 *	of re-painting alphanumeric "overlays" onto the single video plane.
 *	While this version should _work_ for Zoid, and it fixes one bug
 *	related to non-BGBIT txt_stamp() calls, it should not be strictly
 *	necessary for any Zoid development.
 *
 *		Copyright 1994,1995 Atari Games.
 *	Unauthorized reproduction, adaptation, distribution, performance or 
 *	display of this computer program or the associated audiovisual work
 *	is strictly prohibited.
 */

#include <config.h>
#include <os_proto.h>
#include <st_proto.h>
#include <string.h>
#include <zre_defs.h>
#include <zoid_proto.h>

/*	Following definition is needed because gcc bitches about pointer
 *	arithmetic when the MSB of the address is set, which it is for
 *	the XBUS on the HCR4K
 */
#ifndef ZTV_BITMAP_OFFSET
#define ZTV_BITMAP_OFFSET ((ZTV_BITMAP_ADDR-(U32)&ZTV_CTL)/sizeof(ZTV_CTL))
#endif

#define BPPIXEL (4)	/* ZTV2 has pixels on 32-bit boundaries */
#define SCREENW (VIS_H_PIX)
#define STATIC static

#ifndef CHAR_BITS
#define CHAR_BITS (8)
#endif
#if (HOST_BOARD == ASCLEAP)
#define BITMAP_STR (0)
#define CLEAR_MORE_IN_VBLANK (1)
#else
#define BITMAP_STR (1)
#endif

#define U32_BITS (sizeof(U32)*(CHAR_BITS))

STATIC U16 fake_screen[AN_VIS_ROW][AN_TOT_COL];
#define FS_SIZE (AN_VIS_ROW*AN_TOT_COL*sizeof(fake_screen[0][0]))
STATIC U32 def_dirty[AN_VIS_ROW*((AN_TOT_COL+(U32_BITS-1))/U32_BITS)];

static struct txt_alpha_ptr default_screen,*where_is_vs;

#ifdef ZIG
#undef ZRE_XTOT
extern VU32* zre_xtot;
extern U32 xtot_bit;
#define ZRE_XTOT (*zre_xtot)
#endif

/* txt_vsptr - set the pointer to the virtual screen
 * At entry:
 *	new - pointer to new TxtAlphaPtr struct to use or 0
 *		(if new->screen == 0, clears the current pointer)
 * At exit:
 *	returns the old contents of where_is_vs
 */
struct txt_alpha_ptr *txt_vsptr(struct txt_alpha_ptr *new) {
    struct txt_alpha_ptr *old;
    old = where_is_vs;			/* save previous value */
    if (new) {				/* if user supplied a value ...*/
	if (new->screen) {		/* and the screen member is not 0...*/
	    where_is_vs = new;		/* his value becomes the new one */
	} else {
	    where_is_vs = 0;		/* else there is no virtual screen anymore */
	}
    }					/* if new == 0, just return previous value */
    return old;				/* always return previous value */
}

/*	If the "hardware" does not define the bit-depth for alphanumerics,
 *	assume the fairly-standard two bits of System I.
 */
#ifndef AN_BIT_DEPTH
#define AN_BIT_DEPTH (2)
#endif
/*	If the "hardware" does not define the width for alphanumerics,
 *	assume the fairly-standard eight pixels of System I.
 */
#ifndef AN_STMP_WID
#define AN_STMP_WID (8)
#endif
/*	If the "hardware" does not define the height for alphanumerics,
 *	assume the fairly-standard eight lines of System I.
 */
#ifndef AN_STMP_HT
#define AN_STMP_HT (8)
#endif
static U32 an_pal[(AN_PAL_MSK>>AN_PAL_SHF)+1][1<<AN_BIT_DEPTH];

#define WITHOUT_HBLANK(scrptr,colors,scan,pixcnt) \
    *scrptr++ = colors[scan&K3];		\
    scan >>= 2; 			\
    *scrptr++ = colors[scan&K3];		\
    scan >>= 2; 			\
    *scrptr++ = colors[scan&K3];		\
    scan >>= 2; 			\
    *scrptr++ = colors[scan&K3];		\
    scan >>= 2; 			\
    *scrptr++ = colors[scan&K3];		\
    scan >>= 2; 			\
    *scrptr++ = colors[scan&K3];		\
    scan >>= 2; 			\
    *scrptr++ = colors[scan&K3];		\
    scan >>= 2; 			\
    *scrptr++ = colors[scan&K3];		\
    scan >>= 2

extern VU32 *ztv_base;

#ifdef B_Z_HBLANK
static int wait_for_hblank;
#define stampout(scrptr,colors,scan,pixcnt) \
   do { if (wait_for_hblank) { 					\
    U32 lobby[AN_STMP_WID],*lp;					\
    int old_ipl;						\
    VU32 *zp = ztv_base;					\
    VU32 *cp = ztv_base;					\
    U32	cval = ztv_mod_latch(0);				\
    lp = lobby;							\
    for ( pixcnt = AN_STMP_WID-1 ; pixcnt >= 0 ; --pixcnt ) {	\
	*lp++ = colors[scan&K3];			\
	scan >>= 2; 						\
    }								\
    lp = lobby;							\
    old_ipl = prc_set_ipl(INTS_OFF);				\
    while ( !(*zp & (1<<B_Z_VIDB)) ) {;}			\
    while ( *zp & (1<<B_Z_VIDB) ) {;}				\
    *cp = cval | (1<<B_Z_DSM_OFF);				\
    scrptr[0] = lp[0];						\
    scrptr[1] = lp[1];						\
    scrptr[2] = lp[2];						\
    scrptr[3] = lp[3];						\
    *cp = cval & ~(1<<B_Z_DSM_OFF);				\
    prc_set_ipl(old_ipl);					\
    old_ipl = prc_set_ipl(INTS_OFF);				\
    while ( !(*zp & (1<<B_Z_VIDB)) ) {;}			\
    while ( *zp & (1<<B_Z_VIDB) ) {;}				\
    *cp = cval | (1<<B_Z_DSM_OFF);				\
    scrptr[4] = lp[4];						\
    scrptr[5] = lp[5];						\
    scrptr[6] = lp[6];						\
    scrptr[7] = lp[7];						\
    *cp = cval & ~(1<<B_Z_DSM_OFF);				\
    prc_set_ipl(old_ipl);					\
    scrptr += AN_STMP_WID;					\
   } else {							\
    WITHOUT_HBLANK(scrptr,colors,scan,pixcnt);			\
   } } while (0)
#else
#define stampout(scrptr,colors,scan,pixcnt) \
   do {					\
    WITHOUT_HBLANK(scrptr,colors,scan,pixcnt);			\
   } while (0)
#endif

static struct posn {
    short row;
    short col;
} p_posn;

/*		txt_setpos()
 *	Used to save/restore the "cursor position" for
 *	text output (used by txt_c*(), or txt_*() with row < 0)
 *	Takes a "magic cookie" of zero (default postion) or
 *	the value returned by a previous call. Returns a
 *	"magic cookie" encoding the current position.
 */
unsigned long txt_setpos( newpos )
unsigned long newpos;	/* Magic cookie, do not open */
{
    U32 prev;
    int old_ipl;
    old_ipl = prc_set_ipl(INTS_OFF);
    prev = (p_posn.row << 16)|(p_posn.col & 0xFFFF);
    p_posn.col = (newpos & 0xFFFF);
    p_posn.row = (newpos >> 16);
    prc_set_ipl(old_ipl);
    return prev;
}

extern unsigned short an_stamps,an_norm_a,an_end;
#define AN_STAMPS &an_stamps
#define AN_A_OFFSET ((&an_norm_a-&an_stamps)>>3)
struct bigchar {
    unsigned char tl,bl,tr,br;
};

#include <txt_tab.h>

const int BIG_OFFSET = 0xA6;
#if BITMAP_STR
/*		zbtxt_str( col, row, txtptr, color )
 *	Draws text directly into Zoid TV Bitmap memory.
 *	This is the "ultimate fallback" routine, as it
 *	is the slowest method, but does not require
 *	a buffer-swap to view the text, and does not
 *	require the ZRE and ZMB to exist, let alone work.
 */
int zbtxt_str( col, row, txtptr, color )
int col;
int row;
const char *txtptr;
int color;
{
    U32 x, y;
    const char *txtbase = txtptr;
    U32 *scrptr;
    U16 *stamps;
    U32 *colptr,colors[1<<AN_BIT_DEPTH];
    m_int width,stamp,pixcnt;
    int	scan,offset;
    int zctl;
    int	K3 = 3;
    int next_line = TOT_H_PIX;

    if ( row < 0 ) {
	col = p_posn.col;	
	row = p_posn.row;
    }
    p_posn.row = row;			/* we do not wrap to lower rows */
    if (col < 0 ) {
	/* wants to center */
	col = (AN_VIS_COL+1-txt_width(txtptr,color)) >> 1;
	if ( col < 0 ) col = 0;
    }

    zctl = ztv_mod_latch(0);
    if ( zctl & (1<<B_Z_XACC) ) {
	/* host can't write into bitmap anyway, Check for ZRE active and
	 * hijack ZTV if not. If ZRE _is_ active, just return
	 * Note that although the signal name is IDLE, the '1' state
	 * is "busy".
	 */
	if ( ztv_base == &ZTV_CTL ) {
	    if ( ZRE_CSR & (1<<B_ZRE_IDLE) ) return 0;
	} else {
	    /* ZIG is exactly backwards */
	    if ( (ZRE_CSR & (1<<B_ZRE_IDLE)) == 0 ) return 0;
	}
	ztv_mod_latch(~(1<<B_Z_XACC));
    }

    wait_for_hblank = zctl & (1<<B_Z_HBL_WAIT);
    if (!wait_for_hblank) ztv_mod_latch((1<<B_Z_DSM_OFF));

    ztv_mod_latch(~(1<<B_Z_ZBUFF_EN));
    /* convert cell column into screen x offset in bytes */
    x = (U32)(col << 3) * BPPIXEL;
    /* convert cell row into screen y offset bytes */
    /* For ZTV, the Y coordinate needs to be inverted */
    y = (VIS_V_PIX-8 - (U32)(row << 3)) * TOT_H_PIX * BPPIXEL;
#ifdef B_Z_ONE_BANK
    /* Enon-o-zig has only one bank of memory, every other line */
    if ( zctl & (1<<B_Z_ONE_BANK) ) {
	next_line <<= 1;
	y <<= 1;
    }
#endif
    /* calculate the starting screen memory address for the text */
#ifdef ZIG
    scrptr = (U32*)ztv_base + ZTV_BITMAP_OFFSET;
    scrptr += (x + y)/sizeof(U32);
#else
    scrptr = (U32 *)(ZTV_BITMAP_ADDR + x + y);
#endif
    colptr = an_pal[(color&AN_PAL_MSK)>>AN_PAL_SHF];
    memcpy(colors,colptr,sizeof(colors));
    if ( (color & BGBIT) == 0 ) colors[0] = 0x80008000;
    colptr = colors;
    if ( (color & SETMSK) == AN_BIG_SET ) {
	/* big characters, for now we use the un-reduced but possibly-slim
	 * SYSTEM I character set.
	 */
	int tc;		/* translated character */
	width = 0;
	if ( row > 0 ) {
	    /* In the (highly likely) case that we were called
	     * from txt_str, which has already adjusted the base
	     * _down_ for new BIG origin, with (col,row) refering
	     * to bottom left stamp, adjust scrptr back _up_
	     * the screen to allow following code to remain
	     * blissfully unaware of the change.
	     */
	    scrptr += (next_line*AN_STMP_HT);
	}
	while ( (stamp = *txtptr) != '\0' ) {
	    tc = trantab[stamp];
	    if ( tc < 0 ) {
		width += 2;
		scrptr += -(next_line*AN_STMP_HT);
		for ( row = (2*AN_STMP_HT)-1 ; row >= 0 ; --row ) {
		    scan = 0;
		    stampout(scrptr,colors,scan,pixcnt);
		    scan = 0;
		    stampout(scrptr,colors,scan,pixcnt);
		    scrptr += next_line-(2*AN_STMP_WID);
		}
		++txtptr;
		scrptr += ((2*AN_STMP_WID)-(next_line*AN_STMP_HT));
		continue;
	    }
	    stamps = AN_STAMPS+((BTABLE[tc].tl+BIG_OFFSET)<<3)+7;
	    for ( row = AN_STMP_HT-1 ; row >= 0 ; --row ) {
		scan = *stamps--;
		stampout(scrptr,colors,scan,pixcnt);
		scrptr += next_line-AN_STMP_WID;  /* update dest. ptr into screen memory */
	    }
	    scrptr += -(next_line*2*AN_STMP_HT);
	    stamps = AN_STAMPS+((BTABLE[tc].bl+BIG_OFFSET)<<3)+7;
	    for ( row = AN_STMP_HT-1 ; row >= 0 ; --row ) {
		scan = *stamps--;
		stampout(scrptr,colors,scan,pixcnt);
		scrptr += next_line-AN_STMP_WID;  /* update dest. ptr into screen memory */
	    }
	    width += 1;
	    scrptr += (AN_STMP_WID/* -(SCREENW*2*AN_STMP_HT) */ );
	    ++txtptr;
	    if ( BTABLE[tc].tr == 0 ) continue;
	    stamps = AN_STAMPS+((BTABLE[tc].tr+BIG_OFFSET)<<3)+7;
	    for ( row = AN_STMP_HT-1 ; row >= 0 ; --row ) {
		scan = *stamps--;
		stampout(scrptr,colors,scan,pixcnt);
		scrptr += next_line-AN_STMP_WID;  /* update dest. ptr into screen memory */
	    }
	    scrptr += -(next_line*2*AN_STMP_HT);
	    stamps = AN_STAMPS+((BTABLE[tc].br+BIG_OFFSET)<<3)+7;
	    for ( row = AN_STMP_HT-1 ; row >= 0 ; --row ) {
		scan = *stamps--;
		stampout(scrptr,colors,scan,pixcnt);
		scrptr += next_line-AN_STMP_WID;  /* update dest. ptr into screen memory */
	    }
	    width += 1;
	    scrptr += (AN_STMP_WID/* -(SCREENW*2*AN_STMP_HT) */ );
	}
	p_posn.col = col + width;
	if ( (zctl & (1<<B_Z_DSM_OFF)) == 0 ) {
	    ztv_mod_latch(~(1<<B_Z_DSM_OFF));
	}
	if ( zctl & (1<<B_Z_XACC) ) ztv_mod_latch(1<<B_Z_XACC);
	if ( zctl & (1<<B_Z_ZBUFF_EN) ) ztv_mod_latch(1<<B_Z_ZBUFF_EN);
	return width;
    }
    offset = AN_A_OFFSET-'A';

    /* print characters until NULL terminator is reached */
    while( (stamp = *txtptr) != '\0' ) {
	if ( stamp == ' ') stamp = 0;
	else stamp += offset;
	stamps = AN_STAMPS+(stamp<<3)+7;
	for ( row = AN_STMP_HT-1 ; row >= 0 ; --row ) {
	    scan = *stamps--;
	    stampout(scrptr,colors,scan,pixcnt);
	    scrptr += next_line-AN_STMP_WID;  /* update dest. ptr into screen memory */
	}
	txtptr++;
	scrptr += (AN_STMP_WID-(next_line*AN_STMP_HT));
   }

    width = txtptr - txtbase;
    p_posn.col = col + width;
    if ( (zctl & (1<<B_Z_DSM_OFF)) == 0 ) {
	ztv_mod_latch(~(1<<B_Z_DSM_OFF));
    }
    if ( zctl & (1<<B_Z_XACC) ) ztv_mod_latch(1<<B_Z_XACC);
    if ( zctl & (1<<B_Z_ZBUFF_EN) ) ztv_mod_latch(1<<B_Z_ZBUFF_EN);
    return width;
}   /* End: zbtxt_str() */
#endif

static void zbtxt_stamp( col, row, stamp, color )
int col,row,stamp,color;
{
    U32 x, y;
    U32 *scrptr;
    unsigned int scan;
    U16 *stamps;
    U32 *colptr,colors[1<<AN_BIT_DEPTH];
    int zctl;
    int	K3 = 3;
    int next_line = TOT_H_PIX;

    zctl = ztv_mod_latch(0);
    if ( zctl & (1<<B_Z_XACC) ) {
	/* host can't write into bitmap anyway, Check for ZRE active and
	 * hijack ZTV if not. If ZRE _is_ active, just return
	 * Note that although the signal name is IDLE, the '1' state
	 * is "busy".
	 */
	if ( ztv_base == &ZTV_CTL ) {
	    if ( ZRE_CSR & (1<<B_ZRE_IDLE) ) return;
	} else {
	    /* ZIG is exactly backwards */
	    if ( (ZRE_CSR & (1<<B_ZRE_IDLE)) == 0 ) return;
	}
	ztv_mod_latch(~(1<<B_Z_XACC));
    }

    wait_for_hblank = zctl & (1<<B_Z_HBL_WAIT);
    if (!wait_for_hblank) ztv_mod_latch((1<<B_Z_DSM_OFF));

    ztv_mod_latch(~(1<<B_Z_ZBUFF_EN));
    /* convert cell column into screen x offset */
    x = (U32)(col << 3) * BPPIXEL;
    /* convert cell row into screen y offset bytes */
    /* For ZTV, the Y coordinate needs to be inverted */
    y = (VIS_V_PIX-8 - (U32)(row << 3)) * TOT_H_PIX * BPPIXEL;
#ifdef B_Z_ONE_BANK
    /* Enon-o-zig has only one bank of memory, every other line */
    if ( zctl & (1<<B_Z_ONE_BANK) ) {
	next_line <<= 1;
	y <<= 1;
    }
#endif
    /* calculate the starting screen memory address for the text */
#ifdef ZIG
    scrptr = (U32*)ztv_base + ZTV_BITMAP_OFFSET;
    scrptr += (x + y)/sizeof(U32);
#else
    scrptr = (U32 *)(ZTV_BITMAP_ADDR + x + y);
#endif
    stamps = AN_STAMPS+(stamp<<3)+AN_STMP_WID-1;
    colptr = an_pal[(color&AN_PAL_MSK)>>AN_PAL_SHF];
    if ( !(color & BGBIT) ) {
	memcpy(colors,colptr,sizeof(colors));
	colptr = colors;
	colptr[0] = 0x80008000;
    }
    for ( row = AN_STMP_HT-1 ; row >= 0 ; --row ) {
	scan = *stamps--;
	stampout(scrptr,colptr,scan,col);
	scrptr += next_line-AN_STMP_WID;  /* update dest. ptr into screen memory */
    }
    if ( (zctl & (1<<B_Z_DSM_OFF)) == 0 ) {
	ztv_mod_latch(~(1<<B_Z_DSM_OFF));
    }
    if ( zctl & (1<<B_Z_XACC) ) ztv_mod_latch(1<<B_Z_XACC);
    if ( zctl & (1<<B_Z_ZBUFF_EN) ) ztv_mod_latch(1<<B_Z_ZBUFF_EN);
}
#if HOST_BOARD == ASCLEAP
#define CLR_CHUNK (8)
#else
#define CLR_CHUNK (6)
#endif

void
zbtxt_clr_wid(col,row,width)
int col,row,width;
{
    U32 *scrptr,*lptr;
    m_int v,h;
    m_int x,y;
    int zctl;
    int next_line = TOT_H_PIX;

    if ( col < 0 ) {
	/* wants to center */
	col = (AN_VIS_COL+1-width) >> 1;
	if ( col < 0 ) {
	    col = 0;
	    width = AN_VIS_COL;
	}
    }
    zctl = ztv_mod_latch(0);

    if ( zctl & (1<<B_Z_XACC) ) {
	/* host can't write into bitmap anyway, Check for ZRE active and
	 * hijack ZTV if not. If ZRE _is_ active, just return
	 * Note that although the signal name is IDLE, the '1' state
	 * is "busy".
	 */
	if ( ztv_base == &ZTV_CTL ) {
	    if ( ZRE_CSR & (1<<B_ZRE_IDLE) ) return;
	} else {
	    /* ZIG is exactly backwards */
	    if ( (ZRE_CSR & (1<<B_ZRE_IDLE)) == 0 ) return;
	}
	ztv_mod_latch(~(1<<B_Z_XACC));
    }

    wait_for_hblank = zctl & (1<<B_Z_HBL_WAIT);
    if (!wait_for_hblank) ztv_mod_latch((1<<B_Z_DSM_OFF));

    ztv_mod_latch(~(1<<B_Z_ZBUFF_EN));
    x = (U32)(col << 3) * BPPIXEL;            /* convert cell column into screen x offset */
    width *= ((BPPIXEL*AN_STMP_WID)/sizeof(*scrptr));
    /* convert cell row into screen y offset bytes */
    /* For ZTV, the Y coordinate needs to be inverted */
    y = (VIS_V_PIX-8 - (U32)(row << 3)) * TOT_H_PIX * BPPIXEL;
#ifdef B_Z_ONE_BANK
    /* Enon-o-zig has only one bank of memory, every other line */
    if ( zctl & (1<<B_Z_ONE_BANK) ) {
	next_line <<= 1;
	y <<= 1;
    }
#endif
    /* calculate the starting screen memory address for the text */
#ifdef ZIG
    scrptr = (U32*)ztv_base + ZTV_BITMAP_OFFSET;
    scrptr += (x + y)/sizeof(U32);
#else
    scrptr = (U32 *)(ZTV_BITMAP_ADDR + x + y);
#endif
    for ( v = 7 ; v >= 0 ; --v ) {
	int old_ipl;
	int chunk;
	VU32 *zp = ztv_base;
	U32 zval;
	int cval = zctl & ~((1<<B_Z_XACC)|(1<<B_Z_ZBUFF_EN)|(1<<B_Z_DSM_OFF));
	lptr = scrptr;
        if (wait_for_hblank) {
	    h = 0;
	    while ( h < width ) {
		chunk = width-h;
		if (chunk > CLR_CHUNK) chunk = CLR_CHUNK;
		h += chunk;
#if CLEAR_MORE_IN_VBLANK
		old_ipl = prc_set_ipl(INTS_OFF);
		while ( !(*zp & (1<<B_Z_VIDB)) ) {;}
		while ( (zval = *zp) & (1<<B_Z_VIDB) ) {;}
		*zp = cval | (1<<B_Z_DSM_OFF);    
		/* This code will hopefully not outlive ZOID20,
		 * So we _assume_ that chunk will always be
		 * even!!! (MEA 14MAR96)
		 */
		do {
		    *lptr++ = 0;
		    *lptr++ = 0;
		    chunk -= 2;
		} while ( chunk > 0 );
		if ( zval & (1<<B_Z_VB) ) *zp = cval;
		else {
		    /* In VBLANK, we can do quite a few more
		     * pixels. For now, just go for 7 more "chunks"
		     */
		    chunk = width-h;
		    if (chunk > (CLR_CHUNK*7)) chunk = CLR_CHUNK*7;
		    h += chunk;
		    do {
			*lptr = 0;
			lptr[1] = 0;
			lptr += 2;
			chunk -= 2;
		    } while ( chunk > 0 );
		    /* now wait for _next_ HBLANK, to safely
		     * turn DSM back on, and "take a breather".
		     */
		    while ( (zval = *zp) & (1<<B_Z_VIDB) ) {;}
		    *zp = cval;
		}
#else
		old_ipl = prc_set_ipl(INTS_OFF);
		while ( !(*zp & (1<<B_Z_VIDB)) ) {;}
		while ( (zval = *zp) & (1<<B_Z_VIDB) ) {;}
		*zp = cval | (1<<B_Z_DSM_OFF);    
		while ( chunk-- ) *lptr++ = 0;
		*zp = cval;
#endif
		prc_set_ipl(old_ipl);
	    }
        } else
	{
	    lptr = scrptr;
	    for ( h = width ; h ; --h ) {
		*lptr++ = 0;
	    }
        }
	scrptr += next_line*(BPPIXEL/sizeof(*scrptr));
    }
    if ( (zctl & (1<<B_Z_DSM_OFF)) == 0 ) {
	ztv_mod_latch(~(1<<B_Z_DSM_OFF));
    }
    if ( zctl & (1<<B_Z_XACC) ) ztv_mod_latch(1<<B_Z_XACC);
    if ( zctl & (1<<B_Z_ZBUFF_EN) ) ztv_mod_latch(1<<B_Z_ZBUFF_EN);
}

int
txt_cstr(string,psmask)
const char	*string;
int	psmask;
{
    return txt_str(0,-1,string,psmask);
}

void
txt_clr_str(x,y,string,pal)
int x,y,pal;
const char *string;
{
    int endy;
    int height = txt_height(string,pal);
    int width = txt_width(string,pal);
    if ( x < 0 ) {
	/* wants to center */
	x = (AN_VIS_COL+1-width) >> 1;
	if ( x < 0 ) {
	    x = 0;
	    width = AN_VIS_COL;
	}
    }
    for ( endy = y + height ; y < endy ; ++y ) {
	txt_clr_wid(x,y,width);
    }
}

int
txt_width(text,set)
const char *text;
int set;
{
    int width = 0;
    int letter;
    const struct bigchar *bt = BTABLE;

    if ( (set & SETMSK) != AN_BIG_SET ) width = strlen(text);
    else while ( (letter = *text++) != '\0') {
	if ( ( letter = trantab[letter] ) < 0 ) ++width;
	else width += 1 + (bt[letter].tr != 0);
    }
    return width;
}

int txt_height(txt,set)
const char *txt;
int set;
{
    if ( (set & SETMSK) == AN_BIG_SET ) return 2;
    return 1;
}

int
txt_decnum(col,row,val,wid,form,palset)
int		col;	/* coord. of UL corner of first character of txt */
int 		row;	/* (0,0) is upper left corner of screen		*/
unsigned long	val;	/* value to output				*/
int		wid;	/* Size of output field				*/
int		form;	/* one of:
    			 * RJ_ZF (0) Right Justify with ZERO Fill
    			 * RJ_BF (1) Right Justify with BLANK Fill
    			 * LJ_BF (2) Left Justify with BLANK Fill
    			 * LJ_NF (3) Left Justify with NO Fill
    			 *						*/
int		palset;	/* Palette and Character Set selection		*/
{
    char num[20];
    utl_cdec(val,num,wid,form);
    return txt_str(col,row,num,palset);    
}

void
txt_cdecnum(val,wid,form,palset)
unsigned long	val;	/* value to output				*/
int		wid;	/* Size of output field				*/
int		form;	/* one of:
    			 * RJ_ZF (0) Right Justify with ZERO Fill
    			 * RJ_BF (1) Right Justify with BLANK Fill
    			 * LJ_BF (2) Left Justify with BLANK Fill
    			 * LJ_NF (3) Left Justify with NO Fill
    			 *						*/
int		palset;	/* Palette and Character Set selection		*/
{
    txt_decnum(0,-1,val,wid,form,palset);
}

int
txt_hexnum(col,row,val,wid,form,palset)
int		col;	/* coord. of UL corner of first character of txt */
int 		row;	/* (0,0) is upper left corner of screen		*/
unsigned long	val;	/* value to output				*/
int		wid;	/* Size of output field				*/
int		form;	/* one of:
    			 * RJ_ZF (0) Right Justify with ZERO Fill
    			 * RJ_BF (1) Right Justify with BLANK Fill
    			 * LJ_BF (2) Left Justify with BLANK Fill
    			 * LJ_NF (3) Left Justify with NO Fill
    			 *						*/
int		palset;	/* Palette and Character Set selection		*/
{
    char num[20];
    utl_chex(val,num,wid,form);
    return txt_str(col,row,num,palset);
}

void
txt_chexnum(val,wid,form,palset)
unsigned long	val;	/* value to output				*/
int		wid;	/* Size of output field				*/
int		form;	/* one of:
    			 * RJ_ZF (0) Right Justify with ZERO Fill
    			 * RJ_BF (1) Right Justify with BLANK Fill
    			 * LJ_BF (2) Left Justify with BLANK Fill
    			 * LJ_NF (3) Left Justify with NO Fill
    			 *						*/
int		palset;	/* Palette and Character Set selection		*/
{
    txt_hexnum(0,-1,val,wid,form,palset);
}

extern void zover_ANPal( int, U32 );

/*		SetANPal(f_and_b)
 *	Sets one AlphaNumeric palette to have the colors specified
 *	in f_and_b. The lower 16 bits of f_and_b specify the foreground
 *	color (in game's coding) while the upper 16 bits specify the
 *	background color. If we ever get more than 1 bit deep text on
 *	Jaguar, an alias color will be synthesized "halfway between"
 *	the two. We are not actually using the CLUT capability of the
 *	Jaguar for text, as we have a CRY bitmap to draw into and do
 *	not want to waste CLUT space on text.
 */
extern const int vid_init_verbose;
extern int holler(int col, int row, const char *msg, U32 csr);
#ifndef TOO_LONG
#define TOO_LONG (17000000L)
#define LOOP_TIME (300)
#endif

void
SetANPal( palette, colors)
int palette;
U32 colors;
{
    U32 fg,bg,anti_alias;
    VU32 *csr = &ZRE_CSR;
    int idx,offset;
    U32 *dst;
    U32 data;
    S32 spinner;
    struct txt_alpha_ptr *which;

    zover_ANPal( palette, colors);
    bg = colors >> 16;
    fg = (colors & 0xFFFF);

    palette &= AN_PAL_MSK;
    palette >>= AN_PAL_SHF;
    anti_alias = (fg & ~(RED_LSB|GRN_LSB|BLU_LSB))>>1;
    anti_alias += (GRY_FUL & ~(RED_LSB|GRN_LSB|BLU_LSB))>>1;
    an_pal[palette][0] = bg | (bg<<16);
    an_pal[palette][(1<<AN_BIT_DEPTH)-1] = fg | (fg<<16);
#if AN_BIT_DEPTH > 1
    an_pal[palette][1] = GRY_FUL|(GRY_FUL<<16);	/* Border on BIG alphas */;
    an_pal[palette][2] = anti_alias|(anti_alias<<16);
#endif

    /* Duplicate the palette in the appropriate part of the
     * ZRE's color RAM.
     */
    /* It would be exceptionally rude to steal the
     * Texture color RAM while it was still painting.
     */
    if ( ztv_base == &ZTV_CTL )	data = 0;
    else data = (1<<B_ZRE_IDLE);
    for ( spinner = TOO_LONG ; spinner >= 0 ; spinner -= LOOP_TIME ) {
	if ( (*csr & (1<<B_ZRE_IDLE) ) == data ) break;
    }
    if ( vid_init_verbose && (spinner < 0) ) {
	holler(2, 2, "IDLE NOT HAPPENING; CSR=0x",*csr);
	return;
    }

    which = txt_vsptr(0);
    if ( which == 0 ) return;
    offset = which->color_offset + (palette<<2);

    *csr |= (1<<B_ZRE_TLEN);	/* _DIS_able Texture pipe */
    dst = (U32*)ZRE_COLRAM_ADDR+offset;
    for ( idx = 3 ; idx > 0 ; --idx ) {
	dst[idx] = an_pal[palette][idx];
    }
    dst[idx] = an_pal[palette][idx]|0x8000;
    *csr &= ~(1<<B_ZRE_TLEN);	/* _EN_able Texture pipe */
}

/* 	While bringing up new hardware, we may want to output
 *	text to both the remote terminal and the screen. The
 *	set of pointers below is used for this purpose.
 */
int (*vid_str)(int col, int row, const char *string, int font);
void (*vid_stamp)(int col, int row, int stampno, int pal_font);
void (*vid_tclr)(int col, int row, int width);

int (*dbg_str)(int col, int row, const char *string, int font);
void (*dbg_stamp)(int col, int row, int stampno, int pal_font);
void (*dbg_tclr)(int col, int row, int width);

/*		notxt_*()
 *	"placeholder" routines for the situation where
 *	user has called txt_select(0), to disable text
 *	output.
 */
static int
notxt_str (int col, int row, const char *string, int font)
{
    return txt_width(string, font);
}
static void
notxt_stamp (int col, int row, int stampno, int pal_font)
{ return; }
static void
notxt_clr_wid (int col, int row, int width) { return; }

static int def_font;

/*		txt_str( col, row, txtptr, color )
 *	Writes text at the specifed row and column, in
 *	the specified "color", which may also include
 *	font selection.
 */
int
txt_str(col,row,string,palette)
int	col,row;
const char	*string;
int	palette;
{
    struct posn *p = &p_posn;
    int width;
    int old_col = p->col;
    char tbuf[AN_VIS_COL+1];
    struct txt_alpha_ptr *which;
    VU32 *screen,*dirty;
    void (*do_stamp)(int col, int row, int stampno, int pal_font);

    width = txt_width(string,palette);
    if ( row == -1 ) {
	col = p->col;
	row = p->row;
    } else if ( col == -1 ) {
	col = (AN_VIS_COL+1 - width) >> 1;
	if ( col < 0 ) col = 0; 
    }
    old_col = p->col = col;
    p->row = row;
    /* Set up local pointer for "draw one stamp in video",
     * which we should always have. Then over-ride it if
     * we also have a (possibly more efficient) "output
     * whole string" routine.
     */
    do_stamp = vid_stamp;
    if ( vid_str ) do_stamp = 0;
    if ( (col + width) >= AN_VIS_COL ) {
	/* Nip over-long strings in the bud here, so
	 * we don't have to check in every vid_str() 
	 * routine.
	 * KLUGE: This will not work well for BIG character
	 * set, or for "width" expressed in anything but
	 * monospaced character cells. For now, we will
	 * ignore the problem, as this is a "proof of concept."
	 */
	int allow = AN_VIS_COL+1-(col+width);
	memcpy(tbuf,string,allow);
	tbuf[allow] = '\0';
	string = tbuf;
	width = allow;
    }
    p->col = old_col + width;
    if ( dbg_str ) dbg_str(col,row,string,palette);
    which = txt_vsptr(0);
    if ( !which ) return 0;
    if ( !vid_str ) txt_select(TXT_HOST);	/* default to host mode */
    screen = which->screen;
    if ( screen ) {
	/* Output stamps to fake screen _regardless_ of
	 * ultimate video output method. We do this here
	 * to avoid duplication of code, and consequent
	 * version drift, and because BIG characters take
	 * a bit of processing. Not to mention that we
	 * seem to have gone completely over to frame-buffered
	 * video wherein we _need_ a record of what text to
	 * repeatedly output.
	 */
	int stamp,idx;
	int color;
	color = palette & COLMSK;
	if ( (palette & SETMSK) == AN_BIG_SET ) {
	    /* Big characters are built from 2 or 4 stamps
	     * each.
	     */
	    int tc;		/* translated character */
	    VU16 *lp = (VU16*)screen;
	    const char *txtptr = string;
	    width = 0;
	    if ( row < 1 ) row = 1;	/* Strike a blow for bottom-justified */
	    lp += (row*AN_TOT_COL);
	    while ( (stamp = *txtptr) != '\0' ) {
		tc = trantab[stamp];
		idx = col+width;
		if ( idx >= AN_VIS_COL ) {
		    /* Trying to write past right edge of screen,
		     * because each ascii character may be more
		     * than one stamp wide.
		     */
		    break;
		}
		if ( tc < 0 ) {
#if UNK_BIG_IS_SPACE
		    /* KLUGE: Treat characters for which no
		     * BIG graphics exist as m-spaces. We
		     * really _should_ just substitute the
		     * normal character.
		     */
		    width += 2;
		    lp[idx] = 0;
		    lp[idx-AN_TOT_COL] = 0;
		    lp[++idx] = 0;
		    lp[idx-AN_TOT_COL] = 0;
		    ++txtptr;
		    continue;
#else
		    /* NEW: Treat characters for which no
		     * BIG graphics exist as regular ascii
		     * in default font.
		     */
		    width += 1;
		    lp[idx] = (stamp+=(AN_A_OFFSET-'A'))|color;
		    lp[idx-AN_TOT_COL] = color;
		    if ( do_stamp ) do_stamp(idx,row,stamp,color);
		    ++txtptr;
		    continue;

#endif
		}
		stamp = BTABLE[tc].tl + BIG_OFFSET;
		lp[idx-AN_TOT_COL] = stamp | color;
		if ( do_stamp ) do_stamp(idx,row-1,stamp,color);
		stamp = BTABLE[tc].bl + BIG_OFFSET;
		lp[idx] = stamp | color;
		if ( do_stamp ) do_stamp(idx,row,stamp,color);
		++width;
		++txtptr;
		if ( BTABLE[tc].tr == 0 ) continue;
		++idx;
		stamp = BTABLE[tc].tr + BIG_OFFSET;
		lp[idx-AN_TOT_COL] = stamp | color;
		if ( do_stamp ) do_stamp(idx,row-1,stamp,color);
		stamp = BTABLE[tc].br + BIG_OFFSET;
		lp[idx] = stamp | color;
		if ( do_stamp ) do_stamp(idx,row,stamp,color);
		++width;
	    }
	} else {
	    /* Non-Big characters... */
	    int offset = AN_A_OFFSET-'A';
	    const char *txtptr = string;
	    VU16 *lp = (VU16 *)which->screen;
	    lp += (row*AN_TOT_COL);
	    idx = col;
	    while ( (stamp = *txtptr++) != '\0' ) {
		if ( stamp == ' ') stamp = 0;
		else stamp += offset;
		if ( do_stamp ) do_stamp(idx,row,stamp,color);
		lp[idx++] = (stamp|color);
	    }
	}
	dirty = which->dirty;
	if ( dirty ) {
	    U32 left,right;
	    int start,twid;
	    
	    start = col;
	    twid = width;
	    left = 0;
	    if ( start < 32 ) {
		int twid = width;
		if ( twid > 31 ) left = 0;
		else left = (1<<twid);
		left = (left - 1)<<start;
		twid = width-(32-start);
		start = 32;
	    }
	    right = 0;
	    if ( twid ) right = ((1<<twid)-1)<<(start-32);
	    dirty += row*((AN_VIS_COL+U32_BITS-1)/U32_BITS);
	    dirty[0] |= left;
	    dirty[1] |= right;
	    if ( (palette & SETMSK) == AN_BIG_SET ) {
		/* Need to "dirty" the row above, too. */
		dirty -= ((AN_VIS_COL+U32_BITS-1)/U32_BITS);
		dirty[0] |= left;
		dirty[1] |= right;
	    }
	}
    }
    /* If we have a routine for doing a whole string at once, we
     * have not been doing the stamps. Do the whole string now.
     */
    if ( vid_str ) {
	width = vid_str(col,row,string,palette);
    }
    return width;
}

void
txt_clr_wid(col, row, width)
int col, row, width;
{
    struct txt_alpha_ptr *which;
    VU32 *dirty;
    which = txt_vsptr(0);
    if ( which == 0 || which->screen == 0 ) return;
    if ( row < 0 ) {
	col = p_posn.col;	
	row = p_posn.row;
    }
    if ( row >= AN_VIS_ROW ) row = AN_VIS_ROW-1;
    if (col < 0 ) {
	/* wants to center */
	col = (AN_VIS_COL+1) >> 1;
	if ( col < 0 ) col = 0;
    }
    if ( col > (AN_VIS_COL-1) ) col = AN_VIS_COL-1;
    if ( (col+width) >= AN_VIS_COL ) {
	width = AN_VIS_COL-col;
    }
    dirty = which->dirty;
    if ( dirty ) {
	U32 left,right;
	int start,twid;

	start = col;
	twid = width;
	left = 0;
	if ( start < 32 ) {
	    int twid = width;
	    if ( twid > 31 ) left = 0;
	    else left = (1<<twid);
	    left = (left - 1)<<start;
	    twid = width-(32-start);
	    start = 32;
	}
	right = 0;
	if ( twid ) right = ((1<<twid)-1)<<(start-32);
	dirty += row*((AN_VIS_COL+U32_BITS-1)/U32_BITS);
	dirty[0] &= ~left;
	dirty[1] &= ~right;
    }
    if ( dbg_tclr ) dbg_tclr(col, row, width);
    if ( vid_tclr ) vid_tclr(col, row, width);
}

/*	Routine:	txt_stamp(x,y,letter,psmask)
*	Inputs:		int	x,y
*			int	letter,psmask
*	Purpose:	To output a single character to the apha screen. Ignores
*			character-set translation, so psmask must only be color
*/
void
txt_stamp(x,y,letter,psmask)
int	x,y;
int	letter,psmask;
{
    struct txt_alpha_ptr *which;
    VU16 *lp;
    VU32 *dirty;
    which = txt_vsptr(0);
    if ( which == 0 || which->screen == 0 ) return;
    if ( y < 0 ) {
	y = p_posn.col;	
	x = p_posn.row;
    }
    if ( y >= AN_VIS_ROW ) y = AN_VIS_ROW-1;
    if (x < 0 ) {
	/* wants to center */
	x = (AN_VIS_COL+1) >> 1;
	if ( x < 0 ) x = 0;
    }
    if ( x >= AN_VIS_COL ) x = AN_VIS_COL-1;
    psmask &= COLMSK;
    lp = (VU16 *)which->screen;
    lp += (y*AN_TOT_COL);
    lp[x] = letter|psmask;
    dirty = which->dirty;
    if ( dirty ) {
	/* We have a bit-array to maintain.
	 */
	dirty += (y*((AN_TOT_COL+(U32_BITS-1))/U32_BITS));
	dirty[x>>5] |= (1<<(x&0x1F));
    }
    if ( dbg_stamp ) dbg_stamp(x,y,letter,psmask);
    if ( vid_stamp ) vid_stamp(x,y,letter,psmask);
}

void st_font(font_num)
int font_num;
{
    def_font = font_num;
}

static int txt_zstr();
extern int zov_str(int col, int row, const char *ptr, int palette );
extern void zov_stamp( int col, int row, int stamp, int color );
extern void zov_clr_wid( int col, int row, int width );
extern int mbtxt_str(int col, int row, const char *ptr, int palette );
extern void mbtxt_stamp( int col, int row, int stamp, int color );
extern void mbtxt_clr_wid( int col, int row, int width );

const struct ksym {
    const char * const name;
    U32 val;
} syms[] = {
    { "No Video Text", (U32)notxt_str },
#if BITMAP_STR
    { "HOST", (U32)zbtxt_str },
#else
    { "HOST", 0 },
#endif
    { "ZRE", (U32)txt_zstr },
    { "ZOVER", (U32)zov_str },
    { "ZMB", (U32)mbtxt_str },
    { 0, 0 }
};
#define pdesc(val) { #val, val }
static const struct pt {
    const char * const name;
    U32 palette;
} pts[] = {
    pdesc(GRY_PAL),
    pdesc(BLU_PAL),
    pdesc(GRN_PAL),
    pdesc(CYN_PAL),
    pdesc(RED_PAL),
    pdesc(VIO_PAL),
    pdesc(YEL_PAL),
    pdesc(WHT_PAL),
    pdesc(GRY_PALB),
    pdesc(BLU_PALB),
    pdesc(GRN_PALB),
    pdesc(CYN_PALB),
    pdesc(RED_PALB),
    pdesc(VIO_PALB),
    pdesc(YEL_PALB),
    pdesc(WHT_PALB),
    pdesc(WHT_PALB|AN_BIG_SET)
};

int st_text_group( const struct menu_d *smp ) {
    const struct ksym *kp;

    int row = 4;
    int strnum;
    int col = 3;
    int buf;
    setancolors();
    ztv_mod_latch(~(1<<B_Z_XACC));
    txt_str(3,row,"vid_str = 0x",MNORMAL_PAL);
    txt_chexnum((U32)vid_str,8,RJ_ZF,MNORMAL_PAL);
    for ( kp = syms ; kp->name ; ++kp ) {
	if ( kp->val == (U32)vid_str ) break;
    }
    if ( kp->name ) {
	txt_cstr(" -> ",MNORMAL_PAL);
	txt_cstr(kp->name,MNORMAL_PAL);
    }
    row = 8;
    for ( strnum = 0 ; strnum < n_elts(pts) ; ++strnum ) {
	row += txt_height(pts[strnum].name,pts[strnum].palette);
	txt_str(col,row,pts[strnum].name,pts[strnum].palette);
	txt_chexnum(pts[strnum].palette,8,RJ_ZF,MNORMAL_PAL);
    }
    ++row;
    for ( col = 1 ; col < (AN_VIS_COL-2) ; ++col ) {
	txt_stamp(col,row,col+AN_A_STMP-1,MNORMAL_PAL);
    }
    while ( 1 ) {
	if ( ctl_read_sw(SW_NEXT) & SW_NEXT ) break;
	if ( ctl_read_sw(SW_ACTION) & SW_ACTION ) ztv_bufswap();
	txt_hexnum(-1,2,eer_rtc&0xFF,3,RJ_ZF,MNORMAL_PAL);
	buf = *ztv_base & (1<<B_Z_CURBUF);
	txt_hexnum(-1,3,(U32)buf,1,RJ_ZF,MNORMAL_PAL);
	prc_delay(1);
    }
    return 0;
}

/*	ZRE Text portion starts here */
/* We are using local texture RAM to hold the "textures" which
 * represent the alphanumerics. Therefore, we need "ROM" data
 * to initialize it.
 */

int z20_init_loctex()
{
    int offset;
    struct txt_alpha_ptr *which;

    which = txt_vsptr(0);
    if ( which == 0 ) return -1;

#if SHORT16_OFFS
#define ANTX_CHUNK (32)
    {
	/* The texture memory is essentially little-endian, but
	 * ztv_texture_write() swaps 16-bit words within a longword
	 * to pander to big-endian processors. So we end up
	 * having to swap words on a little-endian CPU, to
	 * pre-compensate for this effect.
	 */
	int len,sofar;
	U32 swb[ANTX_CHUNK];
	U16 *stamps = &an_stamps;
	len = &an_end-&an_stamps;
	sofar = 0;
	/* In real life, we would attempt to pre-allocate
	 * the stamp memory here, and use the returned offset
	 * below. Since allocation doesn't work yet, we do
	 * what the BIG_ENDIAN version does, and always
	 * write at zero.
	 */
	offset = 0;
	while ( sofar < len ) {
	    int idx,cnt;
	    cnt = len - sofar;
	    /* Clip cnt to our chunk size, and ensure
	     * that the last chunk has an even length,
	     * Then shift down because cnt is in 16-bit words,
	     * but we are swapping a pair of them at once.
	     */
	    if ( cnt > (ANTX_CHUNK<<1) ) cnt = (ANTX_CHUNK<<1);
	    cnt = (cnt+1)>>1;
	    for ( idx = 0 ; idx < cnt ; ++idx ) {
		/* Form a big-endian longword */
		U32 data;
		data = ((U32 *)stamps)[idx];
		data = (data << 16) | (data >>16);
		swb[idx] = data;
	    }
	    cnt <<= 1;	/* back to count of 16-bit words */
	    idx = ztv_texture_write(sofar,swb,cnt);
	    if ( idx < 0 ) { offset = idx ; break; }
	    sofar += cnt;
	    stamps += cnt;
	}
    }
#else
    offset = ztv_texture_write(0,(U32*)&an_stamps,&an_end-&an_stamps);
#endif /* SHORT16_OFFS */
    if ( offset >= 0 ) which->texture_offset = offset;
    return offset;
}

#define XP (0x80000000)
#define RED_GRN ((RED_MSK<<16)|GRN_MSK)
const U32 st_text_palettes[] = {
    BLK_SLT, BLK_BLU, BLK_GRN, BLK_CYN,			/* 0x00 */
    BLK_RED, BLK_VIO, BLK_YEL, BLK_WHT,			/* 0x04 */
    GRY_SLT, GRY_BLU, GRY_GRN, GRY_CYN,			/* 0x08 */
    GRY_RED, GRY_VIO, GRY_YEL, GRY_WHT,			/* 0x0C */
    BLK_SLT|XP, BLK_BLU|XP, BLK_GRN|XP, BLK_CYN|XP,	/* 0x10 */
    BLK_RED|XP, BLK_VIO|XP, BLK_YEL|XP, BLK_WHT|XP,	/* 0x14 */
    RED_GRN|XP						/* 0x18 */
};
#define RG_PAL (0x18)

const char * const z20_pmsg[] = {
    "BLK_SLT", "BLK_BLU", "BLK_GRN", "BLK_CYN",
    "BLK_RED", "BLK_VIO", "BLK_YEL", "BLK_WHT",
    "GRY_SLT", "GRY_BLU", "GRY_GRN", "GRY_CYN",
    "GRY_RED", "GRY_VIO", "GRY_YEL", "GRY_WHT",
    "BLK_SLT|XP", "BLK_BLU|XP", "BLK_GRN|XP", "BLK_CYN|XP",
    "BLK_RED|XP", "BLK_VIO|XP", "BLK_YEL|XP", "BLK_WHT|XP",
    "RED_GRN|XP"
};

const int z20_nelts_st_text_palettes = n_elts(st_text_palettes);

int z20_init_colram(offset)
int offset;
{
    VU32 *csr = &ZRE_CSR;
    int idx;
    U32 *dst;
    U32 data;
    S32 spinner;
    struct txt_alpha_ptr *which;

    /* It would be exceptionally rude to steal the
     * Texture color RAM while it was still painting.
     */
    if ( ztv_base == &ZTV_CTL )	data = 0;
    else data = (1<<B_ZRE_IDLE);
    for ( spinner = TOO_LONG ; spinner >= 0 ; spinner -= LOOP_TIME ) {
	if ( (*csr & (1<<B_ZRE_IDLE) ) == data ) break;
    }
    if ( spinner < 0 ) {
	holler(2, 2, "IDLE NOT HAPPENING; CSR=0x",*csr);
	return 0;
    }

    which = txt_vsptr(0);
    if ( which == 0 ) return 0;
    which->color_offset = offset;

    *csr |= (1<<B_ZRE_TLEN);	/* _DIS_able Texture pipe */
    dst = (U32*)ZRE_COLRAM_ADDR+offset;
    for ( idx = 0 ; idx < n_elts(st_text_palettes) ; ++idx ) {
	U32 fg,bg,mid;
	fg = st_text_palettes[idx];
	bg = fg >> 16;
	fg &= 0xFFFF;
	/* derive an anti-alias color halfway from fg to bg */
	mid =  fg & ~(RED_LSB|GRN_LSB|BLU_LSB|0x8000);
	mid += bg & ~(RED_LSB|GRN_LSB|BLU_LSB|0x8000);
	mid >>= 1;
	*dst = (bg |= 0x8000);
	if ( (*dst & 0xFFFF) != bg ) break;
	*++dst = mid;
	if ( (*dst & 0xFFFF) != mid ) break;
	*++dst = mid;
	if ( (*dst & 0xFFFF) != mid ) break;
	*++dst = fg;
	if ( (*dst & 0xFFFF) != fg ) break;
	++dst;
    }
    *csr &= ~(1<<B_ZRE_TLEN);	/* _EN_able Texture pipe */
    if ( idx < n_elts(st_text_palettes) ) return -1;
    return 0;
}

int zre_text_init( unsigned int tex_offs, unsigned int col_offs)
{
    int status;
    struct txt_alpha_ptr *which;

    which = txt_vsptr(0);
    if ( which == 0 || which->screen == 0 ) {
	/* as good a time as any... */
	which = &default_screen;
	which->screen = (VU32 *)&fake_screen[0][0];
	which->dirty = def_dirty;
	which->texture_offset = tex_offs;
	which->color_offset = col_offs;
	txt_vsptr(which);
    }

    status = z20_init_colram(col_offs);
    if ( status < 0 ) return status;
    return z20_init_loctex(tex_offs);
}

/* Following preloads needed to do any text at all */
STATIC const U32 boilerplate[] = {
    0x04000007,		/* TRAP PLH 8 */
    0x08000007,		/* TRAP PRH 8 */
    0x10000000,		/* Vertical */
    0x18000000,		/* Vertical */
/* Magic no-perspective PERC, verbatim from pencil sheet */
    0x20400000,		/* VD PL0 */
    0x21400000,		/* VD PR0 */
    0x22000000,		/* VD PDL */
    0x23000000,		/* VD PDR */
    0x24000000,		/* VN PL0 */
    0x25000000,		/* VN PR0 */
    0x26400000,		/* VN PDL */
    0x27400000,		/* VN PDR */
    0x28400000,		/* HD PL0 */
    0x29000000,		/* HD PR0 */
    0x2A000000,		/* HD PDL */
    0x2B000000,		/* HD PDR */
    0x2C000000,		/* HN PL0 */
    0x2D400000,		/* HN PR0 */
    0x2E000000,		/* HN PDL */
    0x2F000000,		/* HN PDR */
#if (0)
    0x40000000,		/* SCI_S_PL0 = 0.0.0 */
    0x4100ff00,		/* SCI_S_PR0 = 0.ff.0 */
    0x42000000,		/* SCI_S_PDL = 0.0.0 */
    0x43000000,		/* SCI_S_PDR = 0.0.0 */
    0x44000000,		/* SCI_T_PL0 = 0.0.0 */
    0x45000000,		/* SCI_T_PR0 = 0.0.0 */
    0x4600ff00,		/* SCI_T_PDL = 0.ff.0 */
    0x4700ff00,		/* SCI_T_PDR = 0.ff.0 */
#else
/* The SCI_S and SCI_T regs are swapped. */
    0x44000000,		/* SCI_S_PL0 = 0.0.0 */
    0x4500ff00,		/* SCI_S_PR0 = 0.ff.0 */
    0x46000000,		/* SCI_S_PDL = 0.0.0 */
    0x47000000,		/* SCI_S_PDR = 0.0.0 */
    0x40000000,		/* SCI_T_PL0 = 0.0.0 */
    0x41000000,		/* SCI_T_PR0 = 0.0.0 */
    0x4200ff00,		/* SCI_T_PDL = 0.ff.0 */
    0x4300ff00,		/* SCI_T_PDR = 0.ff.0 */
#endif
    0x50800330,		/* Texture 8x8x2 */
    0x78000000,		/* In your face at Z = 0 */
    0x79000000,		/* No change at right edge */
    0x7A000000,		/* No change down the left side */
    0x7B000000,		/* No change down right side */
#if (0)
    0x7C030000,		/* Flat, no Z compare */
#else
    0x7C032000,		/* Flat, no Z compare, XP (color D15 = invis) */
#endif
};

#define ASCII_OFFSET (((&an_norm_a-&an_stamps)>>3)-'A')

static int
txt_zstr(col, row, txt, palset)
int col, row, palset;
const char *txt;
{
    /* txt_str has already done the hard work */
    return txt_width(txt,palset);
}

static void
txt_zclr(col, row, width)
int col, row, width;
{
    VU16 *lp;
    struct txt_alpha_ptr *which;

    which = txt_vsptr(0);
    if ( which == 0 || which->screen == 0 ) return;
    lp = (VU16 *)(which->screen)+(row*AN_VIS_COL+col);
    memset((void *)lp,0,width*sizeof(*lp));
}

static void txt_zstamp(int col, int row, int stampno, int pal_font) {
}

#ifndef SCI_SHF
#define SCI_SHF (29)
#endif
#ifndef PLREG_SHF
#define PLREG_SHF (26)
#endif
#ifndef FEND_OP
#define FEND_OP (7)
#endif

extern int zre_bkg();

/*		txt_2_traps(screen)
 *	scans a "fake screen" and emits TBUS commands to display
 *	the requested alphanumerics.
 */
#ifndef TEXMAP_PTB
#define TEXMAP_PTB (0x4C000000)
#endif

void
txt_2_traps(screen)
const U16 *screen;
{
    VU16 *lp;
    VU32 *csr = &ZRE_CSR;
    U32	old_csr,old_ztv;
    int cidx;		/* "Command" Index */
    const U32 *clist = boilerplate;
    int	x,y;
    VU32 *dirty;
    int y_init,old_col = -1;
    int stamp;
    U32 prx_offs = ((TRAP_PRX-TRAP_PLX)<<PLREG_SHF)+(7<<12);
    U32 texmap,color_cmd;

    struct txt_alpha_ptr *which;

    which = txt_vsptr(0);
    if ( which == 0 || which->screen == 0 ) return;

    lp = (VU16 *)(which->screen);
    dirty = which->dirty;
    /* Pre-bias the texmap entry (altered and emitted
     * on a per-stamp basis) to include the offset to
     * the base of the AlphaNumeric textures. This
     * register species the offset to (0,0) in _pairs_
     * of 16-bit texture words.
     */
    texmap = TEXMAP_PTB|((which->texture_offset)>>1);
    color_cmd = 0x54000000 | (which->color_offset);
 
    old_ztv = ztv_mod_latch(0);
    old_csr = *csr;
    if ( (old_csr & (1<<B_ZRE_REON)) == 0 ) {
	if ( zre_init() < 0 ) return;
    }
    ztv_mod_latch(1<<B_Z_XACC);
    *csr |= (1<<B_ZRE_XTOT);
#ifdef ZIG
    *csr &= (xtot_bit| ~(1<<B_ZRE_XTOT));
#endif
    while ( (*csr & (1<<B_ZRE_TFULL) ) == 0 ) {;}
    for ( cidx = 0 ; cidx < n_elts(boilerplate) ; ++cidx ) {
	ZRE_XTOT = clist[cidx];
    }
    for ( y = 0 ; y < AN_VIS_ROW ; ++y ) {
	y_init = (TRAP_PY<<PLREG_SHF)|(((AN_VIS_ROW-y)<<3)-1);
	if ( dirty ) {
	    U32 left,right;
	    left = *dirty++;
	    right = *dirty++;
	    if ( !( left | right) ) continue;
	    lp = ((VU16 *)which->screen)+(y*AN_VIS_COL);
	    x = 0;
	    while ( left | right ) {
		while ( left ) {
		    if ( !(left & 0xFF) ) {
			left >>= 8;
			x += 8;
			continue;
		    }
		    if ( left & 1 ) {
			U32 plx,ptb,ppw=0,plb=0;
			U32 new_col;
			stamp = lp[x];
			new_col = stamp >> AN_PAL_SHF;
			if ( new_col != old_col ) {
			    old_col = new_col;
			    plb = color_cmd | ((new_col &~(BGBIT>>AN_PAL_SHF)) << 2);
			    ppw = 0x7C030000 | ((new_col & (BGBIT>>AN_PAL_SHF)) ? 0 : 0x2000);
			}
			stamp &= (1<<AN_PAL_SHF)-1;
			plx = (TRAP_PLX<<PLREG_SHF)|(x<<15);
			ptb = texmap|(stamp<<2);
			while ( (*csr & (1<<B_ZRE_TFULL) ) == 0 ) {;}
			if ( y_init ) {
			    ZRE_XTOT = y_init;
			    y_init = 0; 
			}
			ZRE_XTOT = plx;
			ZRE_XTOT = plx+prx_offs;
			ZRE_XTOT = ptb;
			if ( plb ) {
			    ZRE_XTOT = plb;
			    ZRE_XTOT = ppw;
			}
			ZRE_XTOT = 0xCf000000;	/* TSTART */
		    }
		    left >>= 1;
		    ++x;
		}
		left = right;
		right = 0;
		x = 32;
	    }
	} else {
	    /* No dirty-bit array, scan whole line */
	    for ( x = 0 ; x < AN_VIS_COL ; ++x ) {
		if ( (stamp = lp[x]) != 0 ) {
		    /* got a non-blank, get ready and wait */
		    U32 plx,ptb,ppw=0,plb=0;
		    U32 new_col;
		    new_col = stamp >> AN_PAL_SHF;
		    if ( new_col != old_col ) {
			old_col = new_col;
			plb = color_cmd | ((new_col &~(BGBIT>>AN_PAL_SHF)) << 2);
			ppw = 0x7C030000 | ((new_col & (BGBIT>>AN_PAL_SHF)) ? 0 : 0x2000);
		    }
		    stamp &= (1<<AN_PAL_SHF)-1;
		    plx = (TRAP_PLX<<PLREG_SHF)|(x<<15);
		    ptb = texmap|(stamp<<2);
		    while ( (*csr & (1<<B_ZRE_TFULL) ) == 0 ) {;}
		    if ( y_init ) {
			ZRE_XTOT = y_init;
			y_init = 0; 
		    }
		    ZRE_XTOT = plx;
		    ZRE_XTOT = plx+prx_offs;
		    ZRE_XTOT = ptb;
		    if ( plb ) {
			ZRE_XTOT = plb;
			ZRE_XTOT = ppw;
		    }
		    ZRE_XTOT = 0xCf000000;	/* TSTART */
		}
	    }
	    lp += AN_VIS_COL;
	} /* End if (dirty bits available) */
    }
    *csr = old_csr;
    if ( (old_ztv & (1<<B_Z_XACC)) == 0 ) ztv_mod_latch(~(1<<B_Z_XACC));
}

#if !USE_ISPRINTF && (HOST_BOARD == LCR3K || HOST_BOARD == HCR4K)
# define Isprintf nisprintf
# define SPRINTF_WHERE(x, siz) x, siz
# include <nsprintf.h>
#else
# define Isprintf isprintf
# define SPRINTF_WHERE(x, siz) x
extern int isprintf(char *, const char *, ... );
#endif

int AN_stamp_test(const struct menu_d *smp);

int zre_text_test(const struct menu_d *smp)
{
    int tidx,row;
    int old_text;
    int bottom;
    VU32 *csr = &ZRE_CSR;
    U32	old_csr,old_ztv;
    struct txt_alpha_ptr *which;

    which = txt_vsptr(0);
    if ( which == 0 || which->screen == 0 ) {
	/* as good a time as any... */
	zre_text_init(0x10000,0x8000);
	which = txt_vsptr(0);
    }
    if ( smp->mn_label[0] == 'A' ) return AN_stamp_test(smp);

    zre_text_init(which->texture_offset,which->color_offset);
    memset((void *)which->screen,0,FS_SIZE);
    old_text = txt_select(TXT_ZRE);
    bottom = st_frame(smp,TITLE_PAL,INSTR_PAL,0);
    bottom = st_insn(bottom,t_msg_next,t_msg_ret_menu,INSTR_PAL);

    old_ztv = ztv_mod_latch(0);
    old_csr = *csr;
    if ( (old_csr & (1<<B_ZRE_REON)) == 0 ) {
	int status = zre_init();
	if ( status < 0 ) return status;
    }
    ztv_mod_latch(1<<B_Z_XACC);
    *csr |= (1<<B_ZRE_XTOT);
#ifdef ZIG
    *csr &= (xtot_bit| ~(1<<B_ZRE_XTOT));
#endif

    tidx = -1;
    row = 2;
    if ( smp->mn_label[0] != 'P' ) setancolors();
    while (1) {
	if ( ctl_read_sw(SW_NEXT) & SW_NEXT ) break;
	if ( row++ >= (AN_VIS_ROW-5) ) row = 2; 
	if ( ++tidx >= n_elts(st_text_palettes) ) tidx = 0;
	if ( smp->mn_label[0] == 'P' ) {
	    txt_str(10,tidx+2,z20_pmsg[tidx],(tidx<<AN_PAL_SHF)|BGBIT);
	} else {
	    txt_str(10,row,"Hello, World",tidx<<AN_PAL_SHF);
	}
	zre_bkg();
	txt_2_traps(which->screen);
	/* End frame and swap when done. Returns non-zero if it
	 * takes to long to do.
	 */
	if ( zre_frame_end(3) ) {
	    int spinner;
	    char msg[AN_VIS_COL+2];
	    Isprintf(SPRINTF_WHERE(msg, sizeof(msg)),"Frame End Timeout: ZRE_CSR=0x%4X ZTV_CSR=0x%4X",
		ZRE_CSR&0xFFFF,*ztv_base & 0xFFFF);
	    txt_str(-1,2,msg,ERROR_PAL);
	    for ( spinner = 42 ; spinner > 0 ; --spinner ) {
		if ( ctl_read_sw(SW_NEXT) & SW_NEXT ) return 1;
		prc_delay(1);
	    }
	    txt_clr_str(-1,2,msg,ERROR_PAL);
	}
	if ( smp->mn_label[0] == 'S' ) prc_delay(10);
    }
    txt_select(old_text);
    *csr = old_csr;
    if ( (old_ztv & (1<<B_Z_XACC)) == 0 ) ztv_mod_latch(~(1<<B_Z_XACC));
    return 0;
}

extern int bm_rect();

int zre_transp(const struct menu_d *smp)
{
    int screens = 2;

    /* Put AlphaNumeric Textures above the Cube-Movie
     * texture, colors above the kluge for ZIG Direct
     * textures.
     */
    zre_text_init(0x10000,0x8000);

    /* get everything else off the screen */
    memset(fake_screen,0,sizeof(fake_screen));
    memset(def_dirty,0,sizeof(def_dirty));
    txt_zstr(2,2,"\135",RG_PAL<<AN_PAL_SHF);
    txt_zstr(2,3,"\135",0);
#if HOST_BOARD == ASCLEAP
    zre_bkg();
#endif
    while (1) {
	if ( ctl_read_sw(SW_NEXT) & SW_NEXT ) break;
	if ( screens ) {
	    --screens;
	    bm_rect(0,0,VIS_H_PIX-1,VIS_V_PIX-1,WHT_FUL,GRY_FUL);
	}
	txt_2_traps(fake_screen);
	/* End frame and swap when done. Returns non-zero if it
	 * takes to long to do.
	 */
	if ( zre_frame_end(3) ) {
	    int spinner;
	    char msg[AN_VIS_COL+2];
	    Isprintf(SPRINTF_WHERE(msg,sizeof(msg)), "Frame End Timeout: ZRE_CSR=0x%4X ZTV_CSR=0x%4X",
		ZRE_CSR&0xFFFF,*ztv_base & 0xFFFF);
	    txt_str(-1,2,msg,ERROR_PAL);
	    for ( spinner = 42 ; spinner > 0 ; --spinner ) {
		if ( ctl_read_sw(SW_NEXT) & SW_NEXT ) return 1;
		prc_delay(1);
	    }
	    txt_clr_str(-1,2,msg,ERROR_PAL);
	}
    }
    return 0;
}

#ifndef AN_STMP_CNT
#define AN_STMP_CNT ((&an_end-&an_stamps)/4)
#endif
#define	AN_COL_CNT	16
#define	AN_COL_SEP 	2
#define	AN_LFT_COL		((AN_VIS_COL - (AN_COL_CNT * AN_COL_SEP))/2)

#define	AN_ROW_CNT	10
#define	AN_ROW_SEP 	2
#define	AN_TOP_ROW	((AN_VIS_ROW - (AN_ROW_CNT * AN_ROW_SEP))/2)
#define	AN_MAX_ROWS	((AN_STMP_CNT / AN_COL_CNT) - AN_ROW_CNT)

int
AN_stamp_test(smp)
const struct menu_d *smp;
{
    VU32 *csr = &ZRE_CSR;
    U32	edges;
    m_int	i,j,update;
    m_uint	stamp,textPal;
    m_int	baserow;
    m_int	addrow;
    int old_text,bottom;

    /* Put AlphaNumeric Textures above the Cube-Movie
     * texture, colors above the kluge for ZIG Direct
     * textures.
     */
    zre_text_init(0x10000,0x8000);

    old_text = txt_select(TXT_ZRE);

    vid_clear();
    setancolors();

    SetANPal(MNORMAL_PAL,GRY_WHT);
    bottom = st_frame(smp,TITLE_PAL,INSTR_PAL,0);
    bottom = st_insn(bottom,"To see more characters,",t_msg_control,INSTR_PAL);
    
    for (i=0; i < AN_COL_CNT; i++)		/* display col #'s	*/
	txt_hexnum(AN_LFT_COL + (i * AN_COL_SEP),AN_TOP_ROW - 2,i,1,RJ_ZF,
	MNORMAL_PAL);
    
    baserow = 0;
    
    ctl_autorepeat(JOY_VERT,30,15);	/* Autorepeat after 1/2secs @@ 1/4 */

    update = 1;

    textPal = MNORMAL_PAL;
    while (1)
    {
	prc_delay0();
	edges = ctl_read_sw(JOY_ALL|SW_EXTRA);	/* get edges	*/
#if HOST_BOARD == ASCLEAP
	zre_bkg();
#endif
	if (edges & SW_NEXT)
	    break;			/* done with this test...	*/

	if (edges & SW_ACTION)
	{
	    textPal ^= BGBIT;
	    if ( (textPal & BGBIT) == 0 ) textPal += AN_NXT_PAL; 
	    txt_str(3,3,"Pal: ",MNORMAL_PAL);
	    txt_chexnum(textPal,8,RJ_ZF,MNORMAL_PAL);
	    update = 1;
	}

	if (ctl_read_sw(0) & SW_EXTRA)		/* SHIFT key?		*/
	    addrow = AN_ROW_CNT;
	else
	    addrow = 1;

	if (edges & J_UP)
	{
	    update = (baserow != 0);
	    if ((baserow -= addrow) < 0)
		baserow = 0;
	}
	else
	if (edges & J_DOWN)
	{
	    update = (baserow != AN_MAX_ROWS);
	    if ((baserow += addrow) > AN_MAX_ROWS)
		baserow = AN_MAX_ROWS;
	}

	if (update)
	{
	    stamp = (baserow * AN_COL_CNT);
	    for (j=0; j < AN_ROW_CNT; j++)
	    {
		m_int x,y;

		x = AN_LFT_COL - 3;
		y = AN_TOP_ROW + (j * AN_ROW_SEP);
		txt_hexnum(x,y,stamp/16,2,RJ_ZF,MNORMAL_PAL);

		for (i=0,x = AN_LFT_COL; i < AN_COL_CNT; i++,x += AN_COL_SEP) {
		    txt_stamp(x,y,stamp,textPal);
		    ++stamp;
		}
	    }
	    update = 0;	/* done with update	*/
	}
	txt_2_traps(fake_screen);
	while ( (*csr & (1<<B_ZRE_TFULL) ) == 0 ) {;}

	/* End frame and swap when done. Returns non-zero if it
	 * takes to long to do.
	 */
	if ( zre_frame_end(3) ) {
	    int spinner;
	    char msg[AN_VIS_COL+2];
	    Isprintf(SPRINTF_WHERE(msg,sizeof(msg)), "Frame End Timeout: ZRE_CSR=0x%4X ZTV_CSR=0x%4X",
		ZRE_CSR&0xFFFF,*ztv_base & 0xFFFF);
	    txt_str(-1,2,msg,ERROR_PAL);
	    for ( spinner = 42 ; spinner > 0 ; --spinner ) {
		if ( ctl_read_sw(SW_NEXT) & SW_NEXT ) return 1;
		prc_delay(1);
	    }
	    txt_clr_str(-1,2,msg,ERROR_PAL);
	}
    }
    txt_select(old_text);
    return 0;
}

/*		txt_select(which_method)
 *	Zoid20 has several different methods for getting
 *	text on the screen, none of them completely satisfactory.
 *	Use txt_select() to select the least objectionable
 *	at any given time. Returns previous setting.
 */

static int which_txt;

int txt_select ( method )
int method;
{
    int old_method;

    old_method = vid_str ? which_txt:TXT_HOST;
    switch (method) {
	case TXT_NONE :
	    vid_str = notxt_str;
	    vid_stamp = notxt_stamp;
	    vid_tclr = notxt_clr_wid;
	    break;
	case TXT_HOST :
#if BITMAP_STR
	    vid_str = zbtxt_str;
#else
	    vid_str = 0;
#endif
	    vid_stamp = zbtxt_stamp;
	    vid_tclr = zbtxt_clr_wid;
	    break;
	case TXT_ZRE :
	    vid_str = txt_zstr;
	    vid_stamp = txt_zstamp;
	    vid_tclr = txt_zclr;
	    break;
	case TXT_ZMB :
	    vid_str = mbtxt_str;
	    vid_stamp = mbtxt_stamp;
	    vid_tclr = mbtxt_clr_wid;
	    break;
	case TXT_ZOVER :
	    vid_str = zov_str;
	    vid_stamp = zov_stamp;
	    vid_tclr = zov_clr_wid;
	    break;
	default :
	    method = old_method;
	    break;
    }
    which_txt = method;
    return old_method;
}

/*		dbg_select(which_method)
 *	Zoid20 has several different methods for getting
 *	text on the screen, none of them completely satisfactory.
 *	Use dbg_select() to select the least objectionable
 *	at any given time, as the _alternate_ output. Returns
 *	previous setting.
 */

static int which_dbg;

int dbg_select ( method )
int method;
{
    int old_method;

    old_method = dbg_str ? which_dbg:TXT_NONE;
    switch (method) {
	case TXT_NONE :
	    dbg_str = notxt_str;
	    dbg_stamp = notxt_stamp;
	    dbg_tclr = notxt_clr_wid;
	    break;
	case TXT_HOST :
#if BITMAP_STR
	    dbg_str = zbtxt_str;
#else
	    dbg_str = 0;
#endif
	    dbg_stamp = zbtxt_stamp;
	    dbg_tclr = zbtxt_clr_wid;
	    break;
	case TXT_ZRE :
	    dbg_str = txt_zstr;
	    dbg_stamp = txt_zstamp;
	    dbg_tclr = txt_zclr;
	    break;
	case TXT_ZMB :
	    dbg_str = mbtxt_str;
	    dbg_stamp = mbtxt_stamp;
	    dbg_tclr = mbtxt_clr_wid;
	    break;
	case TXT_ZOVER :
	default :
	    method = old_method;
	    break;
    }
    which_dbg = method;
    return old_method;
}

@


1.17
log
@Changed extern to static for txt_zstr().
@
text
@d182 20
@


1.16
log
@The (probably) last revision is really an attempt to further
generalize to any system with a single "plane" of video, which
would therefore need to maintain a "fake screen" for purposes
of re-painting alphanumeric "overlays" onto the single video plane.
While this version should _work_ for Zoid, and it fixes one bug
related to non-BGBIT txt_stamp() calls, it should not be strictly
necessary for any Zoid development.
@
text
@d1089 1
a1089 1
extern int txt_zstr();
@


1.15
log
@Start of "chunking" speedups (storing more during VBlank),
protected by (HOST_BOARD == ASCLEAP). More use of txt_vsptr()
@
text
@d13 8
d46 11
a56 1
STATIC U32 fake_screen[AN_VIS_ROW][AN_VIS_COL];
d58 4
d192 1
a192 1

d277 10
d336 1
a336 1
	p_posn.col += width;
d369 1
d371 1
a371 1
void zbtxt_stamp( col, row, stamp, color )
d378 1
a378 1
    U32 *colptr;
a382 10
    if ( row < 0 ) {
	col = p_posn.col;	
	row = p_posn.row;
    }
    if (col < 0 ) {
	/* wants to center */
	col = (AN_VIS_COL+1) >> 1;
	if ( col < 0 ) col = 0;
    }

d424 5
a428 1

a430 1
#if (1)
a431 6
#else
	for ( col = AN_STMP_WID-1 ; col >= 0 ; --col ) {
	    *scrptr++ = colptr[scan&3];
	    scan >>= 2; 
	}
#endif
d517 1
a517 1
#if HOST_BOARD == ASCLEAP
d617 2
a618 2
	if ( ( letter = trantab[letter] ) < 0 ) letter = trantab[' ']; 
	width += 1 + (bt[letter].tr != 0);
d819 5
a823 1
    if ( dbg_str ) dbg_str(col,row,string,palette);
d834 26
d861 129
a989 2
    if ( vid_str ) width = vid_str(col,row,string,palette);
    p->col = old_col + width;
d997 40
d1052 27
d1102 1
d1104 3
d1141 1
a1141 1
    int col;
d1154 1
a1154 1
    row = 9;
d1156 2
a1157 1
	txt_str(3,row,pts[strnum].name,pts[strnum].palette);
a1158 1
	row += txt_height(pts[strnum].name,pts[strnum].palette);
a1167 1
#ifdef ZIG
a1168 3
#else
	buf = ZTV_STAT&(1<<B_Z_CURBUF);
#endif
d1170 1
a1170 1
	prc_delay(10);
d1328 2
a1329 2
	which->screen = &fake_screen[0][0];
	which->dirty = 0;
d1397 1
a1397 1
int
d1402 2
a1403 14
    VU32 *lp;
    U32 stamp;
    struct txt_alpha_ptr *which;
    const char *src = txt;

    which = txt_vsptr(0);
    if ( which == 0 || which->screen == 0 ) return 0;
    lp = which->screen+(row*AN_VIS_COL+col);
    while ( ( stamp = *src++) != 0 ) {
	if ( stamp == ' ' ) stamp = 0;
	else stamp += ASCII_OFFSET;
	*lp++ = (stamp | palset);
    }
    return src - txt;
d1406 1
a1406 1
void
d1410 1
a1410 1
    VU32 *lp;
d1415 1
a1415 1
    lp = which->screen+(row*AN_VIS_COL+col);
d1419 1
a1419 8
void txt_zstamp(int col, int row, int stampno, int pal_font) {
    VU32 *lp;
    struct txt_alpha_ptr *which;

    which = txt_vsptr(0);
    if ( which == 0 || which->screen == 0 ) return;
    lp = which->screen+(row*AN_VIS_COL+col);
    *lp = stampno | pal_font;
d1444 1
a1444 1
const U32 *screen;
d1446 1
a1446 1
    VU32 *lp;
d1452 1
a1452 1

d1463 2
a1464 1
    lp = which->screen;
d1490 43
a1532 18
	for ( x = 0 ; x < AN_VIS_COL ; ++x ) {
	    if ( (stamp = lp[x]) != 0 ) {
		/* got a non-blank, get ready and wait */
		U32 plx,ptb,ppw=0,plb=0;
		U32 new_col;
		new_col = stamp >> AN_PAL_SHF;
		if ( new_col != old_col ) {
		    old_col = new_col;
		    plb = color_cmd | ((new_col &~(BGBIT>>AN_PAL_SHF)) << 2);
		    ppw = 0x7C030000 | ((new_col & (BGBIT>>AN_PAL_SHF)) ? 0 : 0x2000);
                }
		stamp &= (1<<AN_PAL_SHF)-1;
		plx = (TRAP_PLX<<PLREG_SHF)|(x<<15);
		ptb = texmap|(stamp<<2);
		while ( (*csr & (1<<B_ZRE_TFULL) ) == 0 ) {;}
		if ( y_init ) {
		    ZRE_XTOT = y_init;
		    y_init = 0; 
d1534 33
a1566 6
		ZRE_XTOT = plx;
		ZRE_XTOT = plx+prx_offs;
		ZRE_XTOT = ptb;
		if ( plb ) {
		    ZRE_XTOT = plb;
		    ZRE_XTOT = ppw;
a1567 1
		ZRE_XTOT = 0xCf000000;	/* TSTART */
d1569 2
a1570 2
	}
	lp += AN_VIS_COL;
d1592 1
d1600 2
a1601 6
	which = &default_screen;
	which->screen = &fake_screen[0][0];
	which->dirty = 0;
	which->texture_offset = 0;
	which->color_offset = 0x8000;
	txt_vsptr(which);
d1606 1
a1606 2
    memset(fake_screen,0,sizeof(fake_screen));

d1608 2
d1625 1
d1636 1
a1636 1
	txt_2_traps(fake_screen);
d1674 1
d1741 1
a1741 10
#if (0) /* HOST_BOARD == ASCLEAP */
    txt_str(2,4,"Stamp Base: 0x",MNORMAL_PAL);
    txt_chexnum(stamp_base,8,RJ_ZF,MNORMAL_PAL);
    txt_cstr(" Color Base: 0x",MNORMAL_PAL);
    txt_chexnum(color_base,8,RJ_ZF,MNORMAL_PAL);
    for ( i = 420 ; i >= 0 ; --i ) {
	if ( ctl_read_sw(SW_ACTION|SW_NEXT) & (SW_NEXT|SW_ACTION) ) break;
	prc_delay0();
    }
#endif
d1743 1
a1743 3
    bottom = st_insn(bottom,t_msg_control,"to see more characters",INSTR_PAL);

    SetANPal(MNORMAL_PAL,GRY_WHT);
a1805 2
		    txt_zstamp(x,y,stamp,textPal);
#if (0)
a1806 1
#endif
d1857 1
d1859 3
d1911 1
d1913 3
@


1.14
log
@started support for txt_vsptr (moveable virtual screen)
fixed several bugs related to palettes in ZRE text.
deleted some obsolete code, long since #if'd out.
@
text
@d420 5
a425 1
#define CLR_CHUNK (6)
d488 1
a488 1
	VU32 *cp = ztv_base;
d494 1
a494 1
		chunk = width;
d497 35
d534 2
a535 2
		while ( *zp & (1<<B_Z_VIDB) ) {;}
		*cp = cval | (1<<B_Z_DSM_OFF);    
d537 2
a538 1
		*cp = cval;
d1078 12
d1355 1
a1355 1
	    txt_str(10,tidx+2,z20_pmsg[tidx],tidx<<AN_PAL_SHF);
@


1.13
log
@Put "suggested parens" around expression in line 1140
@
text
@a33 10
/* Fall-back definitions for those who can't wait for
 * a proper check-in of ztv2.mac with ztv_vid.mac
 */
#ifndef B_Z_HBL_WAIT
#define B_Z_HBL_WAIT (20)
#endif
#ifndef ZTV_OPT_HBL_WAIT
#define ZTV_OPT_HBL_WAIT (1<<B_Z_HBL_WAIT)
#endif

d39 3
d49 20
d651 7
d664 6
d686 27
a895 9
static unsigned long stamp_base;
static unsigned long color_base;

extern const int vid_init_verbose;
extern int holler(int col, int row, const char *msg, U32 csr);
#ifndef TOO_LONG
#define TOO_LONG (17000000L)
#define LOOP_TIME (300)
#endif
d900 5
a905 6
    /* The texture memory is essentially little-endian, but
     * ztv_texture_write() swaps 16-bit words within a longword
     * to pander to big-endian processors. So we end up
     * having to swap words on a little-endian CPU, to
     * pre-compensate for this effect.
     */
d907 17
a923 17
    int len,sofar;
    U32 swb[ANTX_CHUNK];
    U16 *stamps = &an_stamps;
    len = &an_end-&an_stamps;
    sofar = 0;
    /* In real life, we would attempt to pre-allocate
     * the stamp memory here, and use the returned offset
     * below. Since allocation doesn't work yet, we do
     * what the BIG_ENDIAN version does, and always
     * write at zero.
     */
    offset = 0;
    while ( sofar < len ) {
	int idx,cnt;
	cnt = len - sofar;
	/* Clip cnt to our chunk size, and ensure
	 * that the last chunk has an even length;
d925 23
a947 12
	if ( cnt > ANTX_CHUNK ) cnt = ANTX_CHUNK;
	else cnt = (cnt+1)&~1;
	for ( idx = 0 ; idx < cnt ; ++idx ) {
	    /* Form a big-endian longword */
#if (0)
	    swb[idx] = (stamps[idx<<1] << 16) | stamps[(idx<<1)+1];
#else
	    U32 data;
	    data = ((U32 *)stamps)[idx];
	    data = (data << 16) | (data >>16);
	    swb[idx] = data;
#endif
a948 3
	idx = ztv_texture_write(sofar,swb,cnt);
	if ( idx < 0 ) { offset = idx ; break; }
	sofar += cnt;
d953 1
a953 1
    if ( offset >= 0 ) stamp_base = offset;
d990 1
d1005 4
a1009 1
    color_base = offset;
d1106 3
a1108 1
    U32 *lp,stamp;
d1111 3
a1113 1
    lp = &fake_screen[row][col];
d1126 2
a1127 1
    U32 *lp;
d1129 4
a1132 2
    lp = &fake_screen[row][col];
    memset(lp,0,width*sizeof(*lp));
d1136 2
a1137 1
    U32 *lp;
d1139 4
a1142 2
    lp = &fake_screen[row][col];
    *lp = stampno | (pal_font << 10);
d1169 1
a1169 1
    U32 *lp = (U32 *)fake_screen;
d1179 3
a1181 1
    U32 texmap = TEXMAP_PTB|stamp_base;
d1183 13
d1220 2
a1221 2
		    plb = 0x54000000 | (((new_col &~BGBIT) << 2) + color_base);
		    ppw = 0x7C030000 | ((new_col & BGBIT) ? 0 : 0x2000);
d1262 4
d1267 10
d1279 1
a1279 2
    z20_init_loctex();
    z20_init_colram(0x8000);
d1282 14
d1297 1
a1297 4
    row = 0;
#if HOST_BOARD == ASCLEAP
    zre_bkg();
#endif
d1300 1
a1300 1
	if ( row++ >= (AN_VIS_ROW-5) ) row = 1; 
d1303 1
a1303 1
	    txt_zstr(10,tidx,z20_pmsg[tidx],tidx<<AN_PAL_SHF);
d1305 1
a1305 1
	    txt_zstr(10,row,"Hello, World",tidx<<AN_PAL_SHF);
d1307 1
a1315 1
#ifdef ZIG
a1316 3
#else
		ZRE_CSR&0xFFFF,ZTV_STAT&0xFFFF);
#endif
d1326 3
d1337 6
a1342 2
    z20_init_loctex();
    z20_init_colram(0x8000);
a1364 1
#ifdef ZIG
a1365 3
#else
		ZRE_CSR&0xFFFF,ZTV_STAT&0xFFFF);
#endif
d1399 9
d1409 4
a1412 3
    z20_init_loctex();
    z20_init_colram(0x8000);
#if HOST_BOARD == ASCLEAP
d1422 2
a1423 2
    txt_str(-1,AN_VIS_ROW-5,t_msg_control,INSTR_PAL);
    txt_str(-1,AN_VIS_ROW-4,"to see more characters",INSTR_PAL);
d1448 1
a1448 1
	if (edges & SW_EXTRA)
d1451 3
d1457 1
a1457 1
	if (ctl_read_sw(0) & SW_ACTION)		/* SHIFT key?		*/
a1506 1
#ifdef ZIG
a1507 3
#else
		ZRE_CSR&0xFFFF,ZTV_STAT&0xFFFF);
#endif
d1516 1
@


1.12
log
@pre-swap alpha textures on little-endian CPUs. Pay attention
to color_base, which we may have moved.
@
text
@d1140 1
a1140 1
		    plb = 0x54000000 | ((new_col &~BGBIT) << 2) + color_base;
@


1.11
log
@use ztv_texture_write() instead of ad hoc tricks.
@
text
@d844 2
d856 44
d901 1
d931 2
a932 1
int z20_init_colram()
d954 2
a955 1
    dst = (U32*)ZRE_COLRAM_ADDR;
d1090 1
d1140 1
a1140 1
		    plb = 0x54000000 | (new_col &~BGBIT) << 2;
d1186 1
a1186 1
    z20_init_colram();
d1191 3
d1234 1
a1234 1
    z20_init_colram();
d1240 3
d1297 11
a1307 2
    z20_init_colram();

d1328 3
d1382 1
a1382 5
#if (0)
	ZRE_XTOT = (FEND_OP << SCI_SHF);
	while ( *csr & (1<<B_ZRE_FBUSY) ) {;}
	swap_and_wait();
#else
a1401 1
#endif
@


1.10
log
@Account for econ-o-zig (one-bank version)
Fixed presentation of BIG_SET in alpha test
stopped messing with XLED during texture or color RAM load
@
text
@d853 4
a856 64
#ifdef ZRE_CSR
    VU32 *csr = &ZRE_CSR;
    U16 *src;
    VU32 *dst;
    U32 data;
    S32 spinner;

    /* It would be exceptionally rude to steal the
     * Texture RAM while it was still painting.
     */
    if ( ztv_base == &ZTV_CTL )	data = 0;
    else data = (1<<B_ZRE_IDLE);
    for ( spinner = TOO_LONG ; spinner >= 0 ; spinner -= LOOP_TIME ) {
	if ( (*csr & (1<<B_ZRE_IDLE) ) == data ) break;
    }
    if ( spinner < 0 ) {
	holler(2, 2, "IDLE NOT HAPPENING; CSR=0x",*csr);
	return 0;
    }

    *csr |= (1<<B_ZRE_TLEN);	/* _DIS_able Texture pipe */
    src = &an_stamps;
    dst = 0;
#ifdef TEXRAM_ADDR
    dst = (U32*)TEXRAM_ADDR;
    data = *dst;
    *dst = ~data;
    if ( (*dst ^ ~data) == 0 ) {
	/* TEXRAM nominally present, use it.
	 */
	if (vid_init_verbose) txt_str(-1,6,"USING TEXRAM",MNORMAL_PAL);
	while ( src != &an_end ) {
	    U32 data = *src++;
	    /* TEXRAM requires duplicate data */
	    *dst++ = (data<<16)|data;
	}
	src = 0;
    }
#endif /* TEXRAM_ADDR */
#ifdef ZRE_LOCTEX_ADDR
    if ( src ) {
	/* TEXRAM not defined or not present, try
	 * ZRE_LOCTEX, on first rev board
	 */
	dst = (U32*)ZRE_LOCTEX_ADDR;
	stamp_base = 0x800000;
	data = *dst;
	*dst = ~data;
	if ( (*dst ^ ~data) & 0xFFFF ) {
	    /* still not RAM, insert some other fallback here.
	     */
	    stamp_base = 0;
	} else {
	    txt_str(-1,6,"USING LOCAL TEXTURE",MNORMAL_PAL);
	    while ( src != &an_end ) *dst++ = *src++;
	    src = 0;
	}
    }
#endif /* ZRE_LOCTEX_ADDR */
    *csr &= ~(1<<B_ZRE_TLEN);	/* _EN_able Texture pipe */
    return ( (src == 0) ? 0 : -2 );
#else
    return 0;
#endif /* ZRE_CSR */
@


1.9
log
@added default definition for B_Z_HBL_WAIT and ZTV_OPT_HBL_WAIT.
Deleted variant which did not check this bit during clr_wid()
@
text
@d180 1
d197 1
a197 1
	 * Note that althouth the signal name is IDLE, the '1' state
d217 8
a224 1
    y = (VIS_V_PIX-8 - (U32)(row << 3)) * VIS_H_PIX * BPPIXEL;
a244 1
		int fill = *colptr;
d246 1
d248 5
a252 4
		    for ( pixcnt = (2*AN_STMP_WID)-1 ; pixcnt >= 0 ; --pixcnt) {
			*scrptr++ = fill;
		    }
		    scrptr += (AN_VIS_COL<<3)-(2*AN_STMP_WID);
d255 1
a255 1
		scrptr += ((2*AN_STMP_WID)-(SCREENW*2*AN_STMP_HT));
d262 1
a262 1
		scrptr += (AN_VIS_COL<<3)-AN_STMP_WID;  /* update dest. ptr into screen memory */
d264 1
a264 1
	    scrptr += -(SCREENW*2*AN_STMP_HT);
d269 1
a269 1
		scrptr += SCREENW-AN_STMP_WID;  /* update dest. ptr into screen memory */
d279 1
a279 1
		scrptr += SCREENW-AN_STMP_WID;  /* update dest. ptr into screen memory */
d281 1
a281 1
	    scrptr += -(SCREENW*2*AN_STMP_HT);
d286 1
a286 1
		scrptr += SCREENW-AN_STMP_WID;  /* update dest. ptr into screen memory */
d309 1
a309 1
	    scrptr += SCREENW-AN_STMP_WID;  /* update dest. ptr into screen memory */
d312 1
a312 1
	scrptr += (AN_STMP_WID-(SCREENW*AN_STMP_HT));
d335 1
d351 1
a351 1
	 * Note that althouth the signal name is IDLE, the '1' state
d367 2
a368 1
    x = (U32)(col << 3) * BPPIXEL;            /* convert cell column into screen x offset */
d371 8
a378 1
    y = (VIS_V_PIX-8 - (U32)(row << 3)) * VIS_H_PIX * BPPIXEL;
d399 1
a399 1
	scrptr += SCREENW-AN_STMP_WID;  /* update dest. ptr into screen memory */
d417 1
d432 1
a432 1
	 * Note that althouth the signal name is IDLE, the '1' state
d452 8
a459 1
    y = (VIS_V_PIX-8 - (U32)(row << 3)) * VIS_H_PIX * BPPIXEL;
d495 1
a495 1
	scrptr += VIS_H_PIX*(BPPIXEL/sizeof(*scrptr));
a814 1
	row += txt_height(pts[strnum].name,pts[strnum].palette);
d817 1
d875 1
a882 2

	*csr |= (1<<B_ZRE_XLED);	/* XLED off during texture load */
a888 1
	*csr &= ~(1<<B_ZRE_XLED);	/* XLED on after texture load */
a965 1
    *csr &= ~(1<<B_ZRE_XLED);	/* LED on during color RAM write */
a986 1
    *csr |= (1<<B_ZRE_XLED);	/* LED off after color RAM write */
@


1.8
log
@moved "wait for hblank" from a variable to a bit in
ztv_options. Added possibility of Zover Text. Fixed
bug in "palette setting" which left zero in MSW of
an_pal for border and anti-alias color. Also minor
fix in Alpha Test screen for BIG string.
@
text
@d34 10
d409 1
a441 6
#ifndef B_Z_HBLANK
	lptr = scrptr;
	for ( h = width ; h ; --h ) {
	    *lptr++ = 0;
	}
#else
d462 3
a464 1
        } else {
a468 1
#endif
@


1.7
log
@Added a USE_ISPRINTF conditional to force using isprintf() instead of nisprintf().
@
text
@d87 1
a87 1
extern int no_wait_for_hblank;
d89 1
a89 1
   do if (!no_wait_for_hblank) { 					\
d124 1
a124 1
   } while (0)
d197 4
a200 5
#ifndef B_Z_HBLANK
    ztv_mod_latch((1<<B_Z_DSM_OFF));
#else
    if (no_wait_for_hblank) ztv_mod_latch((1<<B_Z_DSM_OFF));
#endif
d342 4
a345 5
#ifndef B_Z_HBLANK
    ztv_mod_latch((1<<B_Z_DSM_OFF));
#else
    if (no_wait_for_hblank) ztv_mod_latch((1<<B_Z_DSM_OFF));
#endif
d413 4
a416 5
#ifndef B_Z_HBLANK
    ztv_mod_latch((1<<B_Z_DSM_OFF));
#else
    if (no_wait_for_hblank) ztv_mod_latch((1<<B_Z_DSM_OFF));
#endif
d443 1
a443 1
        if (!no_wait_for_hblank) { 					\
d624 2
a625 2
    an_pal[palette][1] = GRY_FUL;	/* Border on BIG alphas */;
    an_pal[palette][2] = anti_alias;
d721 3
a723 1
extern int zov_str();
d767 1
d781 5
a785 3
    for ( row = 10 ; row < (10+n_elts(pts)) ; ++row ) {
	txt_str(3,row,pts[row-10].name,pts[row-10].palette);
	txt_chexnum(pts[row-10].palette,8,RJ_ZF,MNORMAL_PAL);
d787 1
d1412 4
@


1.6
log
@added timeout waiting for IDLE. Fixed dynamic XTOT_BIT polarity.
@
text
@d1146 1
a1146 1
#if HOST_BOARD == LCR3K || HOST_BOARD == HCR4K
@


1.5
log
@Renamed init_colram and init_loctex to z20_xxx and made them
non-static so they can be used by zag_test. Added z20_nelts_st_text_palettes
which is initialized to n_elts(st_text_palettes) so the value can be used
by zag_test. Renamed pmsg to z20_pmsg and made it non-static so it can
be referenced by zag_test.
@
text
@d810 5
d823 2
d830 8
a837 1
    while ((*csr & (1<<B_ZRE_IDLE) ) != data ) {;}
d917 2
d924 8
a931 1
    while ((*csr & (1<<B_ZRE_IDLE) ) != data ) {;}
d1103 1
a1103 1
    *csr &= ~xtot_bit;
@


1.4
log
@Put in conditional around isprintf, since 3 and 4k use nisprintf instead.
@
text
@d811 1
a811 1
STATIC int init_loctex()
d885 1
a885 1
static const char * const pmsg[] = {
d895 3
a897 1
STATIC int init_colram()
d941 1
a941 1
    status = init_colram(col_offs);
d943 1
a943 1
    return init_loctex(tex_offs);
d1141 2
a1142 2
    init_loctex();
    init_colram();
d1152 1
a1152 1
	    txt_zstr(10,tidx,pmsg[tidx],tidx<<AN_PAL_SHF);
d1186 2
a1187 2
    init_loctex();
    init_colram();
d1246 2
a1247 2
    init_loctex();
    init_colram();
@


1.3
log
@added ZTV_BITMAP_OFFSET kluge, to get around spurious warning
 from gcc on 4600.
@
text
@d1121 7
d1129 1
d1161 1
a1161 1
	    isprintf(msg,"Frame End Timeout: ZRE_CSR=0x%4X ZTV_CSR=0x%4X",
d1204 1
a1204 1
	    isprintf(msg,"Frame End Timeout: ZRE_CSR=0x%4X ZTV_CSR=0x%4X",
d1329 1
a1329 1
	    isprintf(msg,"Frame End Timeout: ZRE_CSR=0x%4X ZTV_CSR=0x%4X",
@


1.2
log
@Don't mess with ZBUFF_EN, either...
@
text
@d26 8
d210 1
a210 1
    scrptr = (U32*)ztv_base + ((VU32*)ZTV_BITMAP_ADDR - &ZTV_CTL);
d355 1
a355 1
    scrptr = (U32*)ztv_base + ((VU32*)ZTV_BITMAP_ADDR - &ZTV_CTL);
d428 1
a428 1
    scrptr = (U32*)ztv_base + ((VU32*)ZTV_BITMAP_ADDR - &ZTV_CTL);
@


1.1
log
@Initial revision
@
text
@d269 2
a270 1
	if ( zctl & (1<<B_Z_XACC) ) ztv_mod_latch(zctl & (1<<B_Z_XACC));
d294 2
a295 1
    if ( zctl & (1<<B_Z_XACC) ) ztv_mod_latch(zctl & (1<<B_Z_XACC));
d370 2
a371 1
    if ( zctl & (1<<B_Z_XACC) ) ztv_mod_latch(zctl & (1<<B_Z_XACC));
d463 2
a464 1
    if ( zctl & (1<<B_Z_XACC) ) ztv_mod_latch(zctl & (1<<B_Z_XACC));
@
