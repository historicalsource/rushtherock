head	1.13;
access;
symbols
	RUSH_ROCK_1_0:1.13
	RUSH_ROCK_1_0epst:1.13
	MACE_1_0e:1.11
	MACE_1_0d:1.11
	RUSH_1_06A:1.10
	AREA_52_00:1.13
	MACE_1_0a:1.11
	CJ_206:1.10
	CJ2_05:1.10
	CJ2_04:1.8
	CJ2_03:1.6;
locks; strict;
comment	@ * @;


1.13
date	97.07.01.22.40.48;	author albaugh;	state Exp;
branches;
next	1.12;

1.12
date	97.06.26.23.19.11;	author albaugh;	state Exp;
branches;
next	1.11;

1.11
date	97.02.27.04.04.45;	author shepperd;	state Exp;
branches;
next	1.10;

1.10
date	96.10.28.22.14.53;	author albaugh;	state Exp;
branches;
next	1.9;

1.9
date	96.10.24.21.47.51;	author albaugh;	state Exp;
branches;
next	1.8;

1.8
date	95.11.02.22.36.21;	author birmingham;	state Exp;
branches;
next	1.7;

1.7
date	95.11.01.19.02.02;	author shepperd;	state Exp;
branches;
next	1.6;

1.6
date	95.10.31.21.40.34;	author albaugh;	state Exp;
branches;
next	1.5;

1.5
date	95.09.11.20.59.09;	author albaugh;	state Exp;
branches;
next	1.4;

1.4
date	95.07.27.23.18.41;	author albaugh;	state Exp;
branches;
next	1.3;

1.3
date	95.06.21.16.07.47;	author albaugh;	state Exp;
branches;
next	1.2;

1.2
date	95.05.08.21.19.49;	author albaugh;	state Exp;
branches;
next	1.1;

1.1
date	94.12.16.17.26.58;	author albaugh;	state Exp;
branches;
next	;


desc
@menu-driven option setting. This is only the first, not the only,
sort of menu driver in GUTS.
@


1.13
log
@Added RCS ID string
@
text
@/*	menus.c
 *	Copyright 1987-1995 ATARI Games Corporation.  Unauthorized reproduction,
 *	adaptation, distribution, performance or display of this computer
 *	program or the associated audiovisual work is strictly prohibited. 
 */
#ifdef FILE_ID_NAME
const char FILE_ID_NAME[] = "$Id$";
#endif
/*
 *		Menu-driven option setting
 *	This stuff is used by the coin-option and game-option screens
 *	of self-test. The origianl menus.c was created by splitting
 *	out routines from stats.c (11-AUG-1992 MEA) This latest major
 *	re-write was done in SEPT/OCT 1995, also by MEA. It is a bit larger
 *	but includes "hooks" to allow odd-ball controls (such as the
 *	Area51 gun) to be used more effectively.
 */


#include <config.h>
#include <eer_defs.h>
#include <string.h>
#define GREAT_RENAME (1)
#include <os_proto.h>
#include <st_proto.h>

#ifndef AN_VIS_COL_MAX
# define AN_VIS_COL_MAX AN_VIS_COL
#endif
#ifndef AN_VIS_ROW_MAX
# define AN_VIS_ROW_MAX AN_VIS_ROW
#endif

#define	STATIC	static

/*	Some definitions for default placement on screen
 */
#define TOP_MARGIN (3)
#ifndef MENU_HDR_COL
#define MENU_HDR_COL (4)
#endif

#define MENU_OPTION_OFFSET (2)

/* Forward declarations */
STATIC const U8 * findopt
PARMS((const U8 *menu, int field));
STATIC int scan_menu( const U8 *menu, struct opt_menu_state *mnp );
STATIC int show_menu(
struct opt_menu_state *mnp,
int action );

/*		st_dispmenu()
 * A simplified, publish-able entry to this rats-nest, to allow
 * other bits of selftest (notably the Zoid test routines) to
 * display "packed" registers a bit more legibly.
 */
void st_dispmenu(const U8 *menu, U32 opt_bits, int erase) {
    struct opt_menu_state mns;

    if ( erase ) erase = M_ACT_ERASE_ALL;
    else erase = M_ACT_REDRAW;
    if ( scan_menu( menu, &mns ) > 0 ) {
	mns.bits = opt_bits;
	show_menu( &mns, erase );
    }
}

/*		st_optmenu()
 *	New, improved, (I would _hope_ MEA learned _something_ in the
 *	last 13 years) menu-driven option-setting code. Rather than
 *	a lot of special hacks to implements, e.g. "reset to original",
 *	this version has a "callback hook".
 */
#ifndef BAIL_TIME
#define BAIL_TIME (VCR_HOLD_TIME*10)
#endif
STATIC const char * const whats_wrong[] = {
    "Unknown problem with menu",
    "Zero-bit option",
    "Option over-runs U32",
    "Two options modify same bits",
    "Menu not terminated",
    "No bits modified by menu"
};

STATIC void complain(int row, int problem)
{
    int bail_time;
    if (  (problem < 0)
	|| (problem >= n_elts(whats_wrong)) ) problem = 0;
	
    ctl_read_sw(SW_NEXT);	/* kill latent edge */
    txt_str(-1,row,whats_wrong[problem],ERROR_PAL);
    st_insn(row+2, t_msg_ret_menu, t_msg_next, ERROR_PAL);
    for ( bail_time = BAIL_TIME ; bail_time > 0 ; --bail_time ) {
	if ( ctl_read_sw(SW_NEXT) & SW_NEXT ) break;
	prc_delay(1);
    }
}

/*		scan_menu()
 *	Reads a menu of the "Traditional" System I form, and splits
 *	it into items. Returns the number of items, or < zero if
 *	any of the the various "sanity checks" fail.
 */
STATIC int scan_menu( const U8 *menu, struct opt_menu_state *mnp ) {
    int len,lsb;
    U32 sofar,mask;
    const U8 *current;
    int nitems;

    sofar = 0;
    current = menu;

    mnp->select = mnp->top = 0;
    for ( nitems = 0 ; nitems < MAX_OPT_ITEMS ; ++nitems ) {
	/* Check which bits are used by this menu item.
	 * complain and bail if we find overlap.
	 */
	current = findopt(menu,nitems);
	if ( !current ) break;
	lsb = *current >> 3;
	len = *current & 7;
	if ( (lsb | len) == 0 ) {
	    /* normal end of menu is an item starting with '\000' */
	    mnp->items[nitems] = 0;
	    break;
	}
	if ( len == 0 ) {
	    /* Length of zero but non-zero lsb is error.
	     */
	    return -1;
	}
	if ( (len-1 + lsb) >= MAX_OPT_ITEMS ) {
	    /* We are asking for an option to go beyond limits
	     * of a U32.
	     */
	    return -2;
	}
	mask = (1<<len)-1;
	mask <<= lsb;
	if ( (sofar & mask) != 0 ) {
	    /* This field overlaps one previously encountered.
	     * Likewise complain and return un-changed option bits.
	     */
	    return -3;
	}
	sofar |= mask;
	mnp->items[nitems] = current;
	if ( current == 0 ) break;
    } /* end for ( each menu item ) */
    if ( current != 0 ) {
	/* Menu runs on after all 32 bits have been accounted for.
	 */
	return -4;
    } /* endif ( menu ill-terminated ) */
    if ( sofar == 0 ) {
	/* No bits actually specified...
	 */
	return -5;
    } /* endif ( menu ill-terminated ) */
    /* Fill rest of "items" array with null pointers
     * to simplify other users.
     */
    for ( len = nitems ; len < MAX_OPT_ITEMS ; ++len ) {
	mnp->items[len] = 0;
    }
    mnp->n_items = nitems;
    return nitems;
} 

/*		show_menu()
 *	Display a series of menu items, given a opt_menu_state struct
 *	which contains screen limits.
 *	returns updated row number.
 */
STATIC int show_menu(
struct opt_menu_state *mnp,
int action )
{
    int item,nitems;
    int lsb,len;
    U32 mask;
    int width;
    U8 tbuf[AN_VIS_COL_MAX];
    const U8 *txt;

    int row, bottom, opt_col;

    nitems = mnp->n_items;
    row = mnp->margin_t;
    bottom = mnp->margin_b;
    opt_col = mnp->margin_l+MENU_OPTION_OFFSET;

    if ( mnp->top ) {
	/* We have extra items above those shown on screen.
	 * Say so.
	 */
	if ( (action & ~M_ACT_ERASE) != M_ACT_SELECTED ) {
	    if ( action & M_ACT_ERASE ) {
		txt_clr_str(mnp->margin_l+3,row,
		  "MORE ABOVE",MNORMAL_PAL);
	    } else {
		txt_str(mnp->margin_l+3,row,
		  "MORE ABOVE",MNORMAL_PAL);
	    }
	}
	row += 2;
    }

    for ( item = mnp->top ; item < nitems ; ++item ) {
	int fld;
	int palette = MNORMAL_PAL;

	if ( (row+3) > bottom ) {
	    /* adding this item would over-run the
	     * bottom of the screen. We make a special
	     * exception for the very last item, but
	     * otherwise bail now.
	     */
	    if ( item > (nitems-1) || (row+2) > bottom ) break;
	}
	if ( ((action & ~M_ACT_ERASE) == M_ACT_SELECTED)
	   && (item != mnp->select) ) {
	    row += 3;
	    continue;
	}
	/* get field description from first byte of item,
	 * split into lsb and length, and skip possible '?'
	 */
	txt = mnp->items[item];
	lsb = *txt++;
	len = lsb&7;
	lsb >>= 3;
	if ( *txt == '?' ) ++txt;

	/* Limit string length so some doofus doesn't crash
	 * some over-delicate hardware.
	 */
	for ( width = 0 ; width < (mnp->margin_r-mnp->margin_l) ; ++width ) {
	    if ( (tbuf[width] = txt[width]) == '\0' ) break;
	}
	tbuf[width] = '\0';

	/* Erase or write menu item header.
	 */
	if ( item == mnp->select ) palette = MHILITE_PAL;
	if ( action & M_ACT_ERASE ) {
	    txt_clr_str(mnp->margin_l,row++,(char *)tbuf,palette);
	} else {
	    txt_str(mnp->margin_l,row++,(char *)tbuf,palette);
	}

	/* Get the current value for this item
	 */
	mask = (1L<<len)-1;
	mask &= (mnp->bits >> lsb);
	txt += width;		/* point to end of displayable header */
	while ( *txt++ ) {;}	/* Skip over rest of header, if any */
	for ( fld = 0 ; fld < mask ; ++fld ) {
	    /* count zero-terminated strings after header to get to the
	     * correct label for this field's value.
	     */
	    while ( *txt++ ) {;}
	}
	if ( *txt == '*' ) {
	    /* This is factory default for this item.
	     */
	    ++txt;
	    palette = GRN_PAL;
	    if ( mnp->select == item ) palette = GRN_PALB;
	}
	/* More-or-less same length protection and output for item
	 * value.
	 */
	for ( width = 0 ; width < (mnp->margin_r-opt_col) ; ++width ) {
	    if ( (tbuf[width] = txt[width]) == '\0' ) break;
	}
	tbuf[width] = '\0';
	if ( action & M_ACT_ERASE ) {
	    txt_clr_str(opt_col,row++,(char *)tbuf,palette);
	} else {
	    txt_str(opt_col,row++,(char *)tbuf,palette);
	}
	++row;	/* one blank line between items */
    }
    if ( item < mnp->n_items && (action & ~M_ACT_ERASE) != M_ACT_SELECTED ) {
	/* Could not fit all, say "MORE BELOW"
	 */
	if ( action & M_ACT_ERASE ) {
	    txt_clr_str(mnp->margin_l+3,row,"MORE BELOW",MNORMAL_PAL);
	} else {
	    txt_str(mnp->margin_l+3,row,"MORE BELOW",MNORMAL_PAL);
	}
    }
    return row;
}

/*		fit_menu()
 *	Calculate how many menu items will fit into a given
 *	vertical space. The "top" field of the referenced menu
 *	may be modified by this routine. The basic layout
 *	is two lines of "MORE ABOVE" and a blank, if top_item
 *	is (or becomes) non-zero, followed by one or more
 *	instances of (header,value,leading), which take three
 *	lines, followed by one line of "MORE BELOW" if applicable.
 *	If the selected item will not fit, "top" is incremented
 *	and we re-try. Returns number of items we can display.
 */

STATIC int fit_menu(
struct opt_menu_state *mnp
) {
    int can_fit;
    int lines_used;
    int space;		/* Number of lines available for display */

    space = mnp->margin_b - mnp->margin_t;

    can_fit = mnp->n_items-mnp->top;	/* Assume the best */
    
    while (1) {
	if ( can_fit <= 0 ) return 0;
	if ( mnp->select >= (can_fit+mnp->top) ) {
	    /* our selected item fell off the
	     * bottom, move the top down
	     * and re-calc optimistic guess.
	     */
	    mnp->top += 1;
	    can_fit = mnp->n_items-mnp->top;
	}
	/* Basic menu requires 2 lines per item,
	 * plus one line of leading for all but last.
	 */
	lines_used = ((can_fit-1)*3)+2;
	/* If the top item is not the first
	 * item in the menu, add 2 lines for
	 * "MORE ABOVE" and its leading.
	 */
	if ( mnp->top ) lines_used += 2;
	/* If not all items (below the top)
	 * fit on screen, and two lines for
	 * "MORE BELOW" and its leading.
	 */
	if ( can_fit < (mnp->n_items - mnp->top) ) {
	    lines_used += 2;
	}
	/* We win if it all fits.
	 */
	if ( lines_used <= space ) return can_fit;
	/* Otherwise we need to trim an item
	 * and re-try.
	 */
	--can_fit;
    }
}

#if J_LEFT && J_UP && (GUN_CNT == 0)
STATIC int joy_mdriver( struct opt_menu_state *cur)
{
    U32 ctls;
    U32 opt_bits;
    int nitems = cur->n_items;
    opt_bits = cur->bits;

    ctls = ctl_read_sw(JOY_BITS);

    if ( (ctls & JOY_BITS) == 0 ) return M_ACT_NONE;
    if ( (ctls & J_UP) && (cur->select > 0) ) {
	/* move up in menu, possibly scrolling.
	 */
	if ( --cur->select < cur->top ) cur->top = cur->select;
	return M_ACT_REDRAW;
    }
    if ( (ctls & J_DOWN) && (cur->select < (nitems-1)) ) {
	/* move down in menu.
	 */
	++cur->select;
	return M_ACT_REDRAW;
    }
    if ( ctls & J_LEFT ) return M_ACT_DECVAL;
    if ( ctls & J_RIGHT ) return M_ACT_INCVAL;
    return M_ACT_REDRAW;
}
#endif /* J_LEFT && J_UP which is to say, do we have a joystick, and no GUN */

#if (!J_LEFT || !J_UP) && (GUN_CNT == 0)
/* Modified "two button" interface originally done for "Genocide".
 * SW_NEXT selects menu item, LEFT/RIGHT (or SW_ACTION) diddle values,
 * _holding_ SW_NEXT exits (done in common code, st_optmenu())
 */
STATIC int joy_mdriver( struct opt_menu_state *cur)
{
    U32 ctls;
    U32 opt_bits;
    int nitems = cur->n_items;
    int retval = M_ACT_NONE;

    opt_bits = cur->bits;

#if J_UP
    ctls = ctl_read_sw(JOY_VERT);

    if ( (ctls & J_UP) && (cur->select > 0) ) {
	/* move up in menu, possibly scrolling.
	 */
	if ( --cur->select < cur->top ) cur->top = cur->select;
	return M_ACT_REDRAW;
    }
    if ( (ctls & J_DOWN) && (cur->select < (nitems-1)) ) {
	/* move down in menu.
	 */
	++cur->select;
	return M_ACT_REDRAW;
    }
#else
    ctls = ctl_read_sw(SW_NEXT);
    if ( ctls & SW_NEXT ) {
	/* Move down in menu, possibly scrolling. At bottom,
	 * return to top.
	 */
	++cur->select;
	if ( cur->select >= nitems ) cur->select = cur->top = 0;
	return M_ACT_REDRAW;
    }
#endif
#if J_LEFT
    ctls = ctl_read_sw(J_LEFT|J_RIGHT);
    if ( ctls & J_LEFT ) return M_ACT_DECVAL;
    if ( ctls & J_RIGHT ) return M_ACT_INCVAL;
#else
    if ( ctl_read_sw(SW_ACTION) & SW_ACTION ) return M_ACT_INCVAL;
#endif
    return retval;
}
#endif /* J_LEFT && J_UP which is to say, do we have a joystick, and no GUN */

#if GUN_CNT
extern int gun_mdriver(struct opt_menu_state *cur);
#endif

int (*st_opt_callback())(struct opt_menu_state *mnp)
{
#if GUN_CNT
    return gun_mdriver;
#else
    return joy_mdriver;
#endif
}

#define EX_CNT (40)
#define RST_CNT (40)

U32 st_optmenu(
const U8 *menu,
U32 opt_bits,
int top,
int bottom,
int (*callback)( struct opt_menu_state *mnp),
void *cb_vars
){
    struct opt_menu_state prev,cur;
    int nitems = 0;			/* Number of menu items */
    int redraw;				/* non-zero to re-draw menu */
    int fld_val;			/* value of current selected option field */
    U32 ctls;
#if !J_UP
    int ex_cnt = EX_CNT;		/* Timer for "Press and hold SW_NEXT" */
#endif
#if !J_LEFT
    int rst_cnt = RST_CNT;		/* Timer for "Press and hold SW_ACTION" */
#endif
    /* we need at least six lines to do anything: 
     * 2 for "More Above" and a blank line
     * 3 for a single menu item and blank line
     * 1 for "More Below"
     *
     * A menu consisting of a single item could be done
     * in two lines, but I'm not going to lose a lot of
     * sleep over it. (MEA 2OCT95)
     */
    if ( (bottom - top) < 6 ) return opt_bits;
    prev.cb_vars = cb_vars;
    cur.cb_vars = cb_vars;
    prev.n_items = 0;
    prev.top = 0;
    cur.top = 0;
    /* Establish margins for menu display. The control callback
     * can modify these (E.g. Gun-control might need wider
     * margins) but should probably not make the drawing area
     * larger than our caller asked for.
     */
    prev.margin_t = cur.margin_t = top;
    prev.margin_b = cur.margin_b = bottom;
    prev.margin_l = cur.margin_l = MENU_HDR_COL;
    prev.margin_r = cur.margin_r = AN_VIS_COL-2;
    prev.select = 0;
    cur.select = 0;
    cur.bits = cur.orig_bits = opt_bits;
    cur.warn_bits = 0;
    redraw = M_ACT_NONE;

    if ( !callback ) callback = st_opt_callback();

    while ( 1 ) {
	if ( nitems == 0 ) {
	    /* Either this is the first time we have seen the menu,
	     * or the menu has possibly changed (future enhancement)
	     * Build a list of pointers to the individual menu items.
	     */
	    nitems = scan_menu(menu, &cur);
	    if ( nitems < 0 ) {
		/* Some problem with menu format. Best we
		 * can do is complain and return unchanged
		 * option bits.
		 */
		txt_decnum(-1,2,(U32)(-nitems),10,LJ_NF,ERROR_PAL);
		complain(top,-nitems);
		return cur.orig_bits;
	    }
	    redraw = M_ACT_REDRAW;
	    fld_val = -1;		/* force re-calc of selected field */
	} /* endif ( we need to re-parse menu ) */

	/* Read and process controls */
	if ( callback && (redraw == M_ACT_NONE) ) {
	    redraw = callback( &cur );
	    opt_bits = cur.bits;
	}
	/* below is written as a "while" so we "fast forward"
	 * over any illegal options.
	 */
	while ( redraw == M_ACT_INCVAL || redraw == M_ACT_DECVAL ) {
	    /* change value of current field */
	    int len,lsb;
	    U32 mask,new;
	    const U8 *mp;
	    mp = cur.items[cur.select];
	    lsb = *mp >> 3;
	    len = *mp & 7;
	    mask = (1L<<len)-1;
	    /* get current value of this field, and increment
	     * or decrement it.
	     */
	    new = (opt_bits >> lsb)&mask;
	    if ( redraw == M_ACT_DECVAL ) --new;
	    else ++new;
	    /* Splice new value into opt_bits, so it will be correct
	     * when we break;
	     */
	    opt_bits &= ~(mask<<lsb);
	    opt_bits |= ((new&=mask)<<lsb);
	    cur.bits = opt_bits;
	    /* Scan for the corresponding label, to validate choice.
	     */
	    while (*++mp) {;}	/* Skip to '\000' before 1st label */
	    while (new) {
		while (*++mp) {;}	/* skip to '\0' before nth label */
		--new;
	    }
	    if ( mp[1] != '\0' ) redraw = M_ACT_SELECTED;
	}
	ctls = ctl_read_sw(SW_NEXT|SW_ACTION);

#if J_UP
	/* If we have a Joystick, _any_ closure on SW_NEXT
	 * will cause us to exit. Otherwise, only
	 * holding SW_NEXT will.
	 */
	if ( ctls & SW_NEXT ) redraw = M_ACT_EXIT;
	else
#else
	if ( ctl_read_sw(0) & SW_NEXT ) {
	    if ( --ex_cnt <= 0 ) redraw = M_ACT_EXIT;
	} else ex_cnt = EX_CNT;
#endif
#if J_LEFT
	/* If we have even LEFT/RIGHT, _any_ closure on SW_ACTION
	 * will cause us to reset to entry values. Otherwise,
	 * only _holding_ SW_ACTION will.
	 */
	if ( ctls & SW_ACTION ) {
	    cur.bits = opt_bits = cur.orig_bits;
	    redraw = M_ACT_REDRAW;
	}
#else
	if ( ctl_read_sw(0) & SW_ACTION ) {
	    if ( --rst_cnt <= 0 ) {
		cur.bits = opt_bits = cur.orig_bits;
		redraw = M_ACT_REDRAW;
	    }
	} else rst_cnt = RST_CNT;
#endif
	if ( redraw & M_ACT_EXIT ) break;
	if ( redraw || (cur.top != prev.top) ) {
	    /* Need to redraw whole menu */
	    if ( prev.n_items > 0 ) {
		/* there already was a menu, we need to erase it.
		 */
		fit_menu(&prev);
		show_menu( &prev, M_ACT_ERASE_ALL );
	    } /* endif ( need to erase ) */

	    fit_menu(&cur);
	    show_menu( &cur, M_ACT_REDRAW );
	    /* indicate we have already redrawn menu */
	    prev = cur;
	    redraw = M_ACT_NONE;
	} /* endif ( need to redraw whole menu) */
	if ( cur.bits != prev.bits ) {
	    /* need to re-draw one item */
	    show_menu(&prev, (M_ACT_SELECTED|M_ACT_ERASE));
	    show_menu(&cur, M_ACT_SELECTED);
	    prev.bits = cur.bits;
	}
	prc_delay0();
    } /* end while (1) */
    return cur.bits;
}


U32 DoOptions(
const U8 *menu,
U32 old_opts,
U32 swReset
){
    int bottom = AN_VIS_ROW-3;
#if J_UP
    bottom = st_insn(bottom,t_msg_save_ret, t_msg_next, INSTR_PAL);
#else
    bottom = st_insn(bottom,t_msg_save_ret, t_msg_nexth, INSTR_PAL);
#endif
#if J_LEFT
    bottom = st_insn(bottom,t_msg_restore, t_msg_action, INSTR_PAL);
#else
    bottom = st_insn(bottom,t_msg_restore, t_msg_actionh, INSTR_PAL);
#endif
    return st_optmenu( menu, old_opts, TOP_MARGIN, bottom-1,0,0);
}

/* :::::: FINDOPT scans through the given MENU STRUCTURE and :::::::	*/
/*	skips the appropriate number of fields				*/
/*	RETURNS 0 if no entry for that field				*/

STATIC const U8 *
findopt(menu,field)
const U8 *menu;
int field;
{
    m_int count;
    U8 c;
    const U8 *trail = menu;

    if ( field < 0 ) return 0;

    for ( ; field >= 0 ; --field)
    {
	trail = menu;
	if (*menu == 0) break;	/* zero length in header, end of menu	*/
	c = *menu++;
	count = 1 << ( c & 7 ); /* number of choices */
	if ( *menu == '?' ) {
	    /* this field should only be available during development
	     * and/or when enabled via "secret handshake"
	     */
	    ++menu;
#ifdef DEBUG
	    if ( (debug_mode & GUTS_OPT_DEVEL) == 0 )
#endif
		++field;
	}
	for ( ; count >= 0 ; --count )	     /* Skip title and choices*/
	    while (*menu++);
    }

    if (*trail == '\0')		/* zero length in header, end of menu	*/
	return(0);
    return(trail);
}

/*		factory_setting(menu)
 *	Computes and returns the "factory setting" as indicated
 *	by the selection (in each menu field) starting with a '*'
 */
U32
factory_setting(menu)
const U8 *menu;
{
    m_int count,shift,i;
    U32 options;

    options = 0;
    while ( *menu ) {
	shift = *menu >> 3;
	count = 1 << (*menu++ & 7);
	while ( *menu++ ) {;}
	for ( i = 0 ; i < count ; ++i ) {
	    if ( *menu == '*' ) options |= (i << shift);
	    while ( *menu++ ) {;}
	}
    }
    return options;
}

#if (0)
/*		dispopt(menu,opt_bits,y,color,erase)
*	Display one option selection given a menu string, formatted per below,
* the option word (and defaults), the position, and the color. An "erase flag"
* indicates that the the selection is to be erased, rather than written. If
* the current value matches the default value for this field (Indicated by a
* '*' in the menu,) the value string is output in palette 1 (HILITE).
*    This routine returns 0 if the end of the menu has been reached. It
*    normally returns the updated menu pointer (pointing to the next group of
*    option bits).
*	The menu string is encoded as follows. Each group of bits in the option
*    word is represented by a header byte whose bottom 3 bits indicate the
*    length of the field, and whose top 5 bits represent the bit number of the
*    lsb.
*    This is followed by the string to title the field (zero terminated),  which
*    is in turn followed by the strings corresponding to each possible value for
*    the field. The value string starting with an asterisk (*) is the factory
*    default. Any invalid setting is a null string (i.e. just a zero byte).
*    There must be a "string" (if only a zero) for each value, e.g. a three bit
*    field must have 8 "strings", although some (those corresponding to invalid
*    values) will be single zero bytes. The example menu string below encodes
*    bit D0 of the switch word as a field with two values and D2-D1 a one with
*    three values, the '10' code being invalid.
*
*  char *samplemenu =
*      "\001Single bit option:\0*No\0Yes\0\012Two bit:\0one\0two\0\0three\0\0\0"
*
*	Two things to note in this sample are the "012" which is the OCTAL
*    representation of the header byte (don't blame me, blame K&R), and
*    the fact that only two of the needed three terminating bytes are shown,
*    since C appends one zero-byte to the end of a quoted string. One other
*    caveat is to always use the full three digit form of the \000 if your
*    string starts with a digit. A slightly more legible example appears at
*    coinmenu, in coin91.c. By using the \<newline> (NOT \n) escape, the menu
*    can be made significantly more legible. An even more readable form can
*    be built with ANSI/ISO string concatenation, although I'm not absolutely
*    sure I can safely depend on its existance at this time (June, 1994. MEA)
*/

#endif
@


1.12
log
@Added "fallbacks" for operation without joystick.
@
text
@d2 8
a9 1
 *
a18 5
/*
 *	Copyright 1987-1995 ATARI Games Corporation.  Unauthorized reproduction,
 *	adaptation, distribution, performance or display of this computer
 *	program or the associated audiovisual work is strictly prohibited. 
 */
@


1.11
log
@Allowed for dynamic resolution. I.E. AN_VIS_COL et. al. can be made
into ints instead of #defines. On 3dfx systems this is accompolished
by defining the following in config.mac:
DEC_CONST DYNAMIC_VIS_PIX 1
DEC_CONST VIS_H_PIX_MAX whatever
DEC_CONST VIS_V_PIX_MAX whatever
After this, AN_VIS_COL, AN_VIS_ROW, VIS_V_PIX, VIS_H_PIX and
SST_RESOLUTION become "extern int" instead of #defines.
The new #defines AN_VIS_ROW_MAX and AN_VIS_COL_MAX are
created (computed from VIS_H_PIX_MAX, VIS_V_PIX_MAX) so
local arrays can be declared and this is the principle changed
to this file.
@
text
@d357 1
a357 1
#if J_LEFT && (GUN_CNT == 0)
d384 1
a384 1
#endif /* J_LEFT, which is to say, do we have a joystick */
d386 51
d450 3
d466 6
a471 1

d527 1
d564 17
a580 1
	if ( ctls & SW_NEXT ) break;
d585 9
d627 1
d629 4
d634 3
@


1.10
log
@Fixed definition of joy_mdriver() (Again?!).
@
text
@d25 7
d184 1
a184 1
    U8 tbuf[AN_VIS_COL];
@


1.9
log
@Major revisions to facilitate use of callbacks in option-menu
screens. These features are so far only used in phx_coin.c,
function cn_config(), but should help make all such screens
less dependant on #defines.
@
text
@d351 1
a351 1
STATIC int joy_mdriver( U32 original, struct opt_menu_state *cur)
@


1.8
log
@fixed two rookie errors by MEA, indirecting through
a NULL pointer and off by one.
@
text
@a28 8
#if (GUN_CNT)
/* If using gun to "fake" joystick, restrict screen area a bit */
#define TOP_MARGIN (5)
#define BOTTOM_MARGIN (9)
#ifndef MENU_HDR_COL
#define MENU_HDR_COL (6)
#endif
#else
a29 1
#define BOTTOM_MARGIN (8)
a32 25
#endif

#define MENU_OPTION_COL (MENU_HDR_COL+2)

/*	First, a structure that encapsulates the state of an option-select
 *	menu. By using this, we avoid passing a bunch of parameters, some
 *	by reference. The structure itself is passed by reference, of course.
 *	The items[] array is a set of pointers into a menu string as described
 *	below. It serves two purposes: 1) speeds up access to an item by
 *	index, to aid gun-driven operation. 2) potentially allows "editting"
 *	the fields of a menu in response to changes in other fields. The
 *	latter is so far a "future direction", and will take some care
 *	in implementation.
 */
#ifndef MAX_MENU_ITEMS
#define MAX_MENU_ITEMS (32)	/* Number of bits in U32 sets upper limit */
#endif

struct menu_state {
    int	n_items;
    int	select;
    int top;
    U32 bits;
    const U8 *items[MAX_MENU_ITEMS+1];
};
d34 1
a34 8
/*	Possible values for the "action" parameter of show_menu(), which
 *	are also used as possible returns for the "user control" coroutine.
 */
#define M_ACT_NONE (0)		/* No-operation */
#define M_ACT_ERASE (1)		/* "modifier" for REDRAW and SELECTED */
#define M_ACT_REDRAW (2)	/* redraw entire menu */
#define M_ACT_ERASE_ALL (3)	/* erase entire menu */
#define M_ACT_SELECTED (4)	/* draw (or erase) only selected item */
d39 1
a39 1
STATIC int scan_menu( const U8 *menu, struct menu_state *mnp );
d41 1
a41 3
struct menu_state *mnp,
int row,
int bottom,
d50 1
a50 1
    struct menu_state mns;
d56 1
a56 1
	show_menu( &mns, TOP_MARGIN, AN_VIS_ROW-BOTTOM_MARGIN, erase );
d98 1
a98 1
STATIC int scan_menu( const U8 *menu, struct menu_state *mnp ) {
d108 1
a108 1
    for ( nitems = 0 ; nitems < MAX_MENU_ITEMS ; ++nitems ) {
d126 1
a126 1
	if ( (len-1 + lsb) >= MAX_MENU_ITEMS ) {
d157 1
a157 1
    for ( len = nitems ; len < MAX_MENU_ITEMS ; ++len ) {
d165 2
a166 2
 *	Display a series of menu items, given a menu_state struct and
 *	screen limits.
d170 1
a170 3
struct menu_state *mnp,
int row,
int bottom,
d180 2
d183 3
d193 1
a193 1
		txt_clr_str(MENU_HDR_COL+3,row,
d196 1
a196 1
		txt_str(MENU_HDR_COL+3,row,
d232 1
a232 1
	for ( width = 0 ; width < (AN_VIS_COL-2-MENU_HDR_COL) ; ++width ) {
d241 1
a241 1
	    txt_clr_str(MENU_HDR_COL,row++,(char *)tbuf,palette);
d243 1
a243 1
	    txt_str(MENU_HDR_COL,row++,(char *)tbuf,palette);
d268 1
a268 1
	for ( width = 0 ; width < (AN_VIS_COL-2-MENU_OPTION_COL) ; ++width ) {
d273 1
a273 1
	    txt_clr_str(MENU_OPTION_COL,row++,(char *)tbuf,palette);
d275 1
a275 1
	    txt_str(MENU_OPTION_COL,row++,(char *)tbuf,palette);
d283 1
a283 1
	    txt_clr_str(MENU_HDR_COL+3,row,"MORE BELOW",MNORMAL_PAL);
d285 1
a285 1
	    txt_str(MENU_HDR_COL+3,row,"MORE BELOW",MNORMAL_PAL);
d304 1
a304 2
struct menu_state *mnp,
int space		/* Number of lines available for display */
d308 3
d350 2
a351 3
#define TRIAL_CONTROLS (1)
#if TRIAL_CONTROLS
STATIC int joy_mdriver( U32 original, struct menu_state *cur)
d373 2
a374 33
    /* below is written as a "while" so we "fast forward"
     * over any illegal options.
     */
    while ( ctls & (J_LEFT|J_RIGHT) ) {
	/* change value of current field */
	int len,lsb;
	U32 mask,new;
	const U8 *mp;
	mp = cur->items[cur->select];
	lsb = *mp >> 3;
	len = *mp & 7;
	mask = (1L<<len)-1;
	/* get current value of this field, and increment
	 * or decrement it.
	 */
	new = (opt_bits >> lsb)&mask;
	if ( ctls & J_LEFT ) --new;
	else ++new;
	/* Splice new value into opt_bits, so it will be correct
	 * when we break;
	 */
	opt_bits &= ~(mask<<lsb);
	opt_bits |= ((new&=mask)<<lsb);
	cur->bits = opt_bits;
	/* Scan for the corresponding label, to validate choice.
	 */
	while (*++mp) {;}	/* Skip to '\000' before 1st label */
	while (new) {
	    while (*++mp) {;}	/* skip to '\0' before nth label */
	    --new;
	}
	if ( mp[1] != '\0' ) break;
    }
d377 12
d390 1
d397 2
a398 1
int (*callback)(U32 original, struct menu_state *mnp)
d400 1
a400 1
    struct menu_state prev,cur;
a404 1
    U32 entry_bits = opt_bits;
d415 3
a417 1
    if ( (bottom - top) < 6 ) return entry_bits;
d421 9
d432 2
a433 1
    cur.bits = opt_bits;
d435 3
a437 3
#if TRIAL_CONTROLS
    if ( !callback ) callback = joy_mdriver;
#endif
d452 1
a452 1
		return entry_bits;
a458 1
#if TRIAL_CONTROLS
d460 1
a460 16
	    redraw = callback(entry_bits, &cur);
	}
	ctls = ctl_read_sw(SW_NEXT|SW_ACTION);
#else
	ctls = ctl_read_sw(JOY_ALL);
	if ( (ctls & J_UP) && (cur.select > 0) ) {
	    /* move up in menu, possibly scrolling.
	     */
	    if ( --cur.select < cur.top ) cur.top = cur.select;
	    else redraw = M_ACT_REDRAW;
	}
	if ( (ctls & J_DOWN) && (cur.select < (nitems-1)) ) {
	    /* move down in menu.
	     */
	    ++cur.select;
	    redraw = M_ACT_REDRAW;
d465 1
a465 1
	while ( ctls & (J_LEFT|J_RIGHT) ) {
d478 1
a478 1
	    if ( ctls & J_LEFT ) --new;
d493 1
a493 1
	    if ( mp[1] != '\0' ) break;
d495 2
a496 1
#endif
d499 1
a499 1
	    cur.bits = opt_bits = entry_bits;
a503 3
	    int how_many,have_lines;
	    int row;
	    have_lines = (bottom-top);		/* lines available */
d507 2
a508 2
		how_many = fit_menu(&prev,have_lines);
		row = show_menu( &prev, top, bottom, M_ACT_ERASE_ALL );
d511 2
a512 3
	    have_lines = (bottom-top);		/* lines available */
	    how_many = fit_menu(&cur,have_lines);
	    row = show_menu( &cur, top, bottom, M_ACT_REDRAW );
d519 2
a520 2
	    show_menu(&prev, top, bottom, (M_ACT_SELECTED|M_ACT_ERASE));
	    show_menu(&cur, top, bottom, M_ACT_SELECTED);
a528 14
#if !GUN_CNT
U32 DoOptions(
const U8 *menu,
U32 old_opts,
U32 swReset
){
    int bottom = AN_VIS_ROW-3;
    bottom = st_insn(bottom,t_msg_save_ret, t_msg_next, INSTR_PAL);
    bottom = st_insn(bottom,t_msg_restore, t_msg_action, INSTR_PAL);
    return st_optmenu( menu, old_opts, TOP_MARGIN, bottom-1,0);
}
#else
extern int gun_mdriver( U32 original, struct menu_state *cur);

d537 1
a537 1
    return st_optmenu( menu, old_opts, TOP_MARGIN, bottom-1,gun_mdriver);
a538 1
#endif
@


1.7
log
@Protected gun_mdriver code with GUN_CNT
@
text
@d156 1
d169 1
a169 1
	if ( (len + lsb) >= MAX_MENU_ITEMS ) {
@


1.6
log
@near-total re-write to do better error-handling of
user-supplied menus and allow easier retro-fit for
unusual controls, such as the Area51 gun, which prompted
this re-write.
@
text
@d592 1
a592 1
#if (0)
@


1.5
log
@Added "hook" to use menus display code to provide formatted
"decode" of multi-field registers (st_dispmenu()). Also
changed PRIVATE to STATIC
@
text
@d2 8
a9 3
 *		Contains Menu driver stuff for stats.c
 *	Created by splitting out from stats.c
 *	Latest Edit:			11-AUG-1992	Mike Albaugh
d13 1
a13 1
 *	Copyright 1987-1992 ATARI Games Corporation.  Unauthorized reproduction,
d27 49
a75 4
/*		Menu-driven option setting
*	This stuff is used by the coin-option and game-option screens
*	of self-test.
*/
d77 1
d80 6
a85 4
STATIC const U8 * dispopt
PARMS(( const U8 *menu, U32 opt_bits, unsigned int y, U32 color, int erase));
STATIC const U8 * dispmenu
PARMS(( const U8 *menu, U32 opt_bits, int fld, U32 color, int erase));
d92 2
d95 6
a100 2
void st_dispmenu(const U8 *menu, U32 opt_bits, int erase) {
    dispmenu(menu, opt_bits, 0, MNORMAL_PAL, erase);
d103 5
a107 7
#ifdef AN_UP
static const char * const eightSpace = "        ";
#endif

/*
 *   DoOptions() returns 32 bits of OPTIONS set from a menu
 *   .. it returns the original value if swReset is being held
d109 2
a110 7

STATIC const char morestr[] = "+ MORE +";
#define	MORE_LEN	(sizeof(morestr) - 1)
#define TOP_MARGIN (3)
#define BOTTOM_MARGIN (8)
#if (COJAG_GAME&COJAG_AREA51)
extern void gun_joy();
d112 8
d121 1
a121 5
U32
DoOptions(menu, old_opts, swReset)
const U8 *menu;
U32	old_opts;		/* old_opts is original value	*/
U32	swReset;		/* bit mask for switch that RESETs	*/
d123 12
a134 13
    U32 cur_opts;		/* Menu display shows this setting */
    U32 opt_bits;		/* Setting as altered by user input */
    U32 mask;			/* Used to select/alter current field */
    m_uint last,j,pos,field;
#if HAS_LETA
    m_uint hcount,vcount;
#endif
    m_uint oldfield;
    U32 cntrls;
    m_uint base;
    m_int redraw;
    int	maxopt;
    char more[MORE_LEN+1];
d136 105
a240 1
    const U8 *i,*current = menu;
d242 25
a266 1
    strcpy(more,morestr);		/* Load 'em up			*/
d268 7
a274 1
    /* Figure out the screen format and put out the labels */
d276 8
a283 4
    txt_str(-1,AN_VIS_ROW-5,t_msg_extra,INSTR_PAL);
    txt_str(-1,AN_VIS_ROW-4,t_msg_restore,INSTR_PAL);
    txt_str(-1,AN_VIS_ROW-3,t_msg_next,INSTR_PAL);
    txt_str(-1,AN_VIS_ROW-2,t_msg_save_ret,INSTR_PAL);
d285 44
a328 1
    opt_bits = cur_opts = old_opts;	/* starting value from caller */
d330 11
a340 4
    /* Scan for last field */
    maxopt = (AN_VIS_ROW-TOP_MARGIN-BOTTOM_MARGIN)/3;
    for (field = 0 ; findopt(menu,field) ; ++field)
    {}
d342 44
a385 2
    last = field - 1;			/* LAST LEGAL field value	*/
    base = field = 0;			/* .. start at field ZERO	*/
d387 56
a442 18
    /* Write out the initial screen */
    /* base points to a first visible option */

    dispmenu(menu,opt_bits,base,MNORMAL_PAL,0);	/* show the start values */
    (void)dispopt(menu,opt_bits,TOP_MARGIN,MHILITE_PAL,0); /* highlight the first one */

    /* The following line includes stamp numbers to form a down arrow \/  */
    /* For Escape these Alphanumeric codes are 361 & 362 OCTAL (241. & 242.) */

    if ( (last-base) > maxopt)
    {
#ifdef AN_DOWN
	more[0] = AN_DOWN;
	more[MORE_LEN - 1] = AN_DOWN;
	txt_str(9,(maxopt*3+5),more,GRN_PAL);
#else
	txt_str(9,(maxopt*3+5),"MORE Below",GRN_PAL);
#endif
d444 2
a445 5
    ctl_autorepeat(JOY_BITS,30,15);

#if (HAS_LETA)
    vcount = 4;			/* Was 25 & 20 for some reason...	*/
    hcount = 4;			/* Set up initial delays */
d448 33
a480 5
    while (1)
    {
	prc_delay0();
#if (COJAG_GAME&COJAG_AREA51)
	gun_joy();
d482 24
a505 15
	cntrls = ctl_read_sw(JOY_ALL);
	if (cntrls & SW_NEXT)
	    break;				/* exit			*/

	redraw = 0;

	if (cntrls & swReset)			/* Check for edge of	*/
	{
	    opt_bits = old_opts;		/* ..yep, cancel changes   */
	    dispmenu(menu,cur_opts,base,MNORMAL_PAL,1);	/* Erase old one   */
	    field = 0;
#if (HAS_LETA)
	    cntrls = 0;
#endif
	    redraw = 1;
d507 1
a507 43

	cur_opts = opt_bits;		/* Flag setting for later erase	*/

	oldfield = field;

	if ((cntrls & J_DOWN) && field < last)
	    ++field;
	else
	if ((cntrls & J_UP) && field > 0)
	    --field;

	if ((cntrls & (J_UP | J_DOWN)) || redraw)
	{
	    dispmenu(menu,cur_opts,base,MNORMAL_PAL,1);	/* erase old menu */

	    if (base > field)		/* Did we back up??		*/
		base = field;
	    else
	    if ((base + maxopt) < field)
		base = field - maxopt;

	    dispmenu(menu,opt_bits,base,MNORMAL_PAL,0);	/* Write new */

	    current = findopt(menu,field);

#ifdef AN_UP
    /* The following line includes stamp numbers to form an up arrow /\	*/
    /* For Escape these Alphanumeric codes are 357 & 360 OCTAL (239. & 240.) */


	    /* MAYBE we need to detect THESE also in BITMAP???		*/

	    more[0] = AN_UP;
	    more[MORE_LEN - 1] = AN_UP;
	    txt_str(9,TOP_MARGIN-1,(( base != 0 ) ? more : eightSpace),GRN_PAL);

    /* The following line includes stamp numbers to form an down arrow \/	*/
    /* For Escape these Alphanumeric codes are 361 & 362 OCTAL (241. & 242.) */

	    more[0] = AN_DOWN;
	    more[MORE_LEN - 1] = AN_DOWN;
	    txt_str(9,(maxopt*3+5),
		    ((last-base) > maxopt) ? more : eightSpace,GRN_PAL);
d509 46
a554 4
	    if ( base != 0 ) txt_str(9,TOP_MARGIN-1,"MORE Above",GRN_PAL);
	    else txt_clr_str(9,TOP_MARGIN-1,"MORE Above",GRN_PAL);
	    if ((last-base) > maxopt) txt_str(9,maxopt*3+5,"MORE Below",GRN_PAL);
	    else txt_clr_str(9,maxopt*3+5,"MORE Below",GRN_PAL);
d556 4
a559 5

	    j =(m_int)(field-base+1)*3;
	    (void)dispopt(current,opt_bits,j,MHILITE_PAL,0);

	    continue;		/* <<<<<<< WASN'T HERE <<< ???		*/
d561 24
a584 37

	if (ctl_read_sw(0) & JOY_VERT)
	    continue;	/* no horizontal motion if any vertical level	*/

	if((cntrls & (J_LEFT|J_RIGHT)) == 0)
	    continue;

	/* ::::::::: MAYBE we moved RT/LEFT?? :::::::::::		*/

	pos = *current >> 3;
	mask = ((1 << (*current & 7))-1) << pos;

	while (cntrls & (J_LEFT | J_RIGHT))
	{
	    if (cntrls & J_LEFT)
	    {
		if ((opt_bits & mask) == 0)
		    opt_bits |= mask;
		else
		    opt_bits -= (1 << pos);
	    }
	    else
	    if (cntrls & J_RIGHT)
	    {
		opt_bits += 1 << pos;
		if ( (opt_bits & mask) == 0)
		    opt_bits -= (mask + (1 << pos));
	    }
/* If the new value is invalid we stay in the while to skip over it */

	    i = current + 1;			/* Skip over header byte */
	    j = ((opt_bits & mask) >> pos) +1;	/* Get selected field */
	    for ( ; j != 0 ; --j)
		while (*i++)		     /* Skip to text for that value */
		{}
	    if (*i)
		break;			/* Done selecting if valid value */
d586 4
a589 2

/* We wouldn't be here if something hadn't changed, so update the display */
a590 4
	j =(m_int)(field-base+1)*3;
	(void)dispopt(current,cur_opts,j,MNORMAL_PAL,1);
	(void)dispopt(current,opt_bits,j,MHILITE_PAL,0);
							/* Write new one*/
d592 10
a601 3
	cur_opts = opt_bits;		/* Flag setting for later erase	*/
    }
    return(opt_bits);
d603 2
a604 26

/*****************************************************************************
	The following routines were re-ordered and moved to the
	end of the file to avoid a spurious warning from MRI MCC68K
*****************************************************************************/

/*		U8 *dispmenu(menu,opt_bits,field,color,erase)
*	Displays the option select menu with the specified field on the
*    first line, followed by as many of the others as fit on the screen.
*/

const U8 *
dispmenu(menu,opt_bits,field,color,erase)
const U8 *menu;
int field;
U32 opt_bits,color;
int erase;
{
    m_uint y;

    if ( field < 0 ) return 0;

    menu = findopt(menu,field);		/* Skip any fields...		*/

    if (*menu == 0)		/* zero length in header, end of menu	*/
	return 0;			/* No such field for this menu */
d606 9
a614 8
    /* Now write the selected one on the top followed by the rest that fit */

    for ( y = TOP_MARGIN ; y <= (AN_VIS_ROW-BOTTOM_MARGIN) ; y += 3 )
    {
	if ( (menu = dispopt(menu,opt_bits,y,color,erase)) == 0 )
	    break;
    }
    return menu;
d616 1
d682 1
a720 37
#define LMARGIN (4)

STATIC const U8 *
dispopt(menu,p_opt_bits,y,color,erase)
const U8 *menu;
U32 p_opt_bits,color;
unsigned int y;
int erase;
{
    m_uint pos,i,len,seen;
    U32 mask,opt_bits;
    char *text;

    seen = 0;
    while ( !seen ) {
	/* Extract one "field" from the menu and display it. May ignore
	 * fields whose titles start with '?' for "hidden" options.
	 */
	if (*menu == 0)		/* zero length in header, end of menu	*/
	    return(0);

	len = *menu & 7;	/* the bottom 3 bits are the field size	*/
	pos = *menu >> 3;	/* the top 5 bits are the lsb bit #	*/
	mask = (1 << len)-1;	/* form mask for option			*/
	opt_bits = p_opt_bits;	/* fresh copy of parameter option bits	*/
	opt_bits >>= pos;	/* .. strip out unused lower bits	*/
	opt_bits &= mask;	/* .. mask out unused higher bits	*/

	text = (char *) ++menu;	/* .. get the HEADER line	*/
	seen = 1;
	if ( *menu == '?' ) {
	    /* this field should only be available during development
	     * and/or when enabled via "secret handshake"
	     */
	    ++text;
#ifdef DEBUG
	    if ( (debug_mode & GUTS_OPT_DEVEL) == 0 )
a721 40
	    seen = 0;
	}

	/* first skip title and early labels */

	for (i = 0; i <= opt_bits ; ++i) /* Outer loop skips options..	*/
	    while (*menu++)		/* .. inner skips title strings	*/
	    {}

	if ( seen ) {
	    /* erase/write title string */
	    if (erase)
		txt_clr_str(LMARGIN,y,text,color);
	    else
		txt_str(LMARGIN,y,text,color);
	    /* point to selected choice */
	    text = (char *) menu;

	    if ( *text == '*' ) ++text;		/* skip the "FACTORY" flag */

	    if ( erase )
		txt_clr_str(LMARGIN+1,y+1,text,color);
	    else
	    {
		if (text != (char *)menu ) {
		    /* Show the Factory Option */
		    color = GRN_PAL | (color & BGBIT);
		}
		txt_str(LMARGIN+1,y+1,text,color);
	    }
	}
	/* now skip over remaining choices */
	++mask;
	for (i = opt_bits; i < mask ; ++i)
	    while (*menu++)
	    {}					/* Skip late labels */
    }
    return(menu);
}

@


1.4
log
@re-formatted to fit 80-column screen, and to match
Zoid version.
@
text
@d20 1
a20 1
#define	PRIVATE	static
d27 1
a27 1
PRIVATE const U8 * findopt
d29 1
a29 1
PRIVATE const U8 * dispopt
d31 1
a31 1
PRIVATE const U8 * dispmenu
d34 10
d53 1
a53 1
PRIVATE const char morestr[] = "+ MORE +";
d296 1
a296 1
PRIVATE const U8 *
d396 1
a396 1
PRIVATE const U8 *
@


1.3
log
@added COJAG_ to game name AREA51 to prevent symbol collision
@
text
@d296 1
d300 1
a300 1
	if (*menu == 0) break;		/* zero length in header, end of menu	*/
d424 1
d427 2
a428 2
	for (i = 0; i <= opt_bits ; ++i)	/* Outer loop skips options..	*/
	    while (*menu++)			/* .. inner skips title strings	*/
d441 1
d446 4
a449 2
		if (text != (char *)menu )
		    color = GRN_PAL | (color & BGBIT);	/* Show the Factory Option */
@


1.2
log
@included kluge for gun-driven menu selection on Area51
@
text
@d47 1
a47 1
#if (COJAG_GAME&AREA51)
d121 1
a121 1
#if (COJAG_GAME&AREA51)
@


1.1
log
@Initial revision
@
text
@d47 3
d121 3
a123 1

@
