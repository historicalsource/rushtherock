head	1.76;
access;
symbols
	RUSH_ROCK_1_0:1.71
	RUSH_ROCK_1_0epst:1.70
	MACE_1_0e:1.62
	MACE_1_0d:1.62
	RUSH_1_06A:1.62
	AREA_52_00:1.62
	MACE_1_0a:1.62;
locks; strict;
comment	@ * @;


1.76
date	97.12.08.21.18.58;	author shepperd;	state Exp;
branches;
next	1.75;

1.75
date	97.11.27.04.23.56;	author shepperd;	state Exp;
branches;
next	1.74;

1.74
date	97.11.25.21.38.00;	author shepperd;	state Exp;
branches;
next	1.73;

1.73
date	97.11.01.22.48.35;	author shepperd;	state Exp;
branches;
next	1.72;

1.72
date	97.10.30.21.35.50;	author shepperd;	state Exp;
branches;
next	1.71;

1.71
date	97.10.04.20.35.23;	author shepperd;	state Exp;
branches;
next	1.70;

1.70
date	97.09.24.22.49.26;	author shepperd;	state Exp;
branches;
next	1.69;

1.69
date	97.09.24.21.35.14;	author shepperd;	state Exp;
branches;
next	1.68;

1.68
date	97.09.19.22.51.22;	author shepperd;	state Exp;
branches;
next	1.67;

1.67
date	97.09.19.22.31.45;	author shepperd;	state Exp;
branches;
next	1.66;

1.66
date	97.09.04.06.03.15;	author shepperd;	state Exp;
branches;
next	1.65;

1.65
date	97.09.04.01.07.49;	author shepperd;	state Exp;
branches;
next	1.64;

1.64
date	97.08.13.23.09.59;	author shepperd;	state Exp;
branches;
next	1.63;

1.63
date	97.08.07.22.14.41;	author shepperd;	state Exp;
branches;
next	1.62;

1.62
date	97.05.01.03.34.28;	author shepperd;	state Exp;
branches;
next	1.61;

1.61
date	97.04.19.20.46.00;	author shepperd;	state Exp;
branches;
next	1.60;

1.60
date	97.04.19.18.04.00;	author shepperd;	state Exp;
branches;
next	1.59;

1.59
date	97.04.19.04.02.39;	author shepperd;	state Exp;
branches;
next	1.58;

1.58
date	97.04.18.02.47.47;	author shepperd;	state Exp;
branches;
next	1.57;

1.57
date	97.04.18.02.35.22;	author shepperd;	state Exp;
branches;
next	1.56;

1.56
date	97.03.28.20.46.22;	author shepperd;	state Exp;
branches;
next	1.55;

1.55
date	97.03.28.19.14.12;	author shepperd;	state Exp;
branches;
next	1.54;

1.54
date	97.03.28.02.12.09;	author shepperd;	state Exp;
branches;
next	1.53;

1.53
date	97.03.27.04.55.19;	author shepperd;	state Exp;
branches;
next	1.52;

1.52
date	97.03.25.01.21.44;	author shepperd;	state Exp;
branches;
next	1.51;

1.51
date	97.03.04.22.05.33;	author shepperd;	state Exp;
branches;
next	1.50;

1.50
date	97.02.21.23.45.23;	author shepperd;	state Exp;
branches;
next	1.49;

1.49
date	97.02.04.02.50.18;	author shepperd;	state Exp;
branches;
next	1.48;

1.48
date	97.02.01.22.01.24;	author shepperd;	state Exp;
branches;
next	1.47;

1.47
date	97.01.30.04.20.51;	author shepperd;	state Exp;
branches;
next	1.46;

1.46
date	97.01.30.00.48.50;	author shepperd;	state Exp;
branches;
next	1.45;

1.45
date	97.01.29.02.40.16;	author shepperd;	state Exp;
branches;
next	1.44;

1.44
date	97.01.25.03.48.44;	author shepperd;	state Exp;
branches;
next	1.43;

1.43
date	97.01.08.04.48.04;	author shepperd;	state Exp;
branches;
next	1.42;

1.42
date	97.01.08.03.21.06;	author shepperd;	state Exp;
branches;
next	1.41;

1.41
date	97.01.08.03.09.57;	author shepperd;	state Exp;
branches;
next	1.40;

1.40
date	97.01.07.23.06.26;	author shepperd;	state Exp;
branches;
next	1.39;

1.39
date	97.01.03.03.07.55;	author shepperd;	state Exp;
branches;
next	1.38;

1.38
date	97.01.02.23.27.17;	author shepperd;	state Exp;
branches;
next	1.37;

1.37
date	97.01.02.21.05.03;	author shepperd;	state Exp;
branches;
next	1.36;

1.36
date	96.12.21.03.18.52;	author shepperd;	state Exp;
branches;
next	1.35;

1.35
date	96.12.13.23.07.56;	author shepperd;	state Exp;
branches;
next	1.34;

1.34
date	96.12.13.19.03.06;	author shepperd;	state Exp;
branches;
next	1.33;

1.33
date	96.12.13.03.46.50;	author shepperd;	state Exp;
branches;
next	1.32;

1.32
date	96.12.10.23.45.43;	author shepperd;	state Exp;
branches;
next	1.31;

1.31
date	96.12.04.02.38.48;	author shepperd;	state Exp;
branches;
next	1.30;

1.30
date	96.11.23.20.06.08;	author shepperd;	state Exp;
branches;
next	1.29;

1.29
date	96.11.23.19.34.42;	author shepperd;	state Exp;
branches;
next	1.28;

1.28
date	96.11.23.08.20.26;	author shepperd;	state Exp;
branches;
next	1.27;

1.27
date	96.11.22.20.43.40;	author shepperd;	state Exp;
branches;
next	1.26;

1.26
date	96.11.22.01.36.34;	author shepperd;	state Exp;
branches;
next	1.25;

1.25
date	96.11.20.00.18.48;	author shepperd;	state Exp;
branches;
next	1.24;

1.24
date	96.11.19.23.33.03;	author shepperd;	state Exp;
branches;
next	1.23;

1.23
date	96.11.19.18.33.25;	author shepperd;	state Exp;
branches;
next	1.22;

1.22
date	96.11.18.23.15.03;	author shepperd;	state Exp;
branches;
next	1.21;

1.21
date	96.11.16.01.08.14;	author shepperd;	state Exp;
branches;
next	1.20;

1.20
date	96.11.15.04.27.20;	author shepperd;	state Exp;
branches;
next	1.19;

1.19
date	96.11.12.19.12.12;	author shepperd;	state Exp;
branches;
next	1.18;

1.18
date	96.11.12.00.22.12;	author shepperd;	state Exp;
branches;
next	1.17;

1.17
date	96.11.11.19.39.42;	author shepperd;	state Exp;
branches;
next	1.16;

1.16
date	96.11.09.00.42.30;	author shepperd;	state Exp;
branches;
next	1.15;

1.15
date	96.11.06.05.51.55;	author shepperd;	state Exp;
branches;
next	1.14;

1.14
date	96.11.06.05.35.09;	author shepperd;	state Exp;
branches;
next	1.13;

1.13
date	96.11.05.23.45.41;	author shepperd;	state Exp;
branches;
next	1.12;

1.12
date	96.11.05.23.19.26;	author shepperd;	state Exp;
branches;
next	1.11;

1.11
date	96.11.02.23.44.08;	author shepperd;	state Exp;
branches;
next	1.10;

1.10
date	96.11.02.23.26.18;	author shepperd;	state Exp;
branches;
next	1.9;

1.9
date	96.11.02.22.46.08;	author shepperd;	state Exp;
branches;
next	1.8;

1.8
date	96.10.30.05.21.12;	author shepperd;	state Exp;
branches;
next	1.7;

1.7
date	96.10.29.18.24.14;	author shepperd;	state Exp;
branches;
next	1.6;

1.6
date	96.10.26.19.13.20;	author shepperd;	state Exp;
branches;
next	1.5;

1.5
date	96.10.26.17.48.53;	author shepperd;	state Exp;
branches;
next	1.4;

1.4
date	96.10.08.02.02.17;	author shepperd;	state Exp;
branches;
next	1.3;

1.3
date	96.10.07.16.47.54;	author shepperd;	state Exp;
branches;
next	1.2;

1.2
date	96.10.01.20.03.30;	author shepperd;	state Exp;
branches;
next	1.1;

1.1
date	96.10.01.18.12.00;	author shepperd;	state Exp;
branches;
next	;


desc
@First cut at game file system.
@


1.76
log
@Used QIO_FNAME_SEPARATOR instead of hardcoded '/'.
Fixed squawk code. Fixed file allocation problems.
Now uses FSYS_HB_ALG with FSYS_HB_RANGE to find
home blocks. Added two methods of finding home block
before falling back to scanning for them.
@
text
@/*
 * $Id: fsys.c,v 1.75 1997/11/27 04:23:56 shepperd Exp $
 *
 *		Copyright 1996,1997 Atari Games, Corp.
 *	Unauthorized reproduction, adaptation, distribution, performance or 
 *	display of this computer program or the associated audiovisual work
 *	is strictly prohibited.
 */

#include <config.h>
#include <os_proto.h>
#include <st_proto.h>
#include <phx_proto.h>
#define QIO_LOCAL_DEFINES 1
#include <qio.h>
#include <fsys.h>
#include <eer_defs.h>
#include <sys/types.h>
#include <stdio.h>
#include <string.h>
#include <limits.h>
#include <stdlib.h>
#include <fcntl.h>

#ifndef QIO_FIN_SHIM
# define QIO_FIN_SHIM() do { ; } while (0)
#endif

#ifndef TEST_DISK_TIMEOUT
#define TEST_DISK_TIMEOUT	0
#endif

#if defined(WDOG) && !BOOT_FROM_DISK && !NO_WDOG
# define KICK_THE_DOG	1
#else
# define KICK_THE_DOG	0
#endif
#if !defined(FSYS_SQUAWKING_STDIO)
# define FSYS_SQUAWKING_STDIO 1
#endif
#if (FSYS_SQUAWKING || FSYS_FREE_SQUAWKING || FSYS_SYNC_SQUAWKING) && !FSYS_SQUAWKING_STDIO
# include <iio_proto.h>
IcelessIO *fsys_iop;
#endif

#if FSYS_SQUAWKING
# if !FSYS_SQUAWKING_STDIO
#  define FSYS_SQK(x) iio_printf x
#  define OUTWHERE fsys_iop,
# else
#  define FSYS_SQK(x) do { fprintf x; fflush(stdout); } while (0)
#  define OUTWHERE stdout,
# endif
#else
# define FSYS_SQK(x) do { ; } while (0)
#endif

#if FSYS_SYNC_SQUAWKING
# undef OUTWHERE
# if !FSYS_SQUAWKING_STDIO
#  define SYNSQK(x) iio_printf x
#  define OUTWHERE fsys_iop,
# else
#  define SYNSQK(x) do { fprintf x; fflush(stdout); } while (0)
#  define OUTWHERE stdout,
# endif
#else
# define SYNSQK(x) do { ; } while (0)
#endif

/* set TEST_DISK_ERRORS non-zero to enable fake disk errors */
/* set TEST_DISK_TIMEOUT non-zero to enable fake disk timeouts */

#if !HOST_BOARD
#include <time.h>
#include <assert.h>
#endif		/* HOST_BOARD */

typedef struct opnfile_t {
    FsysOpenT *details;	/* point to user's details */
    FsysVolume *vol;	/* volume on which to create file */
    QioIOQ *ioq;	/* completion function, etc. */
    const char *path;	/* pointer to path/filename */
    int mode;		/* mode bits as defined in fcntl.h */
} FsysOpenFileT;

FsysVolume volumes[FSYS_MAX_VOLUMES];
#ifndef FSYS_QIO_BATCH
#define FSYS_QIO_BATCH	16
#endif

static FsysQio *fsysqio_pool_head;

#if MALLOC_DEBUG
static int num_fsysqios;
#endif

#if FSYS_UMOUNT
# if MALLOC_DEBUG
#  define QMOUNT_ALLOC(vol, amt) qmount_alloc(vol, amt, __FILE__, __LINE__)
#  define QMOUNT_REALLOC(vol, old, amt) qmount_realloc(vol, old, amt, __FILE__, __LINE__)
#  define QMOUNT_FREE(vol, head) qmount_free(vol, head, __FILE__, __LINE__)
# else
#  define QMOUNT_ALLOC(vol, amt) qmount_alloc(vol, amt)
#  define QMOUNT_REALLOC(vol, old, amt) qmount_realloc(vol, old, amt)
#  define QMOUNT_FREE(vol, head) qmount_free(vol, head)
# endif
#else
# define QMOUNT_ALLOC(vol, amt) QIOcalloc(1, amt)
# define QMOUNT_REALLOC(vol, old, amt) QIOrealloc(old, amt)
# define QMOUNT_FREE(vol, head) QIOfree(head)
#endif

extern QioIOQ *qio_getioq_ptr(QioIOQ **head, int size);
extern int qio_freeioq_ptr(QioIOQ *q, QioIOQ **head);

#ifdef EER_FSYS_USEALT
static void inc_bram(int arg) {
    int t;
    t = eer_gets(arg)+1;
    if (t < 256) eer_puts(arg, t);
}

#define USED_ALT() inc_bram(EER_FSYS_USEALT);
#else
#define USED_ALT() do { ; } while (0)
#endif

/************************************************************
 * fsys_getqio - Get a FsysQio from the system's pool
 * 
 * At entry:
 *	no requirements
 *
 * At exit:
 *	returns pointer to queue or 0 if none available.
 */
FsysQio *fsys_getqio(void) {
#if MALLOC_DEBUG
    ++num_fsysqios;
#endif
    return (FsysQio *)qio_getioq_ptr((QioIOQ **)&fsysqio_pool_head, sizeof(FsysQio));
}

/************************************************************
 * fsys_freeqio - Free a FsysQio as obtained from a previous
 * call to fsys_getqio().
 * 
 * At entry:
 *	que - pointer to queue element to put back in pool.
 *
 * At exit:
 *	0 if success or 1 if queue didn't belong to pool.
 */
int fsys_freeqio(FsysQio *que) {
#if MALLOC_DEBUG
    --num_fsysqios;
#endif
    return qio_freeioq_ptr((QioIOQ *)que, (QioIOQ **)&fsysqio_pool_head);
}

#if !FSYS_READ_ONLY || FSYS_UPD_FH
/************************************************************
 * fsys_get_volume - get pointer to volume struct
 *
 * At entry:
 *	which - file descriptor of device with volume
 *
 * At exit:
 *	pointer to FsysVolume structure or 0 if error.
 */

static FsysVolume *fsys_get_volume(int which) {
    QioFile *file;
    const QioDevice *dvc;
    FsysVolume *vol;

    file = qio_fd2file(which);
    if (!file) return 0;
    dvc = file->dvc;
    if (!dvc) return 0;
    vol = (FsysVolume *)dvc->private;
    if (!vol || vol->id != FSYS_ID_VOLUME) return 0;
    return vol;
}
#endif

typedef struct fsys_ltop {
    unsigned long phys;			/* physical LBA */
    unsigned long cnt;			/* max number of sectors */
} FsysLtop;

/************************************************************
 * fsys_ltop - convert a logical sector number/count to a starting
 * physical sector number/count pair. This is an internal support
 * function for the file reader.
 *
 * At entry:
 *	ptrs - pointer to array of retrieval pointers
 *	sector - user's logical sector number
 *	count - user's sector count
 * At exit:
 *	returns a struct (_not_ a pointer to struct) containing
 *	the physical sector number and the maximum number of
 *	sectors that can be read or 0 if the logical sector is
 *	out of bounds.
 */

static FsysLtop fsys_ltop(FsysRamRP *ramp, unsigned long sector, int count) {
    FsysLtop ans;
    FsysRetPtr *ptrs;
    unsigned long lba, lbacnt;
    int nptrs;

    ans.phys = 0;		/* assume no conversion is possible */
    ans.cnt = 0;
    lba = 0;			/* look from the beginning */
    while (ramp) {
	ptrs = ramp->rptrs;
	nptrs = ramp->num_rptrs;
	for (;nptrs; --nptrs, ++ptrs) {    
	    unsigned long diff;
#if (FSYS_OPTIONS&FSYS_FEATURES&FSYS_FEATURES_SKIP_REPEAT)
	/* save doing an integer multiply if not required */
	    if (ptrs->repeat == 1 || ptrs->nblock == 1) {
		if (ptrs->repeat == 1) {
		    lbacnt = ptrs->nblocks; 
		} else {
		    lbacnt = ptrs->repeat;
		}
	    } else {
		lbacnt = ptrs->repeat*ptrs->nblocks;
	    }
	    if (!lbacnt) continue;
#else
	    if (!(lbacnt = ptrs->nblocks)) continue;
#endif
	    if (sector >= lba && sector < lba+lbacnt) {
		diff = sector-lba;
#if (FSYS_OPTIONS&FSYS_FEATURES&FSYS_FEATURES_SKIP_REPEAT)
		if (!ptrs->skip) {			/* if no skip field */
		    ans.phys = ptrs->start + diff;	/* then phys is just start + offset */
		    ans.cnt = lbacnt - diff;		/* and count is amount left in ptr block */
		} else {
		    unsigned long t;
		    t = diff/ptrs->nblocks;		/* otherwise, it gets very complicated */
		    t *= ptrs->nblocks+ptrs->skip;
		    ans.phys = ptrs->start + t;
		    t = diff%ptrs->nblocks;
		    ans.phys += t;
		    ans.cnt = ptrs->nblocks-t;
		}
#else
		ans.phys = ptrs->start + diff;
		ans.cnt = lbacnt - diff;
#endif
		if (ans.cnt > count) ans.cnt = count;	/* maximize the count to the caller's value */
		return ans;
	    }
	    lba += lbacnt;	
	}
#if !FSYS_READ_ONLY
	ramp = ramp->next;
#else
	ramp = 0;
#endif
    }
    return ans;
}

/********************************************************************
 * compute_total_free - walks the free list and computes how many free
 * sectors remain on the disk.
 *
 * At entry:
 *	vol - pointer to volume set to which the file belongs
 *
 * At exit:
 *	returns the number of computed free clusters.
 */
static int compute_total_free(FsysVolume *vol) {
    FsysRetPtr *rp;
    FsysRamFH *rfh;
    int ii, tot, prev;

    rp = vol->free;
    prev = 0;
    for (tot=ii=0; rp->start && ii < vol->free_elems; ++ii, ++rp) {
#if 1				/* for compatibility with old filesystems */
	if (rp->start < prev) break;
	prev = rp->start + rp->nblocks;
#endif
#if (FSYS_OPTIONS&FSYS_FEATURES&FSYS_FEATURES_SKIP_REPEAT)
	tot += rp->nblocks*rp->repeat;
#else
	tot += rp->nblocks;
#endif
    }

    rfh = vol->files + FSYS_INDEX_FREE; /* point to freelist header */
    rfh->size = (ii*sizeof(FsysRetPtr)+511)&-512;
    vol->free_ffree = ii;
    return tot;
}

#if !FSYS_READ_ONLY
static int collapse_free(FsysVolume *vol, int low);

#ifndef _FSYS_FINDFREE_T_
# define _FSYS_FINDFREE_T_
typedef struct fsys_findfree_t {
    int request;	/* number of sectors to get */
    int skip;		/* number of blocks to skip */
    int exact;		/* .ne. if size must be exact */
    int lo_limit;	/* allocate above this sector */
    int hint;		/* connect to this sector if possible */
    int actelts;	/* number of active elements in freelist */
    int totelts;	/* total number of elements in freelist */
    FsysRetPtr *freelist; /* ptr to freelist */
    FsysRetPtr *reply;	/* ptr to place to deposit answer */
    int which_elem;	/* gets which freelist elem modified */
} FsysFindFreeT;
#endif

/************************************************************
 * fsys_findfree - find the next free n sectors. This function
 * walks the freelist and tries to find a block of sectors that
 * matches the request'ed amount or an amount nearest. This
 * function is used internally by the filesystem and not expected
 * to be used by the casual user.
 * 
 * At entry:
 *	freet - pointer to FsysFindFreeT struct.
 *	hint - find space starting here if possible (0=don't care)
 *
 * At exit:
 *	returns 0 if success, 1 if nothing available.
 *	updates freelist accordingly.
 */
static int fsys_findfree( FsysFindFreeT *ft ) {
    int ii;
    int nearest_over, nearest_under;
    long diff_over, diff_under;
    FsysRetPtr *fp, *free;

#if (FSYS_OPTIONS&FSYS_FEATURES&FSYS_FEATURES_SKIP_REPEAT)
# error You need to rewrite fsys_findfree and add repeat/skip support.
#endif

    if (!ft) return 0;

    ft->which_elem = INT_MAX;
    fp = ft->freelist;
    free = ft->reply;

    if (!ft->request || !fp || !free) return 0;

#if 1 && FSYS_FREE_SQUAWKING
    {
	int ii;
	FsysRetPtr *dst;
	dst = ft->freelist;
	FSYS_SQK((OUTWHERE "%6d: findfree before. rqst=%d, hint=%d, lo_lim=%d, actelts=%d, totelts=%d.\n",
	    eer_rtc, ft->request, ft->hint, ft->lo_limit, ft->actelts, ft->totelts));
	for (ii=0; ii < ft->actelts; ++ii, ++dst) {
	    FSYS_SQK((OUTWHERE "\t    %3d: start=%7d, nblocks=%7d\n",
		ii, dst->start, dst->nblocks));
	    if (!dst->start && !dst->nblocks) break;
	}
    }
#endif

    nearest_over = nearest_under = -1;
    diff_over = LONG_MAX;
    diff_under = LONG_MIN;
    for (ii=0; ii < ft->actelts; ++ii, ++fp) { /* look through the list for one that fits */
	long d;
	int size;
	size = fp->nblocks;
	if (!size) continue;		/* empty entry */
	if (ft->hint && fp->start == ft->hint) { /* entry abuts the request */
	    nearest_over = ii;		/* give it to 'em */
	    break;
	}
	if (fp->start+fp->nblocks <= ft->lo_limit) continue; /* keep looking */
	if (fp->start < ft->lo_limit) {	/* may need to split a section in two */
	    if (ft->actelts < ft->totelts-1) {	/* if room for another entry */
		d = ft->lo_limit - fp->start; /* compute how much to skip */
		if (ft->request < fp->nblocks-d) { /* if there's enough left over to split */
		    FsysRetPtr *dst;
		    dst = ft->freelist + ft->actelts + 1;
		    memset(dst, 0, sizeof(FsysRetPtr));
		    --dst;
		    for (; dst > fp; --dst) {
			memcpy(dst, dst-1, sizeof(FsysRetPtr));
		    }
		    ++dst;
		    dst->start = fp->start + d;
		    dst->nblocks = fp->nblocks - d;
		    fp->nblocks = d;
		    nearest_over = ii+1;	/* give 'em the new one */
		    ++ft->actelts;		/* tell 'em we changed it */
		    break;
		}
	    }
	}
	d = fp->nblocks - ft->request;
	if (d == 0) {			/* if there's one that exactly fits */
	    nearest_over = ii;
	    break;			/* use it directly */
	}
	if (d > 0) {			/* if the size is over.. */
	    if (fp->start > ft->hint) {
		nearest_over = ii;	/* issue out of the nearest largest space next to hint */
		break;
	    }
	    if (d < diff_over) {	/* ..but difference is closer */
		nearest_over = ii;	/* remember this entry */
		diff_over = d;		/* and the difference */
	    }
	} else {
	    if (d > diff_under) {	/* size of under but difference is closer */
		nearest_under = ii;	/* remember this entry */
		diff_under = d;		/* and the difference */
	    }
	}	    
    }
    if (nearest_over >= 0) {		/* there's a nearest over */
	int act;
	fp = ft->freelist + nearest_over;
	act = fp->nblocks;		/* size of free region */
	if (act > ft->request) act = ft->request; /* maximize to requested amount */
	free->start = fp->start;	/* his region starts at the free start */
	free->nblocks = act;		/* he gets what he asked for or the size of the region */
	fp->nblocks -= act;		/* take from the free region size what we gave away */
	if (fp->nblocks) {		/* if there is any left */
	    fp->start += act;		/* advance the starting point of free region */
	} else {
	    fp->start = 0;		/* gave the whole region away, zap it */
	}
	ft->which_elem = nearest_over;	/* tell 'em which one we modified */
    } else if (!ft->exact && nearest_under >= 0) {
	fp = ft->freelist + nearest_under;
	free->start = fp->start;
	free->nblocks = fp->nblocks;
	fp->start = 0;
	fp->nblocks = 0;
	ft->which_elem = nearest_under;
    } else {
	free->start = 0;
	free->nblocks = 0;
    }
#if 1 && FSYS_FREE_SQUAWKING
    {
	int ii;
	FsysRetPtr *dst;
	dst = ft->freelist;
	FSYS_SQK((OUTWHERE "        after. %d actelts. Patched entry %d\n",
	    ft->actelts, ft->which_elem));
	for (ii=0; ii < ft->actelts; ++ii, ++dst) {
	    FSYS_SQK((OUTWHERE "\t   %c%3d: start=%7d, nblocks=%7d\n",
		ii == ft->which_elem ? '*' : ' ', ii, dst->start, dst->nblocks));
	}
	FSYS_SQK((OUTWHERE "        Returned to caller: start=%d, nblocks=%d\n",
	    free->start, free->nblocks));
    }
#else
    FSYS_SQK(( OUTWHERE "%6d: find_free returns %d. rqst=%d, start=%d, nblocks=%d.\n",
    	eer_rtc, free->start == 0, ft->request, free->start, free->nblocks));
#endif
    return (free->start == 0);
}
        
/********************************************************************
 * extend_file - extends the retrieval pointer set on a file the
 * specified number of sectors.
 *
 * At entry:
 *	vol - pointer to volume set to which the file belongs
 *	fh - pointer to FsysRamFH of file to be extended
 *	rqst - number of sectors to add to the file
 *	rp - pointer to array of ram retrieval pointers
 *	where - area of disk on which to extend file
 *
 * At exit:
 *	returns 0 on success, and one of FSYS_EXTEND_xxx on error.
 *	Retrieval pointer set in the RamFH may have been updated.
 */

static int extend_file(FsysVolume *vol, int rqst, FsysRamRP *rp, int where) {
    int cnt, low;
    FsysRetPtr *arp, ans;
    FsysFindFreeT freet;

/* Check to see if there is room on the disk for the requested
 * extension.
 */
    if (vol->total_free_clusters < rqst) {
	return FSYS_EXTEND_FULL;	/* filesystem is full */
    }

/* Walk through the entire retrieval pointer array and count how many
 * members there are. At the same time, find the last entry in the list.
 */
    cnt = 0;
    while (1) {
	cnt += rp->num_rptrs;
	if (!rp->next) break;
	rp = rp->next;
    }

    freet.skip = 0;
    freet.exact = 0;
    freet.freelist = vol->free;
    freet.actelts = vol->free_ffree;
    freet.totelts = vol->free_elems;
    freet.lo_limit = FSYS_COPY_ALG(where, vol->maxlba);
    low = INT_MAX;

    FSYS_SQK(( OUTWHERE "%6d: extend_file: asked for %d. cnt=%d\n",
    	eer_rtc, rqst, cnt));

/* Keep trying to extend until either the disk fills up, or the request
 * is satisfied.
 */
    while (rqst > 0) {
	if (cnt >= FSYS_MAX_FHPTRS) {
	    return FSYS_EXTEND_2MNYRP;	/* too many retrieval pointers */
	}

	if (rp->num_rptrs > 0) {
	    arp = rp->rptrs + rp->num_rptrs - 1; /* point to last active RP element */
	    freet.hint = arp->start + arp->nblocks; /* try to find a connecting region */
	} else {
	    arp = 0;
	    freet.hint = 0;			/* choose no particular place */
	}
	freet.reply = &ans;
	freet.request = rqst;
	if (fsys_findfree( &freet )) {
	    if (!freet.lo_limit) {
		FSYS_SQK(( OUTWHERE "        No room left on disk.\n"));
		return FSYS_EXTEND_FULL;	/* disk has become full */
	    }
	    FSYS_SQK(( OUTWHERE "        No room in area %ld. Flopping back to 0\n", freet.lo_limit));
	    freet.lo_limit = 0;			/* else try again from begininig */
	    continue;
	}
        vol->free_ffree = freet.actelts;	/* update if appropriate */
	if (arp && ans.start == freet.hint) {	/* did we get an ajoining region? */
	    arp->nblocks += ans.nblocks;	/* just increase the size of the last one */
	} else {
	    arp = 0;
	}
	if (!arp) {
/* Check to see if there is room in the current retrieval pointer array.
 */
	    if (rp->num_rptrs >= rp->rptrs_size) {

/* There isn't, so create another chunk of retrieval pointers.
 */
		if (!cnt) {				/* at the top level, we don't need a RamRP */
#if FSYS_TIGHT_MEM
# define NUM_RET_PTR_TOP	1		/* one retrevial pointer at top level */
# define NUM_RET_PTR_CHAIN	8		/* overflow into 8 */
#else
# define NUM_RET_PTR_TOP	1		/* one retrevial pointer at top level */
# define NUM_RET_PTR_CHAIN	8		/* overflow into 8 */
#endif
		    FSYS_SQK(( OUTWHERE "        extending top level rptrs by %d\n", NUM_RET_PTR_TOP));
		    rp->rptrs = (FsysRetPtr *)QIOcalloc(NUM_RET_PTR_TOP*sizeof(FsysRetPtr),1);
		    if (!rp->rptrs) return FSYS_EXTEND_NOMEM;
		    rp->rptrs_size = NUM_RET_PTR_TOP;	/* this is how many are in there */
		    rp->mallocd = 1;		/* show rptrs is mallocd */
		} else {
		    FsysRamRP *trp;
		    FSYS_SQK(( OUTWHERE "       extending rptrs chain by %d\n", NUM_RET_PTR_CHAIN));
		    trp = (FsysRamRP *)QIOcalloc(sizeof(FsysRamRP)+NUM_RET_PTR_CHAIN*sizeof(FsysRetPtr),1);
		    if (!trp) {
			return FSYS_EXTEND_NOMEM;	/* oops, ran out of memory */
		    }
		    rp->next = trp;
		    rp = trp;			/* tell last guy about new one */
		    rp->rptrs = (FsysRetPtr *)(trp+1); /* point to an array of FsysRetPtr's */
		    rp->rptrs_size = NUM_RET_PTR_CHAIN; /* this is how many are in there */
		    rp->mallocd = 0;		/* not individually mallocd */
		}
		rp->next = 0;			/* new guy is last on the list */
		rp->num_rptrs = 0;		/* no pointers yet. */
	    }
	    arp = rp->rptrs + rp->num_rptrs;	/* point to RP element */
	    *arp = ans;				/* give 'em the new allocation */
	    ++rp->num_rptrs;			/* count the RP */
	    ++cnt;				/* count the RP */
	}
	rqst -= ans.nblocks;			/* take the amount we obtained from request */
	vol->total_free_clusters -= ans.nblocks; /* take from volume total */
	vol->total_alloc_clusters += ans.nblocks; /* count allocated clusters */
	if (low > freet.which_elem) low = freet.which_elem;
    }
/*
 * Successfully extended the file(s) 
 */
    return collapse_free(vol, INT_MAX);		/* adjust the freelist */
}
#endif

/************************************************************
 * fsys_qread - a file read primitive. This function will read
 * n sectors from a file as specified by the list of retrieval
 * pointers, the starting relative sector number and the sector
 * count. It queue's a read to the I/O subsystem and uses itself
 * as a completion function. It will continue to queue input until
 * the required bytes have been transferred or an error occurs.
 * The I/O subsystem will call this function as a completion
 * routine therefore it will (may) finish asychronously from the
 * calling program. This function is used internally by the
 * filesystem and not expected to be used by the casual user.
 * 
 * At entry:
 *	arg - pointer to read argument list. The list must be in
 *		static memory (i.e., not on the stack)
 * At exit:
 *	returns nothing. The function queue's an input which will
 *	complete asynchronously from the calling program.
 */

static void fsys_qread(QioIOQ *ioq) {
    FsysQio *arg;

    arg = (FsysQio *)ioq;
    while (1) {
	switch (arg->state) {
	    default:
		ioq->iostatus = FSYS_IO_FATAL;	/* fatal internal error */
		break;

	    case 0:
		ioq->complete = fsys_qread;
		if (arg->callers_ioq) {
		    ioq->timeout = arg->callers_ioq->timeout;
#if FSYS_DEFAULT_TIMEOUT
		    if (!ioq->timeout) ioq->timeout = FSYS_DEFAULT_TIMEOUT;
#endif
		}
		arg->total = 0;			/* no bytes xferred */
		if (!arg->u_len) break;		/* a 0 length read simply exits */
		arg->state = 1;
		continue;

	    case 1: {
		FsysLtop ltop;
		int len;
		ltop = fsys_ltop(arg->ramrp, arg->sector, (arg->u_len+511)/512);
		if (!ltop.phys) {
		    if (!ioq->iocount) ioq->iostatus = QIO_EOF;
		    break;
		}
		arg->state = 2;
		arg->count = ltop.cnt;
		len = arg->count*512;
		if (len > arg->u_len) len = arg->u_len;
		if ((len&511) && (len&-512)) len = (len&-512);	/* get multiple of sectors first */
		qio_readwpos(ioq, ltop.phys, arg->buff, len);
		return;
	    }

	    case 2: {
		int t;
		if (!QIO_ERR_CODE(ioq->iostatus)) {
		    t = ioq->iocount;	    
		    arg->total += t;
		    arg->u_len -= t;
		    arg->buff += t;			/* bump buffer by byte count */
		    t = (t+511)/512;			/* round up to sector size */
		    arg->sector += t;			/* advance logical sector number */
		    if (arg->u_len <= 0) break;
		    arg->state = 1;
		    continue;
		}
		break;
	    }
	}
	break;
    }
    arg->state = 0;				/* clean up after ourselves */
    ioq->iocount = arg->total;
    ioq->complete = arg->compl;			/* restore completion rtn address */
    qio_complete(ioq);				/* call completion */
    return;
}

#if !FSYS_READ_ONLY
static int wr_ext_file(FsysQio *arg, QioFile *fp, FsysVolume *v) {
    int ii, jj, fid, def;
    QioIOQ *ioq;
    FsysRamFH *rfh;
    FsysRamRP *rp;

    ioq = (QioIOQ *)arg;
    if (v && fp && fp->dvc) {
	fid = (int)fp->private;
	rfh = v->files + (fid&0x00FFFFFF);
	def = arg->sector - rfh->clusters;
	if (def < 0) def = 0;
	def += rfh->def_extend ? rfh->def_extend : FSYS_DEFAULT_EXTEND;
	if (def*FSYS_MAX_ALTS >= v->total_free_clusters) {	/* maybe there's no room */
	    for (ii=jj=0; ii < FSYS_MAX_ALTS; ++ii) {	/* compute how many copies */
		rp = rfh->ramrp + ii;
		if (rp->num_rptrs) ++jj;
	    }
	    if (def*jj >= v->total_free_clusters) {	/* check again for room */
		ioq->iostatus = FSYS_EXTEND_FULL;	/* no room for extension */
		FSYS_SQK((OUTWHERE "wr_ext_file: error 1 extending. def=%d, jj=%d, total_free=%d\n",
		    def, jj, v->total_free_clusters));
		return 1;
	    }
	}
	for (jj=0; jj < FSYS_MAX_ALTS; ++jj) {
	    rp = rfh->ramrp + jj;
	    if (!rp->num_rptrs) continue;		/* no copy here */
	    ii = extend_file(v, def, rp, jj);
	    if (ii) {
		ioq->iostatus = ii;
		break;				/* ran out of room */
	    }
	}
	rfh->clusters += def;			/* add to total allocation */
	if (QIO_ERR_CODE(ioq->iostatus)) {
#if FSYS_SQUAWKING
	    char emsg[132];
	    qio_errmsg(ioq->iostatus, emsg, sizeof(emsg));
	    FSYS_SQK((OUTWHERE "wr_ext_file: error 1 extending. def=%d, jj=%d, total_free=%d. sts:\n%s\n",
		def, jj, v->total_free_clusters, emsg));
#endif
	    return 1;
	}
	return 0;				/* recompute retrieval pointer set */
    } 
    FSYS_SQK((OUTWHERE "wr_ext_file: error 2 extending. v=%08lX, fp=%08lX, fp->dvc=%08lX\n",
	v, fp, fp ? fp->dvc : 0));
    return 2;
}
#endif

/************************************************************
 * fsys_qwrite - a file write primitive. This function will write
 * n sectors to a file as specified by the list of retrieval
 * pointers, the starting relative sector number and the sector
 * count. It queue's a write to the I/O subsystem and uses itself
 * as a completion function. It will continue to queue output until
 * the required bytes have been transferred or an error occurs.
 * The I/O subsystem will call this function as a completion
 * routine therefore it will (may) finish asychronously from the
 * calling program. This function is used internally by the
 * filesystem and not expected to be used by the casual user.
 * 
 * At entry:
 *	arg - pointer to write argument list. The list must be in
 *		static memory (i.e., not on the stack)
 * At exit:
 *	returns nothing. The function queue's an input which will
 *	complete asynchronously from the calling program.
 */

static void fsys_qwrite(QioIOQ *ioq) {
    FsysQio *arg;

    arg = (FsysQio *)ioq;
    FSYS_SQK((OUTWHERE "fsys_qwrite: sect=%ld, u_buff=%08lX, u_len=%ld, state=%d\n",
    	arg->sector, arg->buff, arg->u_len, arg->state));
    while (1) {
	switch (arg->state) {
	    default:
		ioq->iostatus = FSYS_IO_FATAL;	/* fatal internal error */
		break;

	    case 0:
		ioq->complete = fsys_qwrite;
		if (!arg->u_len) break;		/* a 0 length write simply exits */
		if (arg->callers_ioq) {
		    ioq->timeout = arg->callers_ioq->timeout;
#if FSYS_DEFAULT_TIMEOUT
		    if (!ioq->timeout) ioq->timeout = FSYS_DEFAULT_TIMEOUT;
#endif
		}
		arg->state = 1;
		continue;

	    case 1: {
		FsysLtop ltop;
		int len;

		ltop = fsys_ltop(arg->ramrp, arg->sector, (arg->u_len+511)/512);
		if (!ltop.cnt) {
#if !FSYS_READ_ONLY
		    int sts;
		    FsysVolume *v;
		    QioFile *fp;
		    fp = arg->fsys_fp;
		    if (fp && fp->dvc && fp->dvc->private) {
			v = (FsysVolume *)fp->dvc->private;
			arg->state = 3;
			sts = qio_getmutex(&v->mutex, fsys_qwrite, ioq);
			if (!sts) return;
			if (sts == QIO_MUTEX_NESTED) {
			    FSYS_SQK(( OUTWHERE "%6d: fsys_qwrite, extending. Volumue already locked\n",
				eer_rtc));
			    arg->state = 1;
			    sts = wr_ext_file(arg, fp, v);
			    if (sts == 0) continue;	/* recompute lsn */
			    if (sts == 1) break;
			} else {
			    ioq->iostatus = sts;
			    break;
			}
		    } 
#endif
		    ioq->iostatus = QIO_EOF; /* always return an EOF if tried to write too much */
		    break;
		}
		arg->state = 2;
		arg->count = ltop.cnt;
		len = arg->count*512;
		if (len > arg->u_len) len = arg->u_len;
		if ((len&511) && (len&-512)) len = (len&-512);
		FSYS_SQK((OUTWHERE "Queing write. LBA=%ld, buff=%08lX, len=%ld\n", ltop.phys, arg->buff, len));
		qio_writewpos(ioq, ltop.phys, arg->buff, len);
		return;
	    }

	    case 2: {
		int t;
		if (QIO_ERR_CODE(ioq->iostatus) == 0) {
		    t = ioq->iocount;	    
		    arg->total += t;
		    arg->u_len -= t;
		    arg->buff += t;			/* advance buffer pointer by 'word' count */
		    arg->sector += (t+511)/512;		/* advance logical sector number */
		    if (arg->u_len <= 0) break;
		    arg->state = 1;
		    continue;
		}
		break;
	    }

#if !FSYS_READ_ONLY
	    case 3: {
		int sts;
		FsysVolume *v;
		QioFile *fp;
		fp = arg->fsys_fp;
		v = (FsysVolume *)fp->dvc->private;
		arg->state = 1;				
		sts = wr_ext_file(arg, fp, v);
		qio_freemutex(&v->mutex, ioq);		/* free the volume */
		if (sts == 0) continue;			/* recompute lsn */
		if (sts == 1) break;			/* die */
		ioq->iostatus = QIO_EOF; /* always return an EOF if tried to write too much */
		break;
	    }
#endif
	}
	break;
    }
#if FSYS_SQUAWKING
    {
	char emsg[132];
	qio_errmsg(ioq->iostatus, emsg, sizeof(emsg));
	FSYS_SQK((OUTWHERE "fsys_qwrite: done. buff=%08lX, tot=%ld, u_len=%ld, status:\n\t%s\n",
	    arg->buff, arg->total, arg->u_len, emsg));
    }
#endif
    arg->state = 0;		/* clean up after ourselves */
    ioq->complete = arg->compl;
    qio_complete(ioq);
    return;
}

#if MALLOC_DEBUG
# define ALLOC_EXTRAS ,const char *file, int lineno
# define QM_ALLOC_CALLOC(x,y) guts_calloc_r( (void *)qio_reent, x, y, file, lineno)
# define QM_ALLOC_REALLOC(x,y) guts_realloc_r( (void *)qio_reent, x, y, file, lineno)
# define QM_ALLOC_FREE(x) guts_free_r((void *)qio_reent, x, file, lineno)
#else
# define ALLOC_EXTRAS 
# define QM_ALLOC_CALLOC(x,y) QIOcalloc(x,y)
# define QM_ALLOC_REALLOC(x,y) QIOrealloc(x,y)
# define QM_ALLOC_FREE(x) QIOfree(x)
#endif

#if FSYS_UMOUNT
static void qmount_free(FsysVolume *vol, void *old ALLOC_EXTRAS ) {
    int ii;
    for (ii=0; ii < vol->freem_indx; ++ii) {
	if (vol->freemem[ii] == old) {
	    QM_ALLOC_FREE(old);
	    vol->freemem[ii] = 0;
	    break;
	}
    }
    return;
}

static void *qmount_alloc(FsysVolume *vol, int amt ALLOC_EXTRAS ) {
    void *ans, *nmem;
    ans = QM_ALLOC_CALLOC(amt, 1);
    if (!ans) {
	return ans;
    }
    if (vol->freem_indx >= vol->freem_elems) {
	vol->freem_elems += 10;
	nmem = QIOrealloc(vol->freemem, vol->freem_elems*sizeof(void *));
	if (!nmem) {
	    QIOfree(ans);
	    return 0;
	}
	vol->freemem = nmem;
    }
    vol->freemem[vol->freem_indx++] = ans;
    return ans;
}

static void *qmount_realloc(FsysVolume *vol, void *old, int amt ALLOC_EXTRAS ) {
    void *ans;
    int ii;
    ans = QM_ALLOC_REALLOC(old, amt);
    for (ii=0; ii < vol->freem_indx; ++ii) {
	if (vol->freemem[ii] == old) {
	    vol->freemem[ii] = ans;
	    break;
	}
    }
    if (ans && ii >= vol->freem_indx) {
	if (vol->freem_indx >= vol->freem_elems) {
	    vol->freem_elems += 20;
	    vol->freemem = QIOrealloc(vol->freemem, vol->freem_elems*sizeof(void *));
	    if (!vol->freemem) {
		QIOfree(ans);
		return 0;
	    }
	}
	vol->freemem[vol->freem_indx++] = ans;
    }
    return ans;
}
#endif

#if 0
static volatile int fatal_dir_error;

static void bump_fatal(int arg) {
    ++fatal_dir_error;
    return;
}

static void check_dirs(void) {
    FsysDirEnt *de;
    FsysRamFH *rfh;

    rfh = volumes[0].files;
    if (!rfh) return;			/* volume not mounted yet */
    rfh += 2;				/* advance to root directory */
    if (!rfh->directory) {
	bump_fatal(0);
	return;
    }
    de = rfh->directory[15];		/* point to directory '.' */
    if (!de) {
	bump_fatal(1);
	return;
    }
    if (!de->name || !de->gen_fid ) {
	bump_fatal(2);
	return;
    }
    de = rfh->directory[25];		/* point to directory '.' */
    if (!de) {
	bump_fatal(3);
	return;
    }
    if (!de->name || !de->gen_fid ) {
	bump_fatal(4);
	return;
    }
    return;
}
#endif

#if FSYS_UMOUNT
static void qmount_freeall(FsysVolume *vol) {
    int ii;
    for (ii=0; ii < vol->freem_indx; ++ii) {
	if (vol->freemem[ii]) {
	    QIOfree(vol->freemem[ii]);
	    vol->freemem[ii] = 0;
	}
    }
    if (vol->freemem) {
	QIOfree(vol->freemem);
	vol->freemem = 0;
    }
    vol->freem_indx = vol->freem_elems = 0;
    return;
}
#endif

static int hashit(const char *string) {
   int hashv=0;
   unsigned char c;
   while ((c= *string++)) {
      hashv = (hashv<<3) + (hashv<<1) + hashv + c;	/* hashv = hashv*11 + c */
   }
   return (hashv %= FSYS_DIR_HASH_SIZE) >= 0 ? hashv : -hashv;
}

static void insert_ent(FsysDirEnt **hash, FsysDirEnt *new) { /* insert into hash table */
    int hashv;
    FsysDirEnt *cur, **prev;

#if 0
    if (!new->name || !new->gen_fid) {
	bump_fatal(10);
	return;
    }
#endif
    hashv = hashit(new->name);		/* compute a hash value */
    prev = hash + hashv;		/* record insertion point */
    while ((cur = *prev)) {		/* walk the chain */
	if (strcmp(cur->name, new->name) > 0) break;
	prev = &cur->next;
    }
    *prev = new;			/* old guy points to new one */
    new->next = cur;			/* new one points to next guy */
    return;				/* and that is all there is to it */
}

static FsysDirEnt *find_ent(FsysDirEnt **hash, const char *name) { /* remove from hash table */
    int hashv;
    FsysDirEnt *cur, **prev;

    hashv = hashit(name);		/* compute a hash value */
    prev = hash + hashv;		/* record insertion point */
    while ((cur = *prev)) {		/* walk the chain */
	if (strcmp(cur->name, name) == 0) return cur;	/* found it, give it to 'em */
	prev = &cur->next;
    }
    return 0;				/* not in the list */
}

#if !FSYS_READ_ONLY
static FsysDirEnt *remove_ent(FsysDirEnt **hash, const char *name) { /* remove from hash table */
    int hashv;
    FsysDirEnt *cur, **prev;

    hashv = hashit(name);		/* compute a hash value */
    prev = hash + hashv;		/* record insertion point */
    while ((cur = *prev)) {		/* walk the chain */
	if (strcmp(cur->name, name) == 0) {
	    *prev = cur->next;		/* pluck this from the list */
	    cur->next = 0;		/* break the link */
	    return cur;
	}
	prev = &cur->next;
    }
    return 0;				/* not in the list */
}
#endif

static int lookup_filename(FsysLookUpFileT *lu) {
    char name[256];				/* room for temp copy of path */
    const char *fname, *path;
    FsysDirEnt *dir;
    FsysRamFH *top;
    int len, fid;

    if (!lu || !lu->vol || !lu->path) {
	return FSYS_LOOKUP_INVARG;		/* it can't be there */
    }
    lu->owner = 0;				/* assume no owner directory */
    lu->file = 0;				/* assume no file either */
    top = lu->top ? lu->top : lu->vol->files + FSYS_INDEX_ROOT;
    fname = lu->path;
    if (*fname == QIO_FNAME_SEPARATOR) ++fname; /* eat leading '/' */
    lu->depth = 0;
    while ((path=strchr(fname, QIO_FNAME_SEPARATOR))) { /* see if we have to traverse a directory */
	if (!top->directory) {
	    return FSYS_LOOKUP_NOPATH;		/* not a directory, so file not found */
	}
	len = path - fname;
	strncpy(name, fname, len);
	name[len] = 0;
	dir = find_ent(top->directory, name);	/* find the directory entry */
	if (!dir || !(fid=(dir->gen_fid&FSYS_DIR_FIDMASK))) {
	    return FSYS_LOOKUP_NOPATH;		/* directory not found */
	}
	top = lu->vol->files + fid;		/* get pointer to new top */
	if (top->generation != (dir->gen_fid>>FSYS_DIR_GENSHF)) {
	    return FSYS_LOOKUP_NOPATH;
	}
	fname = path + 1;			/* skip to next filename part */
	if (++lu->depth > 31) {
	    return FSYS_LOOKUP_TOODEEP;
	}
    }
    if (!top->directory) {
	return FSYS_LOOKUP_NOPATH;		/* not looking in a directory */
    }
    lu->owner = top;				/* pass back pointer to found directory */
    lu->fname = fname;				/* record name of file we looked for */
    dir = find_ent(top->directory, fname);	/* look up the filename */
    lu->dir = dir;				/* record pointer to directory entry */
    if (dir && (fid=(dir->gen_fid&FSYS_DIR_FIDMASK))) {
	lu->file = lu->vol->files + fid;	/* pass back the file */ 
	if (lu->file->generation == (dir->gen_fid>>FSYS_DIR_GENSHF)) {
	    return FSYS_LOOKUP_SUCC|SEVERITY_INFO; /* it worked */
	}
    }
    return FSYS_LOOKUP_FNF;			/* file not found */
}

#if !FSYS_READ_ONLY
static int add_to_unused(FsysVolume *vol, int fid) {
    int ii;
    unsigned long *ulp;

    ulp = vol->unused;
    for (ii=0; ii < vol->unused_ffree; ++ii) {
	if (fid == *ulp++) return 0;		/* already in the unused list */
    }
    if (vol->unused_ffree >= vol->unused_elems) {
	vol->unused_elems += 32;		/* room for 32 updates */
	ulp = (U32*)QMOUNT_REALLOC(vol, vol->unused, vol->unused_elems*sizeof(long));
	if (!ulp) {
	    return FSYS_CREATE_NOMEM;
	}
	vol->unused = ulp;
    }
    vol->unused[vol->unused_ffree++] = fid;
    return 0;
}
#endif

#if !FSYS_READ_ONLY || FSYS_UPD_FH
static int fsys_sync(FsysSyncT *f, int how);
static int fatal_dirty_error;

static int add_to_dirty(FsysVolume *vol, int fid, int end) {
    int ii;
    unsigned long *ulp;

    FSYS_SQK(( OUTWHERE "%6d: Adding fid %08lX to dirty list\n", eer_rtc, fid));
    if (fid < 0 || fid >= vol->files_ffree) {
	FSYS_SQK(( OUTWHERE "%6d: add_to_dirty Rejected fid %08lX. files_ffree=%d\n",
    			eer_rtc, fid, vol->files_ffree));
	++fatal_dirty_error;
	return 0;
    }
    if (!end) {
	ulp = vol->dirty;
	for (ii=0; ii < vol->dirty_ffree; ++ii) {
	    if (fid == *ulp++) {
		FSYS_SQK(( OUTWHERE "%6d: add_to_dirty rejected fid %08lX cuz it's already there\n",
				eer_rtc, fid));
		return 0;		/* already in the dirty list */
	    }
	}
    }
    if (vol->dirty_ffree >= vol->dirty_elems) {
	int new;
	new = vol->dirty_elems + 32;
	ulp = (U32*)QMOUNT_REALLOC(vol, vol->dirty, new*sizeof(long));
	if (!ulp) {
	    return FSYS_CREATE_NOMEM;
	}
	vol->dirty = ulp;
	memset((char *)(vol->dirty+vol->dirty_elems), 0, 32*sizeof(long));
	vol->dirty_elems = new;			/* room for 32 updates */
	FSYS_SQK(( OUTWHERE "%6d: Increased size of dirty area\n", eer_rtc));
    }
    FSYS_SQK(( OUTWHERE "%6d: fid %08lx at dirty index %d\n", eer_rtc, fid, vol->dirty_ffree));
    vol->dirty[vol->dirty_ffree++] = fid;
    if (vol->dirty_ffree >= 16) {		/* Getting full, don't wait for timeout */
	FSYS_SQK(( OUTWHERE "%6d: kick started sync task\n", eer_rtc));
	fsys_sync(&vol->sync_work, FSYS_SYNC_BUSY_NONTIMER); /* startup a sync task */
    }
    return 0;
}
#endif

#if !FSYS_READ_ONLY
static int mkroom_free(FsysVolume *vol) {
    FsysRamFH *rfh;
    int ii, size, sts;
    FsysRetPtr *ulp;

    if (vol->free_ffree < vol->free_elems) return 0;	/* there's room */
#if FSYS_FREE_SQUAWKING || FSYS_SQUAWKING
    FSYS_SQK((OUTWHERE "%6d: Increasing size of free list. free_ffree=%d, free_elems = %d\n",
		eer_rtc, vol->free_ffree, vol->free_elems));
#endif
    rfh = vol->files + FSYS_INDEX_FREE;		/* point to freelist file */
    vol->free_elems += 512/sizeof(FsysRetPtr);	/* add another sector's worth of elements */
    size = (vol->free_elems*sizeof(FsysRetPtr)+511)&-512;	/* multiple of sector size */
    ulp = (FsysRetPtr *)QMOUNT_REALLOC(vol, vol->free, size);
    if (!ulp) return FSYS_EXTEND_NOMEM;		/* ran out of memory */
    vol->free = ulp;
    size /= 512;				/* get size in sectors */
    if (size > rfh->clusters) {			/* need to add some more sectors */
#if FSYS_FREE_SQUAWKING || FSYS_SQUAWKING
	FSYS_SQK(( OUTWHERE "%6d: Increasing size of free list file. size=%d, clust=%d\n",
		    eer_rtc, size, rfh->clusters));
#endif
	rfh->clusters += 10;			/* add 10 more sectors */    
	for (ii=0; ii < FSYS_MAX_ALTS; ++ii) {	/* need to extend the freelist file */
	    sts = extend_file(vol, 10, rfh->ramrp + ii, ii);
	    if (sts) return sts;			/* couldn't extend file */
	}
    }
    add_to_dirty(vol, FSYS_INDEX_FREE, 0);	/* make sure the freelist gets updated */
    return 0;
}
	    		
static int upd_index_bits(FsysVolume *vol, int fid) {
    int lw, le, bits;
    U32 *ulp;

    bits = ((vol->files_ffree+1)*FSYS_MAX_ALTS*sizeof(long)+511)/512; /* number of sectors required to hold index file */
    bits = (bits+31)/32;			/* number of longs rqd to hold bit map */
    FSYS_SQK(( OUTWHERE "%6d: upd_index_bits: fid=%08lX, Bits=%d, elems=%d\n",
		eer_rtc, fid, bits, vol->index_bits_elems));
    if (bits >= vol->index_bits_elems) {
	int newsize, len;
	newsize = vol->index_bits_elems + bits + 8;
	FSYS_SQK(( OUTWHERE "%6d: upd_index_bits: Increasing size. newsize=%d\n", eer_rtc, newsize));
	ulp = (U32*)QMOUNT_REALLOC(vol, vol->index_bits, newsize*sizeof(long));
	if (!ulp) {
	    return FSYS_FREE_NOMEM;
	}
	len = newsize - vol->index_bits_elems; /* size of additional area */
	memset((char *)(ulp + vol->index_bits_elems), 0, len*sizeof(U32));
	vol->index_bits = ulp;
	vol->index_bits_elems = newsize;
    }
    lw = fid*FSYS_MAX_ALTS*sizeof(long); /* byte position in index file of first byte */
    le = lw + FSYS_MAX_ALTS*sizeof(long)-1; /* byte position of last byte in array */
    lw /= 512;				/* sector position in index file of first byte */
    fid = lw&31;			/* bit position in bitmap element of first byte */
    lw /= 32;				/* longword element in bitmap of first byte */
    FSYS_SQK(( OUTWHERE "%6d: upd_index_bits: lw=%d, new=%08lX, old=%08lX\n",
		eer_rtc, lw, 1<<fid, vol->index_bits[lw]));
    vol->index_bits[lw] |= 1<<fid;	/* set bit in bitmap */
    le /= 512;				/* sector position in index file of last byte */
    fid = le&31;			/* bit position in bitmap element of last byte */
    le /= 32;				/* longword element in bitmap of last byte */
    vol->index_bits[le] |= 1<<fid;	/* set bit in bitmap of last byte */
    return 0;
}

static int collapse_free(FsysVolume *vol, int low) {	/* squeeze all the empty space out of free list */
    FsysRetPtr *dst, *src, *lim;
#if FSYS_SQUAWKING
    int old_start = vol->free_start, old_ffree=vol->free_ffree;
#endif

#if 0 && FSYS_FREE_SQUAWKING
    {
	int ii;
	dst = vol->free;
	iio_printf(fsys_iop, "%6d: collapse_free before. %d items\n", eer_rtc, vol->free_ffree);
	for (ii=0; ii < vol->free_ffree; ++ii, ++dst) {
	    iio_printf(fsys_iop, "\t   %3d: start=%7d, nblocks=%7d\n",
		ii, dst->start, dst->nblocks);
	}
    }
#endif
    dst = vol->free;
    src = dst+1;			/* point to free list */
    lim = dst + vol->free_ffree;	/* point to end of list */
    while (src < lim) {			/* walk the whole list */
	unsigned long s, ss, e, ds, de;
	s = src->start;
	ss = src->nblocks;
	e = s + ss;
	ds = dst->start;
	de = ds + dst->nblocks;
	if (ss) {			/* the source has to have a size */
	    if (!de) {			/* if the destination has no size */
		*dst = *src;		/* just copy the source to it */
	    } else {
		if (s <= de) {		/* if the regions touch or overlap */
		    dst->nblocks += ss - (de - s);
		    src->start = src->nblocks = 0;
		    if (dst - vol->free < low) low = dst - vol->free;
		} else {
		    ++dst;			/* advance destination */
		    if (dst != src) *dst = *src; /* copy source if in different locations */
		}
	    }
	}
	++src;				/* advance the source */
    }
    ++dst;
    vol->free_ffree = dst - vol->free; /* compute new length */
    if (dst - vol->free < vol->free_elems) {
	dst->start = dst->nblocks = 0;	/* follow with a null entry if there's room */
    }
    if (low < vol->free_start) vol->free_start = low;
#if FSYS_SQUAWKING
    if (old_start != vol->free_start || old_ffree != vol->free_ffree) {
	FSYS_SQK(( OUTWHERE "%6d: collapse_free entry: start=%d, ffree=%d; exit: start=%d, ffree=%d\n",
	    eer_rtc, old_start, old_ffree, vol->free_start, vol->free_ffree));
    } else {
	FSYS_SQK(( OUTWHERE "%6d: collapse_free, start=%d, ffree=%d. No changes.\n",
	    eer_rtc, vol->free_start, vol->free_ffree));
    }
#endif
#if 0 && FSYS_FREE_SQUAWKING
    {
	int ii;
	dst = vol->free;
	iio_printf(fsys_iop, "        after. %d items\n", vol->free_ffree);
	for (ii=0; ii < vol->free_ffree; ++ii, ++dst) {
	    iio_printf(fsys_iop, "\t   %3d: start=%7d, nblocks=%7d\n",
		ii, dst->start, dst->nblocks);
	}
    }
#endif
    return 0;
}

static int back_to_free(FsysVolume *vol, FsysRetPtr *rp) {
#if (FSYS_OPTIONS&FSYS_FEATURES&FSYS_FEATURES_SKIP_REPEAT)
# error You need to re-write back_to_free to use the skip repeat feature
#else
    int ii, sts, amt, reuse;
    int old_start, old_end, new_start, new_end;
    FsysRetPtr *vrp;
    
    vrp = vol->free;
    new_start = rp->start;
    new_end = rp->start + rp->nblocks;
#if 0 && FSYS_FREE_SQUAWKING
    {
	int ii;
	FsysRetPtr *dst;
	dst = vol->free;
	iio_printf(fsys_iop, "%6d: back_to_free before. %d items. Adding start=%d, nblocks=%d\n",
    		eer_rtc, vol->free_ffree, new_start, rp->nblocks);
	for (ii=0; ii < vol->free_ffree; ++ii, ++dst) {
	    iio_printf(fsys_iop, "\t   %3d: start=%7d, nblocks=%7d\n",
		ii, dst->start, dst->nblocks);
	}
    }
#endif
    for (amt=ii=0; ii < vol->free_ffree; ++ii, ++vrp) {
	old_start = vrp->start;
	old_end = vrp->start + vrp->nblocks;
	if (new_start > old_end) continue;	/* insertions are maintained in a sorted list */
	if (new_end < old_start) break;		/* need to insert a new entry */
	sts = ((new_start == old_end)<<1) | (new_end == old_start);
	if (sts) {
	    amt = rp->nblocks;
	    vrp->nblocks += amt;
	    if ((sts&1)) vrp->start = new_start;
	    vol->total_free_clusters += amt;
	    vol->total_alloc_clusters -= amt;
	    return collapse_free(vol, ii);
	}
	if (new_start >= old_start) {	/* overlaps are actually errors, but ... */
	    if (new_end >= old_end) {	/* we ignore them as errors, and handle them */
		amt = new_end - old_end;
		vrp->nblocks += amt;	/* just move end pointer in free list */
		vol->total_free_clusters += amt;
		vol->total_alloc_clusters -= amt;
	    }
	    return collapse_free(vol, ii);
	}
	amt = old_start - new_start;
	if (new_end > old_end) amt += new_end - old_end;
	vrp->nblocks += amt;		/* move the end pointer */
	vol->total_free_clusters += amt;
	vol->total_alloc_clusters -= amt;
	vrp->start = new_start;		/* move the start pointer */
	return collapse_free(vol, ii);
    }
    reuse = 0;
    if (vrp > vol->free) {
	--vrp;				/* look back one slot */
	if (!vrp->nblocks) {		/* is it empty? */
	    while (vrp > vol->free) {	/* yes, then keep looking back */
		--vrp;
		if (vrp->nblocks) break;	/* until a non-empty one is found */
	    }
	    if (vrp->nblocks) ++vrp;	/* if we stopped because of a non-empty, advance over it */
	    reuse = 1;
	} else {
	    ++vrp;			/* nevermind */
	}
    }
    if (!reuse) {
	++vol->free_ffree;		/* advance pointer */
	sts = mkroom_free(vol);		/* make sure there is room for insertion */
	if (sts) return sts;		/* there isn't, can't update */
	vrp = vol->free + ii;		/* vol->free might have moved */
	if (ii < vol->free_ffree-1) {	/* if in the middle */
	    memmove((char *)(vrp+1), (char *)vrp, (vol->free_ffree-1-ii)*sizeof(FsysRetPtr));
	}
	if (vol->free_ffree < vol->free_elems) {
	    FsysRetPtr *ep;
	    ep = vol->free + vol->free_ffree;
	    ep->start = ep->nblocks = 0; /* follow with a null if there's room */
	}
    }
    vrp->start = rp->start;
    vrp->nblocks = rp->nblocks;
    vol->total_free_clusters += rp->nblocks;
    vol->total_alloc_clusters -= rp->nblocks;
    return collapse_free(vol, vrp - vol->free);
#endif	
}

static int free_rps(FsysVolume *vol, FsysRamRP *rps) {
    FsysRamRP *cur, *nxt, *prev;
    int ii, jj, sts;

#if (FSYS_OPTIONS&FSYS_FEATURES&FSYS_FEATURES_SKIP_REPEAT)
# error You need to rewrite free_rps to get skip/repeat feature
#endif
    for (ii=0; ii < FSYS_MAX_ALTS; ++ii) {
	nxt = cur = rps + ii;
	while (nxt) {
	    FsysRetPtr *retp;
	    retp = nxt->rptrs;
	    for (jj=0; retp && jj < nxt->num_rptrs; ++jj, ++retp) {
		sts = back_to_free(vol, retp);
		if (sts) return sts;
	    }
	    nxt = nxt->next;
	}
	while (1) {
	    nxt = cur->next;
	    if (!nxt) break;
	    prev = cur;
	    while (nxt->next) {
		prev = nxt;
		nxt = nxt->next;
	    }
	    QIOfree(nxt);				/* done with this */
	    prev->next = 0;				/* break the link */
	}
	if (cur->rptrs && cur->mallocd) QIOfree(cur->rptrs);
	cur->rptrs = 0;
	cur->mallocd = 0;
	cur->num_rptrs = 0;
	cur->rptrs_size = 0;
    }
    return 0;
}

static int get_fh(FsysVolume *vol) {
    int fid, gen, ii;
    unsigned long *ulp;
    FsysRamFH *rfh;

    fid = 0;					/* assume failure */
    gen = 1;					/* assume generation of 1 */

    while (vol->unused_ffree) {			/* if something on the unused list */
	--vol->unused_ffree;			/* use it */
	fid = vol->unused[vol->unused_ffree];
	ulp = vol->index + fid*FSYS_MAX_ALTS;
	if (!(*ulp&0x80000000)) {		/* error, not really a free fid */
	    fid = 0;				/* keep looking */
	    continue;
	}
	gen = (*ulp & 0xff)+1;			/* get the new generation number */
	if (gen > 255) gen = 1;			/* wrap it back to 1 */
	break;
    }
    if (!fid) {					/* nothing on the unused list */
	FsysRamFH *nf;
	if (vol->files_ffree >= vol->files_elems) { /* grab a new one from the end of the allocated list */
	    int new_size;
	    new_size = vol->files_elems + 32;
	    nf = (FsysRamFH *)QMOUNT_REALLOC(vol, vol->files, new_size*sizeof(FsysRamFH));
	    if (!nf) {
		return -FSYS_CREATE_NOMEM;	/* ran out of memory */
	    }
	    vol->files = nf;
	    ulp = (U32*)QMOUNT_REALLOC(vol, vol->index, new_size*sizeof(U32)*FSYS_MAX_ALTS);
	    if (!ulp) {
		return -FSYS_CREATE_NOMEM;	/* ran out of room bumping index */
	    }
	    vol->index = ulp;
	    vol->files_elems = new_size;	/* ran out, so allocate some more */
	}
	fid = vol->files_ffree++;
	nf = vol->files + FSYS_INDEX_INDEX;	/* point to index file header */
	nf->size += sizeof(long)*FSYS_MAX_ALTS;	/* increment index file size */
	if (nf->size > nf->clusters*512) {	/* if file has grown out of its britches */
	    FsysRamRP *rp;
	    if (!nf->def_extend) nf->def_extend = FSYS_DEFAULT_DIR_EXTEND;
	    if (nf->def_extend*FSYS_MAX_ALTS >= vol->total_free_clusters) {
		return -FSYS_EXTEND_FULL;	/* no room to extend index file */
	    }
	    for (ii=0; ii < FSYS_MAX_ALTS; ++ii) {
		int ans;
		rp = nf->ramrp + ii;
		ans = extend_file(vol, nf->def_extend, rp, ii);
		if (ans) return -ans;		/* some kind of error */
	    }
	    nf->clusters += nf->def_extend;
	}
	add_to_dirty(vol, FSYS_INDEX_INDEX, 0); /* index file header needs updating */
    }
    ulp = vol->index + fid*FSYS_MAX_ALTS;	/* point to index */
    for (ii=0; ii < FSYS_MAX_ALTS; ++ii) {
	*ulp++ = 0x80000000 | gen;		/* make pointers to FH's invalid */
    }
    rfh = vol->files + fid;
    memset((char *)rfh, 0, sizeof(FsysRamFH));	/* zap the entire file header */
    rfh->generation = gen;			/* set the file's generation number */
    return fid;
}
    
static void fsys_mkheader(FsysHeader *hdr, int gen) {
    memset((char *)hdr, 0, sizeof(FsysHeader));
    hdr->id = FSYS_ID_HEADER;
#if (FSYS_FEATURES&FSYS_OPTIONS&FSYS_FEATURES_CMTIME)
    hdr->ctime = hdr->mtime = (unsigned long)time(0);
#endif
#if (FSYS_FEATURES&FSYS_OPTIONS&FSYS_FEATURES_ABTIME)
    hdr->atime = hdr->ctime;
    hdr->btime = 0;
#endif
    hdr->size = 0;			/* file size in bytes */
    hdr->type = FSYS_TYPE_FILE;	/* assume plain file */
    hdr->flags = 0;			/* not used, start with 0 */
    hdr->generation = gen;
}

static int zap_file( FsysLookUpFileT *luf ) {
    unsigned long *ndx;
    int fid, ii, sts;
    FsysRetPtr t;
    FsysVolume *vol;

    vol = luf->vol;
    remove_ent(luf->owner->directory, luf->fname); /* delete the name from the directory */
    add_to_dirty(vol, luf->owner - vol->files, 0); /* put owner directory on the dirty list */
    fid = luf->file - vol->files;
    ndx = vol->index + fid*FSYS_MAX_ALTS;
    t.start = *ndx;
    t.nblocks = 1;
    back_to_free(vol, &t);			/* free the FH */
    *ndx++ = luf->file->generation | 0x80000000;	/* remember the old generation number */
    for (ii=1; ii < FSYS_MAX_ALTS; ++ii) {
	t.start = *ndx;
	t.nblocks = 1;
	back_to_free(vol, &t);		/* free the FH */
	*ndx++ = luf->file->generation | 0x80000000;
    }
    sts = free_rps(vol, luf->file->ramrp);	/* free all the retrieval pointers */
    memset((char *)luf->file, 0, sizeof(FsysRamFH)); /* zap the entire file header */
    if (!sts) {
	sts = add_to_unused(vol, fid);	/* mark FH as unused */
	if (!sts) sts = upd_index_bits(vol, fid); /* need to update index file */
    }
    return sts ? sts : (FSYS_DELETE_SUCC|SEVERITY_INFO);
}

static void delete_q(QioIOQ *ioq) {
    FsysLookUpFileT luf;
    QioFile *file;

    luf.path = (char *)ioq->pparam0;
    luf.vol = (FsysVolume *)ioq->pparam1;
    luf.top = 0;
    ioq->iostatus = lookup_filename(&luf);
    if (ioq->iostatus == (FSYS_LOOKUP_SUCC|SEVERITY_INFO)) {
	if (luf.file->directory) {
	    ioq->iostatus = FSYS_DELETE_DIR;		/* for now, we cannot delete a directory */
	} else {
	    ioq->iostatus = zap_file(&luf);
	}
    }
    file = qio_fd2file(ioq->file);
    file->dvc = 0;
    file->private = 0;
    qio_freefile(file);
    ioq->file = -1;
    qio_freemutex(&luf.vol->mutex, ioq);
    qio_complete(ioq);
    return;
}

static int fsys_delete( QioIOQ *ioq, const char *name ) {
    FsysVolume *vol;
    QioFile *file;

    if ( !name || *name == 0 ) return (ioq->iostatus = FSYS_DELETE_INVARG);
    file = qio_fd2file(ioq->file);		/* get pointer to file */
    vol = (FsysVolume *)file->dvc->private;	/* point to our mounted volume */
    if (!vol) return (ioq->iostatus = FSYS_DELETE_FNF);
    if (!vol->files) (ioq->iostatus = FSYS_DELETE_FNF);
    ioq->pparam0 = (void *)name;
    ioq->pparam1 = (void *)vol;
    ioq->iostatus = 0;
    return qio_getmutex(&vol->mutex, delete_q, ioq);
}

static void fcreate_q(QioIOQ *ioq) {
    FsysOpenFileT *t;
    QioFile *file;
    FsysVolume *vol;
    FsysOpenT *dtls;
    FsysRamFH *rfh;
    FsysLookUpFileT luf;
    FsysDirEnt *dp;
    const char *fname;
    int fid, sts, ii, new, sectors, delete_after=0;

    t = (FsysOpenFileT *)ioq->private;
    if (!t) {
	ioq->iostatus = FSYS_CREATE_FATALNOPRIV;
	qio_complete(ioq);		/* this is certain death since the mutex is being held */
	return;
    }
    ioq = t->ioq;
    vol = t->vol;
    dtls = t->details;
    file = qio_fd2file(ioq->file);	/* get pointer to file */
    vol = luf.vol = t->vol;
    luf.top = 0;			/* If we supported 'cwd', this is where it would go */
    luf.path = t->path;

    do {
	sts = lookup_filename(&luf);
	if (sts != (FSYS_LOOKUP_SUCC|SEVERITY_INFO) && sts != FSYS_LOOKUP_FNF) {
	    ioq->iostatus = sts;
	    break;
	}
	fname = strrchr(t->path, QIO_FNAME_SEPARATOR); /* isolate the name from the path */
	if (!fname) fname = t->path;		/* no path, use name as is */
	if ((rfh=luf.file)) {			/* there's an old file */
	    int gen;
	    if (rfh->directory) {		/* cannot create a new file on top of a directory */
		ioq->iostatus = FSYS_CREATE_NAMEINUSE;
		break;
	    }
	    if (QIO_ERR_CODE((ioq->iostatus=free_rps(vol, rfh->ramrp)))) { /* free all the retrieval pointers */
		break;
	    }
	    gen = rfh->generation;			/* save old FH generation number */
/*
 * NOTE: This is a memory leak that needs plugging. The individual RamRP ptrs _may_
 * have been malloc'd. If they were, they need to be free'd before being erased.
 */
	    memset((char *)rfh, 0, sizeof(FsysRamFH));	/* zap the entire file header */
	    luf.dir->gen_fid = (luf.dir->gen_fid&FSYS_DIR_FIDMASK)|(gen<<FSYS_DIR_GENSHF); /* restore generation number in directory */
	    rfh->generation = gen;		/* restore generation number in FH */
	    fid = rfh - vol->files;
	    dp = luf.dir;			/* remember where the directory is */
	    new = 0;				/* signal not to update directory */
	} else {
	    U32 *ndx;
	    int bcnt;
	    char *fname;
	    FsysFindFreeT freet;
	    FsysRetPtr freep;
	    int oowner;				/* need to save this */

	    if (vol->total_free_clusters < FSYS_MAX_ALTS+1) { /* room for some additional FH's? */
		ioq->iostatus = FSYS_CREATE_NOFH;	/* nope, file system is full */
		break;
	    }	    
	    oowner = luf.owner - vol->files;
	    fid = get_fh(vol);				/* get the next available fileheader */
	    if (fid <= 0) {				/* no more file headers */
		ioq->iostatus = fid ? -fid : FSYS_CREATE_NOFH;
		break;
	    }
	    luf.owner = vol->files + oowner;
	    ndx = vol->index + fid*FSYS_MAX_ALTS;
	    rfh = vol->files + fid;
	    freet.skip = 0;
	    freet.exact = 0;
	    freet.actelts = vol->free_ffree;
	    freet.totelts = vol->free_elems;
	    freet.freelist = vol->free;
	    freet.reply = &freep;
	    freet.request = 1;
	    freet.hint = 0;
	    for (sts=bcnt=0; bcnt < FSYS_MAX_ALTS; ++bcnt) {
		freet.lo_limit = FSYS_COPY_ALG(bcnt, vol->maxlba);
		if ( fsys_findfree( &freet ) ) {	/* get a free block */
		    ioq->iostatus = FSYS_CREATE_FULL;	/* no room for file headers */
		    break;
		}
		if (vol->free_start > freet.which_elem) vol->free_start = freet.which_elem;
		if (*ndx && !(*ndx&0x80000000)) {	/* just to make sure we didn't screw up */
		    ioq->iostatus = FSYS_CREATE_FATAL;	/* oops, must have double mapped a file header */
		    break;
		}
		vol->free_ffree = freet.actelts;	/* update if appropriate */
		*ndx++ = freep.start;			/* load index file with new LBA */
	    }	
	    if (QIO_ERR_CODE(ioq->iostatus)) break;
	    vol->total_free_clusters -= FSYS_MAX_ALTS;
	    vol->total_alloc_clusters += FSYS_MAX_ALTS;
	    dp = (FsysDirEnt *)QMOUNT_ALLOC(vol, sizeof(FsysDirEnt)+strlen(luf.fname)+1);
	    fname = (char *)(dp+1);
	    strcpy(fname, luf.fname);
	    dp->name = fname;
	    dp->gen_fid = (rfh->generation<<FSYS_DIR_GENSHF) | fid;
	    dp->next = 0;
	    upd_index_bits(vol, fid);
	    new = 1;
	}
#if (FSYS_FEATURES&FSYS_OPTIONS&FSYS_FEATURES_CMTIME)
# if HAVE_TIME
	rfh->ctime = dtls->ctime ? dtls->ctime : (U32)time(0);
# else
	rfh->ctime = dtls->ctime;
# endif
	rfh->mtime = dtls->mtime ? dtls->mtime : dtls->ctime;
#endif
#if (FSYS_FEATURES&FSYS_OPTIONS&FSYS_FEATURES_ABTIME)
	rfh->atime = dtls->atime;
	rfh->btime = dtls->btime;
#endif
	add_to_dirty(t->vol, fid, 0);			/* put FH on the dirty list */
	if (!rfh->def_extend) {
	    rfh->def_extend = dtls->mkdir ? FSYS_DEFAULT_DIR_EXTEND : FSYS_DEFAULT_EXTEND;
	}
	if (dtls->alloc) {
	    sectors = ((dtls->alloc+511)/512);
	} else {
	    sectors = rfh->def_extend;
	}
	luf.file = rfh;					/* in case of errors */
	if (vol->total_free_clusters < sectors*dtls->copies) { /* room for file? */
	    zap_file( &luf );				/* remove all traces of this file */
	    ioq->iostatus = FSYS_CREATE_FULL;		/* file system is full */
	    break;
	}	    
	rfh->clusters = sectors;
	for (ii=0; ii < FSYS_MAX_ALTS && ii < dtls->copies; ++ii) { /* add retrieval pointers to the file */
	    FsysRamRP *rp;
	    int where;

	    rp = rfh->ramrp + ii;

	    where = dtls->placement + ii;
	    if (where >= FSYS_MAX_ALTS) where = FSYS_MAX_ALTS-1;
	    sts = extend_file(vol, rfh->clusters, rp, where);
	    if (sts) {
		zap_file( &luf );			/* remove all traces of this file */
		ioq->iostatus = sts;
		break;
	    }
	}
	if (QIO_ERR_CODE(ioq->iostatus)) break;
	if (new) {
	    insert_ent(luf.owner->directory, dp);	/* insert new file into parent directory */
	    add_to_dirty(t->vol, luf.owner - t->vol->files, 0); /* put owner directory on the dirty list too */
	}
	rfh->valid = RAMFH_VALID;		/* mark entry as valid and useable */
	ioq->iostatus = FSYS_CREATE_SUCC|SEVERITY_INFO; /* assume success */
	dtls->fid = ((rfh->generation<<24) | (rfh - vol->files));
	file->private = (void *)dtls->fid;
	dtls->parent = ((luf.owner->generation<<24) | (luf.owner - vol->files));
	while (dtls->mkdir) {			/* are we to make it into a directory? */
	    FsysDirEnt *inddir;			/* pointer to list of directory ents */
	    char *strings;			/* pointer to place to put strings */

	    delete_after = 1;
	    rfh->directory = (FsysDirEnt **)QMOUNT_ALLOC(vol, FSYS_DIR_HASH_SIZE*sizeof(FsysDirEnt*) +
    					3+2+	/* + room for strings (. and ..) */
					2*sizeof(FsysDirEnt)); /* + room for directory items */
	    if (!rfh->directory) {
		ioq->iostatus = FSYS_CREATE_NOMEM;
		break;
	    }

	    inddir = (FsysDirEnt *)(rfh->directory + FSYS_DIR_HASH_SIZE);
	    strings = (char *)(inddir + 2);
	    inddir->name = strings;
	    *strings++ = '.';
	    *strings++ = '.';
	    *strings++ = 0;
	    inddir->gen_fid = (luf.owner->generation<<FSYS_DIR_GENSHF) | (luf.owner - vol->files);
	    insert_ent(rfh->directory, inddir);
	    ++inddir;
	    inddir->name = strings;
	    *strings++ = '.';
	    *strings = 0;
	    inddir->gen_fid = (rfh->generation<<FSYS_DIR_GENSHF) | (rfh - vol->files);
	    insert_ent(rfh->directory, inddir);
	    break;
	}
	break;
    } while (0);
    file->pos = 0;			/* !FIXME!!! start at beginning of file */
    qio_freemutex(&vol->mutex, ioq);	/* done with volume mutex */
    if (delete_after || QIO_ERR_CODE(ioq->iostatus)) {	/* if there were open errors */
	qio_freefile(file);		/* done with the file descriptor */
	ioq->file = -1;			/* file didn't open */
	dtls->fid = -1;
	dtls->parent = -1;
    }
    QIOfree(ioq->private);		/* done with this memory */
    ioq->private = 0;			/* burn our bridges */
    qio_complete(ioq);			/* call user's completion routine if any */
    return;
}
#endif				/* !FSYS_READ_ONLY */

static void fopen_q(QioIOQ *ioq) {
    FsysOpenFileT *t;
    QioFile *file;
    FsysVolume *vol;
    FsysOpenT *dtls;
    FsysRamFH *rfh;
    FsysLookUpFileT luf;
    int fid, gen;

    t = (FsysOpenFileT *)ioq->private;

#if !FSYS_READ_ONLY
    if (t->mode&_FCREAT) {
	fcreate_q(ioq);			/* open for writing */
	return;
    }
#endif

    vol = t->vol;
    dtls = t->details;
    file = qio_fd2file(ioq->file);		/* get pointer to file */
    if (!file) {
	ioq->iostatus = FSYS_OPEN_NOTOPEN;
    } else do {
	if ((fid=dtls->fid)) {			/* if to open by FID */
	    gen = (fid >> 24)&0xFF;
	    fid &= 0x00FFFFFF;
	    if (fid >= vol->files_ffree) {
		ioq->iostatus = FSYS_OPEN_NOFID; /* fid out of range */
		break;
	    }
	    rfh = vol->files + fid;
	    if (rfh->generation != gen) {
		ioq->iostatus = FSYS_OPEN_NOGEN; /* generation numbers don't match */
		break;
	    }
	    dtls->parent = 0;			/* don't know a parent if open by FID */
	} else {				/* else we're to open by name */
	    FsysRamFH *own;
	    luf.vol = vol;
	    luf.top = 0;			/* start looking at root directory */
	    luf.path = t->path;			/* point to adjusted name */
	    ioq->iostatus = lookup_filename(&luf);
	    if (QIO_ERR_CODE(ioq->iostatus)) {	/* if didn't open */
		break;				/* just die */
	    }
	    rfh = luf.file;
	    own = luf.owner;
	    dtls->fid = (rfh->generation<<24) | (rfh - vol->files); /* pass back FID of opened file */
	    dtls->parent = (own->generation<<24) | (own - vol->files); /* pass back FID of parent */
	}		
	dtls->alloc = rfh->clusters * 512;	/* number of bytes allocated to file */
	dtls->eof = rfh->size;			/* size of file in bytes */
	if (!(file->mode&_FAPPEND)) { 
	    file->pos = 0;			/* assume start at position 0 */
	    if ((file->mode&(_FWRITE|_FREAD)) == _FWRITE) { /* if open only for write ... */
		rfh->size = 0;			/* ... move the file's eof mark too */
	    }
	} else {
	    file->pos = dtls->eof;		/* unless supposed to append */
	}
	file->size = rfh->size;			/* note the size of the file */
	dtls->placement = 0;			/* cannot determine placement */
	for (gen=0; gen < FSYS_MAX_ALTS; ++gen) {
	    if (!rfh->ramrp[gen].rptrs) break;
	}
	if ((file->mode&O_OPNCPY)) {
	    file->mode &= ~FSYS_OPNCPY_M;	/* zap all the bits */
	    if (dtls->copies+1 > gen) {
		ioq->iostatus = FSYS_LOOKUP_FNF; /* cannot open that version */
		break;
	    }
	    file->mode |= (dtls->copies+1) << FSYS_OPNCPY_V;
	}
	dtls->copies = gen;			/* give 'em copies */
	dtls->mkdir = rfh->directory ? 1 : 0;	/* tell 'em if file is directory */
#if (FSYS_FEATURES&FSYS_OPTIONS&FSYS_FEATURES_CMTIME)
	dtls->ctime = rfh->ctime;
	dtls->mtime = rfh->mtime;
#endif
#if (FSYS_FEATURES&FSYS_OPTIONS&FSYS_FEATURES_ABTIME)
	dtls->atime = rfh->atime;
	dtls->btime = rfh->btime;
#endif
	file->private = (void*)dtls->fid;	/* remember FID of open file for ourself */
	ioq->iostatus = FSYS_IO_SUCC|SEVERITY_INFO;
	break;
    } while (0);
    if (QIO_ERR_CODE(ioq->iostatus)) {	/* if there were open errors */
	qio_freefile(file);		/* done with the file descriptor */
	ioq->file = -1;			/* file didn't open */
	dtls->fid = -1;
	dtls->parent = -1;
    }
    ioq->private = 0;			/* burn our bridges */
    qio_freemutex(&vol->mutex, ioq);	/* done with volume mutex */
    qio_complete(ioq);			/* call user's completion routine if any */
    QIOfree(t);				/* done with this memory */
    return;
}

/*********************************************************************
 * fsys_open - open a file for input or output. Expected to be called
 * from qio_open.
 *
 * At entry:
 *	ioq - pointer to QioIOQ struct.
 *	name - pointer to null terminated string with path/filename.
 *
 * NOTE: If O_QIOSPC is set in 'mode', then ioq->spc points to a
 * FsysOpenT struct with additional details about the open:
 *	path - pointer to null terminated string of whole name including
 *		volume name.
 *	fid - if .ne. and mode is O_RDONLY, will open the file by FID
 *		ignoring the 'name' parameter. Regardless of mode bits, open
 *		will set this field to the FID of the opened file at completion
 *		(or -1 if open failed).
 *	parent - Regardless of mode bits, open will set this field to the FID
 *		of the parent directory (or -1 if open failed).
 *	alloc - if mode set to O_WRONLY, specifies the amount of disk to
 *		pre-allocate to the file. Regardless of mode bits, open will
 *		set this field to the amount of space allocated to the file.
 *	eof - if mode set to O_WRONLY, specifies where the EOF marker is
 *		to be set. Regardless of mode bits, open will set this field
 *		to the position of the EOF marker at completion.
 *	placement - number from 0 to FSYS_MAX_ALTS-1 indicating the preferred
 *		placement of the file. Only relevant during file creation.
 *	copies - if mode contained O_WRONLY, specifies the number of copies
 *		of the file that are to be maintained (value must be from 1
 *		to FSYS_MAX_ALTS). Regardless of mode bits, open will set this
 *		field to the copies of files that are present in the file system
 *		at completion.
 *	mkdir - if mode contains O_CREAT and this field is not 0, the created
 *		file will made into a directory.

 * At exit:
 *	returns one of FSYS_CREATE_xxx signalling success or failure
 *	*file gets pointer to newly created FsysRamFH struct.
 */

static int fsys_open( QioIOQ *ioq, const char *name ) {
    FsysVolume *vol;
    FsysOpenFileT *ours=0;
    FsysOpenT *his;
    QioFile *file;
    int sts = 0;

    if (!ioq) return FSYS_OPEN_INVARG;
    do {
	file = qio_fd2file(ioq->file);		/* get pointer to file */
	his = (FsysOpenT *)file->private;
	vol = (FsysVolume *)file->dvc->private;	/* point to our mounted volume */
	if (!vol) {
	    ioq->iostatus = FSYS_OPEN_NOTMNT;
	    break;
	}
	if (!vol->files) {
	    ioq->iostatus = FSYS_OPEN_NOTMNT;
	    break;
	}
	if ( (!his || !his->fid) && (!name || *name == 0) ) {
	    ioq->iostatus = FSYS_OPEN_INVARG;
	    break;
	}
	if ((file->mode&_FCREAT)) {
#if FSYS_READ_ONLY
	    ioq->iostatus = FSYS_CREATE_NOSUPP;
	    break;
#else
	    if (his && ((his->copies < 0 || his->copies > FSYS_MAX_ALTS) ||
	                (his->placement < 0 || his->placement >= FSYS_MAX_ALTS)) ) {
		ioq->iostatus = FSYS_OPEN_INVARG;
		break;
	    }
	    if (his && !his->copies) his->copies = 1;
#endif
	}
	ours = QIOcalloc(sizeof(FsysOpenFileT)+sizeof(FsysOpenT),1);
	if (!ours) {
	    ioq->iostatus = FSYS_OPEN_NOMEM;
	    break;
	}
	if (!his) {
	    his = (FsysOpenT *)(ours+1);
	    his->spc.path = name;
	    his->spc.mode = file->mode;
	    his->copies = 1;
	}
	ours->details = his;
	ours->vol = vol;
	ours->ioq = ioq;
	ours->path = name;
	ours->mode = file->mode;
	ioq->private = (void *)ours;
	sts = qio_getmutex(&vol->mutex, fopen_q, ioq);
	if (sts) {
	    ioq->iostatus = sts;
	    break;
	}
	return 0;
    } while (0);
    if (ours) QIOfree(ours);
    qio_freefile(file);
    ioq->file = -1;
    ioq->private = 0;
    return ioq->iostatus;
}

#if !FSYS_READ_ONLY
/*********************************************************************
 * fsys_mkdir - create a directory. This function creates a directory on the
 * specified volume.
 *
 * At entry:
 *	ioq - pointer to QioIOQ struct.
 *	name - pointer to null terminated string with path/filename
 *	mode - mode to apply to directory (not used)
 *
 * At exit:
 *	returns one of FSYS_CREATE_xxx signalling success or failure.
 */

static int fsys_mkdir( QioIOQ *ioq, const char *name, int mode ) {
    FsysVolume *vol;
    FsysOpenFileT *ours=0;
    FsysOpenT *his;
    QioFile *file;
    int sts = 0;

    if (!ioq) return FSYS_OPEN_INVARG;
    do {
	file = qio_fd2file(ioq->file);		/* get pointer to file */
	vol = (FsysVolume *)file->dvc->private;	/* point to our mounted volume */
	if (!vol) {
	    ioq->iostatus = FSYS_OPEN_NOTMNT;
	    break;
	}
	ours = QIOcalloc(sizeof(FsysOpenFileT)+sizeof(FsysOpenT),1);
	if (!ours) {
	    ioq->iostatus = FSYS_OPEN_NOMEM;
	    break;
	}
	his = (FsysOpenT *)(ours+1);
	his->spc.path = name;
	his->spc.mode = O_CREAT;
	his->copies = FSYS_MAX_ALTS;	/* there are always max copies of directories */
	his->mkdir = 1;
	ours->details = his;
	ours->vol = vol;
	ours->ioq = ioq;
	ours->path = name;
	ours->mode = _FCREAT;
	ioq->private = (void *)ours;
	sts = qio_getmutex(&vol->mutex, fopen_q, ioq);
	if (sts) {
	    ioq->iostatus = sts;
	    break;
	}
	return 0;
    } while (0);
    if (ours) QIOfree(ours);
    qio_freefile(file);
    ioq->file = -1;
    return ioq->iostatus;
}
#endif

static int mk_ramdir(FsysVolume *vol) {
    unsigned char *s, *lim, gen;
    unsigned long fid;
    int qty, len, totstr;
    FsysDirEnt *inddir, **dir;		/* pointer to list of directory ents */
    unsigned char *strings;		/* pointer to place to put strings */
    FsysRamFH *rfh;

    rfh = vol->files + vol->files_indx;
    dir = rfh->directory;		/* pointer to our hash table */
    if (!dir) {
	vol->status = FSYS_MOUNT_FATAL;
	return 1;
    }
    s = (unsigned char *)vol->buff;
#if 1
    lim = s + vol->rw_amt;
    qty = totstr = 0;			/* start with nothing */    		
    while (s < lim) {			/* walk the list to get lengths and counts */
	fid = (s[2]<<16) | (s[1]<<8) | *s;
	if (!fid) break;		/* fid of 0 is end of list */
	s += 4;				/* skip fid and generation number */
	len = *s++;
	if (!len) len = 256;
	totstr += len;
	++qty;
	s += len;
    }
    inddir = (FsysDirEnt *)QMOUNT_ALLOC(vol, totstr+	/* room for strings */
    			  	       qty*sizeof(FsysDirEnt)); /* room for directory items */
    if (!inddir) {
	vol->status = FSYS_MOUNT_NOMEM;
	return 1;
    }
    strings = (unsigned char *)(inddir + qty);

    s = (unsigned char *)vol->buff;
    while (s < lim) {
	fid = (s[2]<<16) | (s[1]<<8) | *s;
	if (!fid) break;		/* fid of 0 is end of list */
	s += 3;
	gen = *s++;
	len = *s++;
	if (!len) len = 256;
	strcpy((char *)strings, (char *)s);
	inddir->name = (char *)strings;
	inddir->gen_fid = 0;		/* assume invalid entry */
	if (fid < vol->files_ffree) {	/* fid is in bounds */
	    rfh = vol->files + fid;	/* point to file header */
	    inddir->gen_fid = (gen<<FSYS_DIR_GENSHF) | fid;
	}
	insert_ent(dir, inddir);	/* put filename into directory */
	s += len;
	strings += len;
	++inddir;
    }
#else
    lim = s + vol->rw_amt;
    while (s < lim) {			/* walk the list to get lengths and counts */
	totstr = 0;				/* start with nothing */    		
	fid = (s[2]<<16) | (s[1]<<8) | *s;
	if (!fid) break;		/* fid of 0 is end of list */
	s += 3;
	gen = *s++;
	len = *s++;
	if (!len) len = 256;
	inddir = (FsysDirEnt *)QMOUNT_ALLOC(vol, len+	/* room for string */
					   sizeof(FsysDirEnt)); /* room for directory item */
	if (!inddir) {
	    vol->status = FSYS_MOUNT_NOMEM;
	    return 1;
	}
	strings = (unsigned char *)(inddir + 1);
	strcpy((char *)strings, (char *)s);
	inddir->name = (char *)strings;
	inddir->fid = 0;		/* assume invalid entry */
	if (fid < vol->files_ffree) {	/* fid is in bounds */
	    inddir->gen_fid = (gen<<FSYS_DIR_GENSHF) | fid;
	}
	insert_ent(dir, inddir);	/* put filename into directory */
	s += len;
    }
#endif
    return 0;
}

static int mk_ramfh(FsysVolume *vol, FsysRamFH *rfh) {
    FsysHeader *hdr;
    FsysRamRP *rrp;
    FsysRetPtr *dst, *src;
    int ii, jj, kk, amt, nblk=0;

    hdr = (FsysHeader *)vol->buff;
    memset((char *)rfh, 0, sizeof(FsysRamFH));
#if (FSYS_OPTIONS&FSYS_FEATURES&FSYS_FEATURES_EXTENSION_HEADER)
    if (hdr->extension) {
	vol->status = FSYS_MOUNT_NOSUPP;	/* extension headers not supported */
	return 1;
    }
#endif
    rfh->clusters = hdr->clusters;
    vol->total_alloc_clusters += FSYS_MAX_ALTS;
    rfh->size = hdr->size;
    rfh->generation = hdr->generation;		/* keep a copy of generation number */
    if (hdr->type == FSYS_TYPE_DIR) {		/* if file is a directory */
	rfh->directory = (FsysDirEnt **)QMOUNT_ALLOC(vol, FSYS_DIR_HASH_SIZE*sizeof(FsysDirEnt*));
	if (!rfh->directory) {
	    vol->status = FSYS_MOUNT_NOMEM;
	    return 1;
	}
	rfh->def_extend = FSYS_DEFAULT_DIR_EXTEND;
    } else {
	rfh->def_extend = FSYS_DEFAULT_EXTEND;
    }
#if (FSYS_FEATURES&FSYS_OPTIONS&FSYS_FEATURES_CMTIME)
    rfh->mtime = hdr->mtime;
#endif
#if (FSYS_FEATURES&FSYS_OPTIONS&FSYS_FEATURES_PERMS)
    rfh->perms = hdr->perms;
    rfh->owner = hdr->owner;
#endif
    rrp = rfh->ramrp;
    for (amt=kk=jj=0; jj < FSYS_MAX_ALTS; ++jj, ++rrp) {
	for (ii=0; ii < FSYS_MAX_FHPTRS; ++ii) {
	    if (!hdr->pointers[jj][ii].start) break;
	}
	if (ii) ++kk;
	if (ii > amt) amt = ii;
    }
    if (kk) {
#if 0 && !FSYS_READ_ONLY && !FSYS_TIGHT_MEM
	amt += 8;
	if (amt > FSYS_MAX_FHPTRS) amt = FSYS_MAX_FHPTRS;
#endif
	jj = kk*amt;
	rrp = rfh->ramrp;
#if FSYS_TIGHT_MEM
	if (vol->rp_pool_size >= jj) {
	    dst = vol->rp_pool;
	    vol->rp_pool += jj;
	    vol->rp_pool_size -= jj;
	} else
#endif
	    dst = (FsysRetPtr *)QMOUNT_ALLOC(vol, jj*sizeof(FsysRetPtr));
	if (!dst) {		/* ooops, ran out of memory */
	    vol->status = FSYS_MOUNT_NOMEM ;
	    return 1;
	}
	for (jj=0; jj < kk; ++jj, ++rrp, dst += amt) {
	    FsysRetPtr *lcl_dst;
	    if (hdr->pointers[jj][0].start == 0) break; /* nothing left to do */
	    rrp->rptrs = dst;
#if !FSYS_READ_ONLY
	    rrp->rptrs_size = amt;
#endif
	    src = hdr->pointers[jj];
	    lcl_dst = dst;
	    for (ii=0; ii < amt; ++ii, ++lcl_dst, ++src) {
		if (!src->start) break;
		lcl_dst->start = src->start;
		lcl_dst->nblocks = src->nblocks;
		nblk += src->nblocks;
	    }
	    rrp->num_rptrs = ii;
	}
    }
    vol->total_alloc_clusters += nblk;
    rfh->valid = RAMFH_VALID;
    return 0;
}

#if !FSYS_READ_ONLY || FSYS_UPD_FH
enum syn_state {
    SYNC_BEGIN,
    SYNC_WALK_DIRTY,
    SYNC_READFH_COMPLETE,
    SYNC_WRITE_FH,
# if !FSYS_READ_ONLY
    SYNC_UPD_INDEX,
    SYNC_INDEX_WRCOMPL,
    SYNC_UPD_FREE,
    SYNC_FREE_WRCOMPL,
    SYNC_UPD_DIRECTORY,
    SYNC_WRITE_DIRECTORY,
# endif
    SYNC_READ_FIRSTFH,
    SYNC_DONE
};
#endif

#if !FSYS_READ_ONLY || FSYS_UPD_FH
static int get_sync_buffers(FsysVolume *vol, FsysSyncT *syn) {
    int old_size;
    unsigned char *old_ptr, *old_head;
    old_size = syn->buffer_size;
    old_ptr = (U8*)syn->output;
    old_head = (U8*)syn->buffers;
    syn->buffer_size = (syn->buffer_size + FSYS_SYNC_BUFFSIZE + 511) & -512;
    SYNSQK((OUTWHERE "%6d: get_sync_buffers: Increasing buffer size from %d to %d\n",
		eer_rtc, old_size, syn->buffer_size));
    syn->buffers = (unsigned long *)QMOUNT_ALLOC(vol, syn->buffer_size+QIO_CACHE_LINE_SIZE);
    if (!syn->buffers) {
	SYNSQK((OUTWHERE "        Ran out of memory\n"));
	return (syn->status = FSYS_SYNC_NOMEM);
    }
    syn->output = (unsigned long *)QIO_ALIGN(syn->buffers, QIO_CACHE_LINE_SIZE);
    memcpy(syn->output, old_ptr, old_size);
    QMOUNT_FREE(vol, old_head);
    return 0;
}

static void fsys_sync_q(QioIOQ *ioq) {
    FsysVolume *vol;
    FsysSyncT *syn;
    int sts;
    FsysRamFH *rfh=0;
    FsysQio *qio;
    int fid, ii;
    unsigned long *ndx;

    syn = (FsysSyncT *)ioq;
    qio = (FsysQio *)ioq;
    vol = syn->vol;
    syn->status = 0;			/* assume success */

    while (1) {
	switch (syn->state) {
	    default:
		SYNSQK((OUTWHERE "%6d: fsys_sync_q: Illegal state of %d\n", syn->state));
		syn->status = FSYS_SYNC_FATAL;	/* something terrible happened */
		break;
	    case SYNC_BEGIN: {
		if (!vol->dirty_ffree) {
		    break;			/* nothing in the dirty list, we're done */
		}
		if (!syn->output) {		/* need to get a buffer */
		    SYNSQK(( OUTWHERE "%6d: sync: Begin, getting buffers.\n", eer_rtc));
		    if (get_sync_buffers(vol, syn)) break;
		    qio->compl = fsys_sync_q;	/* completion routine is us */
		    ioq->file = vol->iofd;
		    syn->ramrp.rptrs = &syn->rptr;
# if !FSYS_READ_ONLY
		    syn->ramrp.rptrs_size = 1;
		    syn->ramrp.next = 0;
# endif
		    syn->ramrp.num_rptrs = 1;
		    syn->rptr.start = 0;	/* start at block 0 on device */
		    syn->rptr.nblocks = vol->maxlba; /* the whole disk is one file */
		}
		syn->substate = 0;
		syn->state = SYNC_WALK_DIRTY;	/* walk the dirty list */
		syn->alts = 0;			/* start with the first copy */
		SYNSQK(( OUTWHERE "%6d: sync: Begin alt 0.\n", eer_rtc));
		continue;
	    }

	    case SYNC_WALK_DIRTY: {
		if (syn->substate >= vol->dirty_ffree) {
# if !FSYS_READ_ONLY
		    if (!syn->alts) {			/* check this on the first pass */
			rfh = vol->files + FSYS_INDEX_FREE;
			collapse_free(vol, INT_MAX);
			ii = (vol->free_ffree * sizeof(FsysRetPtr) + 511) & -512;
			if (ii > rfh->size) {
			    rfh->size = ii;			/* record high water mark */
			    add_to_dirty(vol, FSYS_INDEX_FREE, 1); /* add to end of dirty list */
			    continue;			/* re-iterate */
			}
		    }
# endif
		    SYNSQK(( OUTWHERE "%6d: sync: dirty list %d processing complete. substate=%d\n",
		    	eer_rtc, syn->alts, syn->substate));

		    if (++syn->alts < FSYS_MAX_ALTS) {
			syn->substate = 0;		/* restart the whole procedure again */
			continue;
		    }

# if !FSYS_READ_ONLY
		    syn->state = SYNC_UPD_INDEX; /* start updating index file */
		    syn->alts = 0;
# else
		    syn->state = SYNC_DONE;
# endif
		    syn->substate = 0;
		    continue;
		}
		fid = vol->dirty[syn->substate]; /* get fid of file to process next */
		rfh = vol->files + fid;		/* point to FH */
		SYNSQK(( OUTWHERE "%6d: sync: processing dirty fid: %08lX.%d. valid=%d\n",
		    eer_rtc, fid, syn->alts,
    		   (fid >= FSYS_INDEX_ROOT) && (fid < vol->files_ffree) ? rfh->valid : 0));
		if ((fid > FSYS_INDEX_ROOT && !rfh->valid) || fid >= vol->files_ffree) { /* it isn't valid anymore */
		    SYNSQK(( OUTWHERE "%6d: sync: fid %08lX invalid. ffree=%d, valid=%d\n",
		    	eer_rtc, fid, vol->files_ffree, fid <= FSYS_INDEX_ROOT ? rfh->valid : 0));
# if !FSYS_READ_ONLY
		    ndx = vol->index + fid*FSYS_MAX_ALTS;
		    if (!syn->alts && fid < vol->files_ffree && !(*ndx&0x80000000)) { /* check that the index file is ok with an invalid RFH */
			int jj;
			for (jj=0; jj < FSYS_MAX_ALTS; ++jj) ndx[jj] = 0x80000001;
			upd_index_bits(vol, fid); /* signal we have to write the index file */
		    }
# endif
		    ++syn->substate;	/* next file */
		    continue;
		}
# if !FSYS_READ_ONLY
		if (rfh->directory) {
		    syn->state = SYNC_UPD_DIRECTORY;
		} else {
		    syn->state = SYNC_READ_FIRSTFH;
		}
# else
		syn->state = SYNC_READ_FIRSTFH;
# endif
		continue;
	    }				/* -- case WALK_DIRTY */

# if !FSYS_READ_ONLY
	    case SYNC_UPD_DIRECTORY: {
		char *dst, *lim;
		FsysDirEnt **hash, *dir;
		int sects;

		dst = (char *)syn->output;
		lim = dst + syn->buffer_size;
		hash = rfh->directory;		/* point to hash table */
		SYNSQK(( OUTWHERE "%6d: Writing directory\n", eer_rtc));
		for (ii=0; ii < FSYS_DIR_HASH_SIZE; ++ii, ++hash) {
		    dir = *hash;		/* point to directory entry */
		    while (dir) {
			int len;
			if (lim-dst <= (len=strlen(dir->name)+1)+1+4+4) {
			    int olen;
			    olen = dst - (char *)syn->output; /* remember how much we have used */
			    if (get_sync_buffers(vol, syn)) break;
			    dst = (char *)syn->output + olen;
			    lim = (char *)syn->output + syn->buffer_size;
			    continue;
			}
			*dst++ = dir->gen_fid;
			*dst++ = dir->gen_fid>>8;
			*dst++ = dir->gen_fid>>16;
			*dst++ = dir->gen_fid>>24;
			*dst++ = len;
			strcpy(dst, dir->name);
			dst += len;
			dir = dir->next;
		    }
		    if (syn->status) break;
		}
		if (lim-dst < 4) {
		    int olen;
		    olen = dst - (char *)syn->output; /* remember how much we have used */
		    if (get_sync_buffers(vol, syn)) break;
		    dst = (char *)syn->output + olen;
		}
		*dst++ = 0;			/* need a null fid to end the list */
		*dst++ = 0;
		*dst++ = 0;
		*dst++ = 0;
#  if FSYS_SQUAWKING && !FSYS_SQUAWKING_STDIO
		if (!syn->alts && (rfh - vol->files) == FSYS_INDEX_ROOT) {
		    extern void fsys_dump_bytes(void *iop, U8 *s, int siz);
		    SYNSQK(( OUTWHERE "       Dump of root directory (%d bytes)\n", rfh->size));
		    fsys_dump_bytes(OUTWHERE (U8*)syn->output, dst - (char *)syn->output);
		}
#  endif
		sects = dst - (char *)syn->output; /* compute size of data */
		if (sects&511) {
		    memset(dst, 0, 512 - (sects&511)); /* clear the rest of the buffer to sector boundary */
		}
		if (syn->status) break;
		rfh->size = dst - (char *)syn->output;
		sects = (rfh->size+511)/512;
		if (!syn->alts && sects > rfh->clusters) {
		    int def;
		    def = sects - rfh->clusters;
		    def += rfh->def_extend ? rfh->def_extend : FSYS_DEFAULT_EXTEND;
		    sts = 0;
		    if (def*FSYS_MAX_ALTS < vol->total_free_clusters) {
			for (ii=0; ii < FSYS_MAX_ALTS; ++ii) {
			    sts = extend_file(vol, def, rfh->ramrp+ii, ii);
			    if (sts) break;
			}
			if (!sts) rfh->clusters += def;
		    }
		    if (sts) {
			syn->state = SYNC_READ_FIRSTFH;
			continue;
		    }
		}
		syn->state = SYNC_WRITE_DIRECTORY;
		qio->ramrp = rfh->ramrp+syn->alts; /* point to retrieval pointer set */
		qio->u_len = rfh->size;
		qio->buff = (U8*)syn->output;	/* point to output buffer */
		qio->state = 0;
		qio->sector = 0;
		SYNSQK(( OUTWHERE "%6d: sync, directory upd: Queuing write %d. u_len=%d, sector=0\n",
	    		eer_rtc, syn->alts, qio->u_len));
		fsys_qwrite(ioq);
		return;
	    }			/* -- case SYNC_UPD_DIRECTORY */
	    case SYNC_WRITE_DIRECTORY: {
		if (QIO_ERR_CODE(ioq->iostatus)) { /* All we can do is log write errors */
		    syn->errlog[syn->err_in++] = ioq->iostatus;
		    if (syn->err_in > n_elts(syn->errlog)) syn->err_in = 0;
		    ++syn->errcnt;
		}
		syn->state = SYNC_READ_FIRSTFH; /* go update the directory's file header */
		continue;
	    }		/* -- case SYNC_WRITE_DIRECTORY */
# endif
	    case SYNC_READ_FIRSTFH: {
# if 0	/* someday we might have to pre-read the old file header before updating */
		if ((rfh->valid&RAMFH_NEW)) {	/* if it is a brand new fileheader */
		    syn->state = SYNC_READFH_COMPLETE;
		    ioq->iostatus = 0;		/* pretend we got no errors */
		    continue;			/* and goto next state */
		}
		qio->rptrs = &syn->ramrp;	/* point to fake retrieval pointer */
		qio->u_len = 512;
		qio->buff = syn->output;		/* point to input buffer */
		qio->state = 0;
		qio->sector = *ndx;		/* fh's lba */
		qio->ioq->file = vol->iofd;
		ioq->private = (void *)qio;	/* cross connect these structs */
		syn->state = SYNC_READFH_COMPLETE;
		syn->alts = 0;
		fsys_qread(ioq);
		return;
# else
		syn->state = SYNC_READFH_COMPLETE;
		ioq->iostatus = 0;		/* no errors */
		continue;			/* goto next state */
# endif
	    }			/* -- case SYNC_READ_FIRSTFH */
	    case SYNC_READFH_COMPLETE: {
		FsysHeader *fh;
		FsysRetPtr *dst;
		FsysRamRP *src;
		int alts;

		fid = vol->dirty[syn->substate]; /* get fid of file to process */
# if 0	/* someday we might have to pre-read the old file header before updating */
		if (QIO_ERR_CODE(qio->iostatus)) { /* no read errors on file headers allowed */
		    ++syn->alts;		/* advance to alternate fileheader pointer */
		    if (syn->alts >= FSYS_MAX_ALTS) {	/* tried all of them and none worked */
			syn->errlog[syn->err_in++] = ioq->iostatus;
			if (syn->err_in > n_elts(syn->errlog)) syn->err_in = 0;
			++syn->errcnt;
			syn->state = SYNC_WALK_DIRTY;
			++syn->substate;	/* Oh well, just skip this file then */
			continue;
		    }
		    ndx = vol->index + fid*FSYS_MAX_ALTS + syn->alts;
		    qio->u_len = 512;
		    qio->sector = *ndx;		/* select new relative sector */
		    qio->buff = syn->input;	/* point to input buffer */
		    qio->state = 0;
		    ioq->private = (void *)qio;	/* cross connect these structs */
		    fsys_qread(ioq);		/* read the next alternate */
		    return;		    
		}
# endif
		fh = (FsysHeader *)syn->output;
		rfh = vol->files + fid;
		fh->id = fid == FSYS_INDEX_INDEX ? FSYS_ID_INDEX : FSYS_ID_HEADER;
		fh->type = rfh->directory ? FSYS_TYPE_DIR : FSYS_TYPE_FILE;
		fh->flags = 0;			/* not used at this time, but 0 it anyway */
# if (FSYS_FEATURES&FSYS_FEATURES_CMTIME)
#  if (FSYS_OPTIONS&FSYS_FEATURES_CMTIME)
		fh->ctime = rfh->ctime;
		fh->mtime = rfh->mtime;
#  else
		fh->ctime = fh->mtime = 0;	/* times not supported in this version */
#  endif
# endif
# if (FSYS_FEATURES&FSYS_FEATURES_ABTIME)
#  if (FSYS_OPTIONS&FSYS_FEATURES_ABTIME)
		fh->atime = rfh->atime;
		fh->btime = rfh->btime;
#  else
		fh->atime = fh->btime = 0;
#  endif
# endif
		fh->generation = rfh->generation;
		fh->size = rfh->size;
		fh->clusters = rfh->clusters;
# if (FSYS_FEATURES&FSYS_OPTIONS&FSYS_FEATURES_PERMS)
		fh->perms = rfh->perms;
		fh->owner = rfh->owner;
# endif
		for (alts=0; alts < FSYS_MAX_ALTS; ++alts) {
		    src = rfh->ramrp + alts;
		    dst = fh->pointers[alts];
		    for (ii=0; ii < FSYS_MAX_FHPTRS;) {
			int lim;
			lim = FSYS_MAX_FHPTRS - ii;
			if (lim > src->num_rptrs) lim = src->num_rptrs;
			memcpy((char *)dst, (char *)src->rptrs, lim*sizeof(FsysRetPtr));
# if !FSYS_READ_ONLY
			ii += lim;
			dst += lim;			
			if (ii < FSYS_MAX_FHPTRS && !src->next) {
			    lim = FSYS_MAX_FHPTRS - ii;
			    memset((char *)dst, 0, lim*sizeof(FsysRetPtr));
			    break;
			}
			src = src->next;
# else
			break;
# endif
		    }				/* -- for FSYS_MAX_FHPTRS */
		}				/* -- for FSYS_MAX_ALTS */
		ndx = vol->index + fid*FSYS_MAX_ALTS + syn->alts;
		syn->state = SYNC_WRITE_FH;
		qio->ramrp = &syn->ramrp;	/* point to fake retrieval pointer */
		qio->u_len = 512;
		qio->buff = (U8*)syn->output;	/* point to output buffer */
		qio->state = 0;
		qio->sector = *ndx;
		SYNSQK(( OUTWHERE "%6d: sync, FH upd: Queuing write %d. u_len=%d, sector=%d\n",
	    		eer_rtc, syn->alts, qio->u_len, qio->sector));
		fsys_qwrite(ioq);
		return;
	    }

	    case SYNC_WRITE_FH: {
		if (QIO_ERR_CODE(ioq->iostatus)) { /* All we can do is log write errors */
		    syn->errlog[syn->err_in++] = ioq->iostatus;
		    if (syn->err_in > n_elts(syn->errlog)) syn->err_in = 0;
		    ++syn->errcnt;
		}
		++syn->substate;		/* next fid */
		syn->state = SYNC_WALK_DIRTY;	/* back to top of loop */
		continue;
	    }		/* -- case SYNC_WRITE_FH */

# if !FSYS_READ_ONLY
	    case SYNC_UPD_INDEX: {
		unsigned long bit, *bp;
		int elem, sects, sects_bytes, start, start_bytes;
		int nelems, len;
		unsigned long *bits;

		nelems = vol->index_bits_elems;
		bits   = vol->index_bits;
#if FSYS_SYNC_SQUAWKING
		if (!syn->substate && !syn->alts) {
		    int ii;
		    SYNSQK(( OUTWHERE "%6d: sync: UPD_INDEX: nelms=%d, bits = %08lX\n",
			eer_rtc, nelems, bits));
		    for (ii=0; ii < nelems; ++ii) {
			SYNSQK(( OUTWHERE "             Bits[%2d]: %08lX\n", ii, bits[ii]));
		    }
		}
#endif
		if (!nelems || !bits) {
		    syn->state = SYNC_UPD_FREE;
		    continue;
		}
		elem = syn->substate/32;
		bit = syn->substate&31;
		bp = bits + elem;
		while (elem < nelems && !*bp) {
		    ++bp;
		    ++elem;
		    bit = 0;
		    syn->substate = (syn->substate & ~31) + 32;
		}
		if (elem >= nelems) {
		    syn->substate = 0;
		    syn->state = SYNC_UPD_FREE;
		    continue;
		}
		while (bit < 32 && !(*bp & (1<<bit))) { ++bit; }
		if (bit >= 32) {
		    syn->substate = (syn->substate & ~31) + 32;
		    continue;
		}
		start = elem*32 + bit;		/* relative starting sector */
		elem = (start+1)/32;		/* next element */
		bit = (start+1)&31;		/* next bit */
		bp = bits + elem;
		sects = 0;
		do {
		    if (elem >= nelems) {
			sects = elem*32 - start;
			break;
		    }
		    while (bit < 32 && (*bp & (1<<bit))) { ++bit; }
		    if (bit < 30 && ( (*bp & (1<<(bit+1))) || (*bp & (1<<(bit+2))) ) ) {
			bit += 3;
			continue;
		    } else if (bit < 31 && (*bp & (1<<(bit+1))) ) {
			bit += 2;
			continue;
		    }
		    if (bit >= 32) {
			++elem;
			++bp;
			bit = 0;
			continue;
		    }
		    sects = elem*32 + bit - start;
		} while (!sects);
		start_bytes = start*512;
		len = syn->buffer_size/512;
		if (sects > len) sects = len;
		sects_bytes = sects*512;
    		syn->substate = start + sects;	/* advance substate for next time */
		memcpy((char *)syn->output, (char *)(vol->index)+start_bytes, sects_bytes);
		len = vol->files_ffree*FSYS_MAX_ALTS*sizeof(U32); /* length of index file */
		if (start_bytes+sects_bytes > len) {
		    len -= start_bytes;
		    if (len > 0) {
			memset((char *)syn->output+len, 0, sects_bytes-len);
		    }
		}
		syn->state = SYNC_INDEX_WRCOMPL;
		qio->ramrp = (vol->files+FSYS_INDEX_INDEX)->ramrp + syn->alts; /* point to first retrieval pointer set */
		syn->sects = sects;		/* number of sectors to write */
		qio->u_len = sects_bytes;
		qio->buff = (U8*)syn->output;	/* point to output buffer */
		qio->state = 0;
		qio->sector = syn->start = start;
		SYNSQK(( OUTWHERE "%6d: sync, INDEX upd: Queuing write %d. u_len=%d, sector=%d\n",
	    		eer_rtc, syn->alts, qio->u_len, start));
		fsys_qwrite(ioq);
		return;
	    }

	    case SYNC_INDEX_WRCOMPL:
		if (QIO_ERR_CODE(ioq->iostatus)) { /* All we can do is log write errors */
#  if FSYS_FREE_SQUAWKING || FSYS_SQUAWKING
#   ifndef AN_VIS_COL
#    define AN_VIS_COL 132
#   endif
		    char emsg[AN_VIS_COL];
		    qio_errmsg(ioq->iostatus, emsg, sizeof(emsg));
		    FSYS_SQK((OUTWHERE "%6d: sync error writing INDEX %d. u_len=%d, sector=%d\n",
			    eer_rtc, syn->alts, qio->u_len, syn->start));
		    FSYS_SQK((OUTWHERE "        Reason: \"%s\"\n", emsg));
#  endif
		    syn->errlog[syn->err_in++] = ioq->iostatus;
		    if (syn->err_in > n_elts(syn->errlog)) syn->err_in = 0;
		    ++syn->errcnt;
		}
		syn->state = SYNC_UPD_INDEX;
		continue;

	    case SYNC_UPD_FREE:
#  if 0
		if (vol->free_start >= vol->free_ffree) {
		    syn->state = SYNC_DONE;
		    continue;
		}
#  endif
#  if FSYS_FREE_SQUAWKING || FSYS_SQUAWKING
		{
		    FsysRetPtr *rp;
		    rp = vol->free;
		    FSYS_SQK((OUTWHERE "%6d: sync_upd_free: %d entries\n", eer_rtc, vol->free_ffree));
		    for (ii=0; ii < vol->free_ffree; ++ii, ++rp) {
			FSYS_SQK((OUTWHERE "        %3d: start=%7d, nblocks=%6d\n",
				ii, rp->start, rp->nblocks));
		    }
		}
#  endif
		syn->state = SYNC_FREE_WRCOMPL;
    		syn->start = 0; 
		syn->sects = (vol->free_ffree*sizeof(FsysRetPtr) + 511)/512; 
		qio->ramrp = (vol->files+FSYS_INDEX_FREE)->ramrp+syn->alts; /* point to first retrieval pointer set */
		qio->u_len = syn->sects*512;
		qio->buff = (U8*)vol->free;
		qio->state = 0;
		qio->sector = syn->start;
		SYNSQK(( OUTWHERE "%6d: sync, FREE upd: Queuing write %d. u_len=%d, sector=%d\n",
	    		eer_rtc, syn->alts, qio->u_len, syn->start));
		fsys_qwrite(ioq);
		return;

	    case SYNC_FREE_WRCOMPL:
		if (QIO_ERR_CODE(ioq->iostatus)) { /* All we can do is log write errors */
#  if FSYS_FREE_SQUAWKING || FSYS_SQUAWKING
		    char emsg[AN_VIS_COL];
		    qio_errmsg(ioq->iostatus, emsg, sizeof(emsg));
		    FSYS_SQK((OUTWHERE "%6d: sync error writing FREE %d. u_len=%d, sector=%d\n",
			    eer_rtc, syn->alts, qio->u_len, syn->start));
		    FSYS_SQK((OUTWHERE "        Reason: \"%s\"\n", emsg));
#  endif
		    syn->errlog[syn->err_in++] = ioq->iostatus;
		    if (syn->err_in > n_elts(syn->errlog)) syn->err_in = 0;
		    ++syn->errcnt;
		}
		if (++syn->alts < FSYS_MAX_ALTS) {
		    syn->state = SYNC_UPD_INDEX;
		} else {
		    syn->state = SYNC_DONE;
		}
		continue;

# endif
	    case SYNC_DONE:
# if !FSYS_READ_ONLY
		if (vol->index_bits) memset((char *)vol->index_bits, 0, vol->index_bits_elems*sizeof(long));
		vol->free_start = INT_MAX;
# endif
		vol->dirty_ffree = 0;
		SYNSQK(( OUTWHERE "%6d: Sync done\n", eer_rtc));
		break;
	}		/* -- switch sync->state */
	break;
    }			/* -- while forever */

    ii = syn->busy;				/* save this for later */
    syn->busy = 0;				/* not busy anymore */
    syn->state = SYNC_BEGIN;			/* reset ourself */
    if (!syn->status) syn->status = FSYS_SYNC_SUCC|SEVERITY_INFO;
    sts = qio_freemutex(&vol->mutex, ioq);	/* done with the mutex */
    if (sts || syn->status != (FSYS_SYNC_SUCC|SEVERITY_INFO)) {
	syn->errlog[syn->err_in++] = sts ? sts : syn->status;
	if (syn->err_in > n_elts(syn->errlog)) syn->err_in = 0;
	++syn->errcnt;
    }
#if 0 && defined(IO_MAIN_LED_ON) && defined(IO_MAIN_CTL_T)
    IO_MAIN_CTL_T &= ~IO_MAIN_LED_ON;
#endif
    return;
}

static int fsys_sync(FsysSyncT *f, int how) {
    FsysVolume *vol;
    int sts = 0, oldipl;

    vol = f->vol;
    oldipl = prc_set_ipl(INTS_OFF);
    if (!f->busy && vol->dirty_ffree) {	/* if it not already running and there is something to do */
	f->busy = how;			/* say it is busy */
	prc_set_ipl(oldipl);
	SYNSQK(( OUTWHERE "%6d: sync: started. getting volume mutex\n", eer_rtc));
#if 0 && defined(IO_MAIN_LED_ON) && defined(IO_MAIN_CTL_T)
	IO_MAIN_CTL_T |= IO_MAIN_LED_ON;
#endif
	sts = qio_getmutex(&vol->mutex, fsys_sync_q, (QioIOQ *)f);
	if (sts) {
	    f->errlog[f->err_in++] = sts;
	    ++f->errcnt;
	    if (f->err_in >= n_elts(f->errlog)) f->err_in = 0;
	}
    	return sts;
    }
    prc_set_ipl(oldipl);
    SYNSQK(( OUTWHERE "%6d: sync: busy=%d, dirty_ffree=%d. Back to waiting\n",
		eer_rtc, f->busy, vol->dirty_ffree));
    return -1;
}

static int fsys_sync_time;

static void fsys_sync_t(QioIOQ *ioq) {
    FsysVolume *vol;
    FsysSyncT *f;

    f = (FsysSyncT *)ioq;
    vol = f->vol;
    fsys_sync(f, FSYS_SYNC_BUSY_TIMER);
    f->sync_t.delta = fsys_sync_time ? fsys_sync_time : FSYS_SYNC_TIMER; /* requeue the sync timer */
    tq_ins(&f->sync_t);
    return;
}

int fsys_sync_delay(int new) {
    int old, ii, oldps;
    FsysVolume *vol;

    oldps = prc_set_ipl(INTS_OFF);
    old = fsys_sync_time ? fsys_sync_time : FSYS_SYNC_TIMER;
    fsys_sync_time = new ? new : FSYS_SYNC_TIMER;
    vol = volumes;
    for (ii=0; ii < FSYS_MAX_VOLUMES; ++ii, ++vol) {
	struct tq *tq;
	tq = &vol->sync_work.sync_t;
	if (tq->que) {
	    tq_del(tq);
	    tq->delta = fsys_sync_time;
	    tq_ins(tq);
	    prc_set_ipl(oldps);
	    fsys_sync(&vol->sync_work, 0);	/* force a sync */
	    prc_set_ipl(INTS_OFF);
	}
    }
    prc_set_ipl(oldps);
    return old;
}

static int fsys_fsync( QioIOQ *ioq ) {
    FsysVolume *vol;

    if (!ioq) return QIO_INVARG;
    vol = fsys_get_volume(ioq->file);
    qio_freefile(qio_fd2file(ioq->file)); /* done with the file descriptor */
    ioq->file = -1;
    if (!vol) return (ioq->iostatus = FSYS_SYNC_NOMNT);
    fsys_sync(&vol->sync_work, FSYS_SYNC_BUSY_NONTIMER);
    ioq->iostatus = FSYS_SYNC_SUCC|SEVERITY_INFO;	/* never report a sync error */
    return 0;
}
#endif

enum mount_e {
    MOUNT_BEGIN,
    MOUNT_RD_HOME,
    MOUNT_CK_HOME,
    MOUNT_RD_HOME2,
    MOUNT_SEARCH_HOME,
    MOUNT_RD_FH,
    MOUNT_PROC_FH,
    MOUNT_RD_FILE,
    MOUNT_PROC_FILE
};

/*****************************************************************
 * fsys_qmount() - mount a volume. This function performs the steps necessary to
 * read the home blocks, index.sys, freemap.sys and directory files. It
 * places portions of those files into the 'volumes' array described above.
 * This routine is expected to run entirely as an AST function.
 *
 * At entry:
 *	vol - pointer to element in volumes array to which to mount.
 * At exit:
 *	returns nothing. 
 */
void fsys_qmount(QioIOQ *ioq) {
    FsysQio *qio;
    FsysHomeBlock *hb;
    FsysHeader *hdr;
    FsysRamFH *rfh;
    FsysRamRP *rrp;
    FsysVolume *vol;
    int ii, sts;
    unsigned long *ulp;

    vol = (FsysVolume *)ioq;
    qio = (FsysQio *)ioq;
    while (1) {
	switch (vol->state) {			/* next? */
	    default:			/* Better never get here */
		ioq = qio->callers_ioq;
		vol->state = MOUNT_BEGIN;
		ioq->iostatus = vol->status = FSYS_MOUNT_FATAL;
		qio_complete(ioq);
		return;
/*****************************************************************************
 * First we init some variables, grab the mutex and switch to AST level.
 */
	    case MOUNT_BEGIN: {			/* setup to read home blocks */
		struct act_q *q;
#if !FSYS_READ_ONLY || FSYS_UPD_FH
		struct tq *qt;
		FsysSyncT *sw;

		sw = &vol->sync_work;
		qt = &sw->sync_t;
		qt->func = (void (*)(void *))fsys_sync_t;
		qt->vars = (void *)sw;
		sw->vol = vol;
#endif
		if (!vol->buff) {
		    vol->buff_size = 512;
		    vol->buff = (U32*)QMOUNT_ALLOC(vol, 512);	/* get a temporary sector buffer */
		    if (!vol->buff) {
			vol->status = FSYS_MOUNT_NOMEM;
			goto clean_up;
		    }
		}
		vol->substate = 0;		/* substate */
		vol->status = 0;		/* start with no status */
		vol->files_indx = 0;		/* start at index file */
		/* build a dummy retrieval pointer to get file headers... */
		vol->tmprp.start = 0;		/* "file header"'s are found in a a pseudo file starting at 0 */
		vol->tmprp.nblocks = vol->maxlba; /* ...and comprising the whole disk */
#if (FSYS_OPTIONS&FSYS_FEATURES&FSYS_FEATURES_SKIP_REPEAT)
		vol->tmprp.repeat = 1;
		vol->tmprp.skip = 0;
#endif
		vol->tmpramrp.rptrs = &vol->tmprp;
		vol->tmpramrp.num_rptrs = 1;
#if !FSYS_READ_ONLY
		vol->tmpramrp.next = 0;
		vol->tmpramrp.rptrs_size = 1;
#endif
		qio->ramrp = &vol->tmpramrp;	/* init the reader stuff */
		qio->u_len = 512;
		qio->buff = (U8*)vol->buff;	/* into our buffer */
		qio->compl = fsys_qmount;	/* come back to us when done */
		q = &vol->tmpq;
		q->action = (void (*)(void *))fsys_qmount;
		q->param = (void *)ioq;
		q->next = q->que = 0;
		vol->state = MOUNT_RD_HOME;	/* switch to next state */
		vol->total_free_clusters = 0;
		vol->total_alloc_clusters = 1 + FSYS_MAX_ALTS;
		sts = qio_getmutex(&vol->mutex, fsys_qmount, ioq);
		if (sts) {
		    vol->status = sts;
		    goto clean_up;
		}
		return;
	    }

/*****************************************************************************
 * Loop however many times it takes to read a home block without error or until
 * all the home blocks have been tried. If it cannot find a home block where one
 * is expected, it reads every 256'th sector (+1, skipping sector 1) looking for
 * a sector that it recognizes as a home block. The read procedure hops back and
 * forth between states MOUNT_RD_HOME, MOUNT_CK_HOME and MOUNT_SEARCH_HOME until
 * a home block is successfully read.
 */
	    case MOUNT_RD_HOME: 		/* loop reading home blocks until a good one is found */
		qio->sector = FSYS_HB_ALG(vol->substate, FSYS_HB_RANGE); /* relative sector number */
		qio->u_len = 512;
		qio->buff = (U8*)vol->buff;	/* into our buffer */
		vol->state = MOUNT_CK_HOME;
		fsys_qread(ioq);
		return;				/* wait for I/O to complete */

	    case MOUNT_RD_HOME2: 		/* loop reading home blocks until a good one is found */
		qio->sector = FSYS_HB_ALG(vol->substate-FSYS_MAX_ALTS, vol->maxlba); /* relative sector number */
		qio->u_len = 512;
		qio->buff = (U8*)vol->buff;	/* into our buffer */
		vol->state = MOUNT_CK_HOME;
		fsys_qread(ioq);
		return;				/* wait for I/O to complete */

	    case MOUNT_CK_HOME: {
		unsigned long cs;
		hb = (FsysHomeBlock *)vol->buff;
		ulp = vol->buff;
		for (cs=0, ii=0; ii < 128; ++ii) cs += *ulp++; /* checksum the home block */
		if (cs || 			/* checksum is expected to be 0 */
		    QIO_ERR_CODE(ioq->iostatus) ||	/* no errors are expected or accepted */
		    hb->id != FSYS_ID_HOME) {	/* block is wrong kind */
		    ++vol->substate;
		    if (vol->substate < FSYS_MAX_ALTS) {
			vol->state = MOUNT_RD_HOME; /* first 3 tries are normal */
			continue;
		    }
		    if (vol->substate < FSYS_MAX_ALTS*2) {
			vol->state = MOUNT_RD_HOME2; /* second 3 tries are old method */
			continue;
		    }
		    vol->state = MOUNT_SEARCH_HOME; /* try alternate home block addrs */
		    continue;
		}
		if (vol->substate > 0) USED_ALT();
		for (ii=0; ii < FSYS_MAX_ALTS; ++ii) {
		    vol->index_lbas[ii] = hb->index[ii];	/* remember lba's for index file */
		}
		if (hb->max_lba) vol->maxlba = hb->max_lba;	/* adjust our maxlba from value in home block */
		vol->substate = 0;
		vol->state = MOUNT_RD_FH;		/* goto to next state */
		continue;
	    }

	    case MOUNT_SEARCH_HOME: {
		int nxt;
		nxt = (vol->substate-FSYS_MAX_ALTS*2+1)*256 + 1;
		if (nxt >= vol->maxlba) {
		    vol->status = FSYS_MOUNT_NOHBLK ;	/* could not read any of the home blocks */
clean_up:
#if FSYS_UMOUNT
		    qmount_freeall(vol);
#endif
		    vol->files = 0;
		    vol->files_elems = vol->files_ffree = 0;
		    vol->buff = 0;
		    vol->index = 0;
		    vol->free = 0;
		    vol->free_ffree = vol->free_elems = 0;
		    vol->state = MOUNT_BEGIN;
		    qio_freemutex(&vol->mutex, ioq);
		    ioq = qio->callers_ioq;
		    ioq->iostatus = vol->status;
		    qio_complete(ioq);
		    return;
		}
		qio->sector = nxt;		/* relative sector number */
		qio->u_len = 512;
		qio->buff = (U8*)vol->buff;	/* into our buffer */
		vol->state = MOUNT_CK_HOME;
		fsys_qread(ioq);
		return;				/* wait for I/O to complete */
	    }

/*****************************************************************************
 * The home block has the LBA's to find the file header(s) for the index file.
 *
 * The next step is to read all the file headers on the disk starting with the
 * index file. As file headers are read, their contents are stuffed into a
 * 'malloc'd FsysRamFH struct. The FsysRamFH structs are maintained as a linear
 * array, one element per file, the 'array index' of which matches the file's
 * position in the index file (its FID). This allows one to access both the pointer
 * to the LBA's in the index file and the ram copies of the file header with the
 * file's FID. 
 *
 * The read procedure hops back and forth between states MOUNT_RD_FH and MOUNT_PROC_FH
 * until a file header is read successfully. At this time, an unrecoverable error
 * reading a file header is fatal.
 */
	    case MOUNT_RD_FH: {
		int bad, ii;
		unsigned long sect;

		if (vol->files_indx == FSYS_INDEX_INDEX) {	/* reading index file header */
		    ulp = vol->index_lbas;		/* lba's are in a special spot while reading index.sys */
		} else {
		    if (vol->files_indx >= vol->files_ffree) {	/* if we've reached the end */
			break;				/* we're done with all I/O */
		    }
		    ulp = vol->index + vol->files_indx*FSYS_MAX_ALTS; /* any other file header */
		}
		if (!vol->substate) {			/* on the first pass of a file header read */
		    unsigned long *p;
		    bad = 0;
		    p = ulp;
		    for (ii=0; ii < FSYS_MAX_ALTS; ++ii, ++p) { /* check to see if any of them are bad */
			sect = *p;
			if (!sect || (!(sect&0x80000000) && sect >= vol->maxlba)) {	/* if value is illegal */
			    sect = ii ? 0x80000000 : 0x80000001; /* record it as unused */
			}
			if ((sect&0x80000000)) {		/* if unused */
#if !FSYS_READ_ONLY
			    if (!ii) {			/* and the first one */
				add_to_unused(vol, vol->files_indx);
			    }
#endif
			    ++bad;			/* record a bad index */
			}
			if (bad) {
			    *p = sect;			/* replace with unused flag */
			}
		    }
		    if (bad >= FSYS_MAX_ALTS) {		/* if all are bad */
			if (vol->files_indx <= FSYS_INDEX_ROOT) {
			    if (vol->files_indx == FSYS_INDEX_INDEX) {
				vol->status = FSYS_MOUNT_NOINDX;
			    } else if (vol->files_indx == FSYS_INDEX_FREE) {
				vol->status = FSYS_MOUNT_NOFREE;
			    } else {
				vol->status = FSYS_MOUNT_NOROOT;
			    }
			    goto clean_up;		/* can't continue */
			}
			++vol->files_indx;		/* skip this fileheader */
			continue;			/* loop */
		    }
		}
		while (vol->substate < FSYS_MAX_ALTS) {
		    qio->sector = ulp[vol->substate++];
		    qio->ramrp = &vol->tmpramrp;	/* init the reader stuff */
		    qio->u_len = 512;
		    qio->buff = (U8*)vol->buff;		/* into our local header buffer */
		    vol->state = MOUNT_PROC_FH;
		    fsys_qread(ioq);			/* read the next copy of file header */
		    return;
		}		
		vol->status = FSYS_MOUNT_FHRDERR;	/* for now, an unreadable header is fatal */
		goto clean_up;
	    }

	    case MOUNT_PROC_FH: {		/* process the file header */
		unsigned long id;
		hdr = (FsysHeader *)vol->buff;
		id = (vol->files_indx == FSYS_INDEX_INDEX) ? FSYS_ID_INDEX : FSYS_ID_HEADER;
		if (QIO_ERR_CODE(ioq->iostatus) || 	/* can't have any input errors */
		    hdr->id != id) {		/* and the id needs to be the correct type */
		    vol->state = MOUNT_RD_FH;	/* try to read the next one */
		    continue;
		}
		if (vol->substate > 1) USED_ALT();
		if (vol->files_indx == FSYS_INDEX_INDEX) { /* index file is done first */
		    ii = hdr->size/(FSYS_MAX_ALTS*sizeof(long));
		    vol->files_ffree = ii;		/* point to end of active list */
#if !FSYS_READ_ONLY 
# if !FSYS_TIGHT_MEM
		    ii += 512;			/* allow easy "growth" of 512 files */
# else
		    ii += 32;			/* allow easy "growth" of 32 files */
# endif
#endif
		    vol->files = (FsysRamFH *)QMOUNT_ALLOC(vol, ii*sizeof(FsysRamFH));
#if !FSYS_READ_ONLY
		    if (!vol->files) {
# if !FSYS_TIGHT_MEM
			ii -= 512-16;		/* running tight on space, try something smaller */
# else
			ii -= 32-4;		/* running tight on space, try something smaller */
# endif
			vol->files = (FsysRamFH *)QMOUNT_ALLOC(vol, ii*sizeof(FsysRamFH));
		    }		
#endif
		    if (!vol->files) {
			vol->status = FSYS_MOUNT_NOMEM;	/* ran out of memory */
			goto clean_up;
		    }
		    vol->files_elems = ii;		/* total available elements */
		    vol->index = (U32*)QMOUNT_ALLOC(vol,
    				(ii*FSYS_MAX_ALTS*sizeof(long)+511)&-512); /* room to read the whole index file */
		    if (!vol->index) {
			vol->status = FSYS_MOUNT_NOMEM;
			goto clean_up;
		    }
		    vol->contents = vol->index;
#if FSYS_TIGHT_MEM
		    vol->rp_pool = (FsysRetPtr *)QMOUNT_ALLOC(vol, FSYS_MAX_ALTS*ii*sizeof(FsysRetPtr));
		    if (vol->rp_pool) vol->rp_pool_size = ii;
#endif
		} else if (vol->files_indx == FSYS_INDEX_FREE) {
#if !FSYS_READ_ONLY
		    vol->free_elems = ((hdr->size+1023)&-512)/sizeof(FsysRetPtr);
#else
		    vol->free_elems = ((hdr->size+511)&-512)/sizeof(FsysRetPtr);
#endif
		    vol->free = (FsysRetPtr *)QMOUNT_ALLOC(vol,
			    (vol->free_elems*sizeof(FsysRetPtr)+511)&-512); /* room to read the whole file */
		    if (!vol->free) {
			vol->status = FSYS_MOUNT_NOMEM;
			goto clean_up;
		    }
		    vol->contents = (unsigned long *)vol->free;
		} 
		vol->rw_amt = (hdr->size+511)&-512;
		rfh = vol->files + vol->files_indx;
		if (mk_ramfh(vol, rfh)) goto clean_up;
		if (vol->files_indx <= FSYS_INDEX_FREE) {
		    rfh->def_extend = FSYS_DEFAULT_DIR_EXTEND;
		}
		if (vol->files_indx > FSYS_INDEX_FREE && hdr->type != FSYS_TYPE_DIR) {
		    ++vol->files_indx;
		    vol->substate = 0;
		    vol->state = MOUNT_RD_FH;		/* read the next file header */
		    continue;				/* loop */
		}
		if (hdr->type == FSYS_TYPE_DIR) {
		    int need;
		    need = (hdr->size+511)&-512;
		    if (!need) {			/* empty directory!!!! This is a bug */
			++vol->files_indx;		/* so skip it. */
			vol->substate = 0;
			vol->state = MOUNT_RD_FH;	/* read the next file header */
			continue;			/* loop */
		    }			
		    if (vol->buff_size < need) {
			U32 *bp;
			vol->buff_size = need;
			bp = (U32*)QMOUNT_REALLOC(vol, (void *)vol->buff, vol->buff_size); /* give back old buffer */
			if (!bp) {
			    vol->status = FSYS_MOUNT_NOMEM;
			    goto clean_up;
			}
			vol->buff = bp;
		    }
		    vol->contents = vol->buff;
		}
		vol->state = MOUNT_RD_FILE;	/* next state */
		vol->substate = 0;		/* substate */
		continue;
	    }

/*****************************************************************************
 * The file header has been read. If it is a type INDEX, FREEMAP or DIRECTORY,
 * the contents need to be obtained. The read procedure hops between states MOUNT_RD_FILE
 * and MOUNT_PROC_FILE until the contents are successfully obtained. Note that these three
 * types of files are always duplicated FSYS_MAX_ALTS times on the disk.
 *
 * At this time, an unrecoverable error reading the contents of one of these
 * files is fatal.
 */
	    case MOUNT_RD_FILE: 		/* loop reading files until a good one is found */
		rfh = vol->files + vol->files_indx;
		while (vol->substate < FSYS_MAX_ALTS) {
		    rrp = rfh->ramrp + vol->substate++;
		    if (!rrp->num_rptrs) continue;
		    qio->ramrp = rrp;
		    qio->sector = 0;		/* read file starting at relative sector 0 */
		    qio->u_len = vol->rw_amt;
		    qio->buff = (U8*)vol->contents;
		    vol->state = MOUNT_PROC_FILE;
		    fsys_qread(ioq);		/* read the whole damn file at once */
		    return;				/* wait for I/O to complete */
		}		
		vol->status = FSYS_MOUNT_RDERR;	/* for now, an unreadable file is fatal */
		goto clean_up;

	    case MOUNT_PROC_FILE: 
		if (QIO_ERR_CODE(ioq->iostatus)) {	/* can't have any input errors */
		    vol->state = MOUNT_RD_FILE; /* try to read the alternates */
		    continue;
		}

		if (vol->files_indx == FSYS_INDEX_INDEX) {
		    U32 *ulp;
		    int jj, bad=0;
		    ulp = (U32 *)vol->contents;
		    for (jj=0; jj < FSYS_MAX_ALTS; ++jj) {
			if (!jj && vol->index_lbas[jj] != ulp[jj]) {
			    ++bad;
			    continue;
			}
			if (!(vol->index_lbas[jj]&0x80000000) &&
				ulp[0] != vol->index_lbas[0]) {
			    ++bad;
			    continue;
			}
		    }
		    if (bad) {
			vol->state = MOUNT_RD_FILE;	/* doesn't match, reject it */
			continue;
		    }
		}

		if (vol->substate > 1) USED_ALT();
/*
 * If the file is of type DIRECTORY, a FsysDir struct is created for it and its
 * contents copied into that struct.
 */
		if (vol->files_indx > FSYS_INDEX_FREE) {	/* Not index or free, so has to be dir */
		    if (mk_ramdir(vol)) goto clean_up;	/* create a directory for it */
		}
		++vol->files_indx;
		vol->state = MOUNT_RD_FH;	/* read the next file */
		vol->substate = 0;
		continue;
	}				/* -- switch state */
	break;
    }					/* -- while forever */
#if !FSYS_READ_ONLY || FSYS_UPD_FH
    vol->sync_work.sync_t.delta = FSYS_SYNC_TIMER;
    tq_ins(&vol->sync_work.sync_t);	/* start a sync timer */
#endif
    QIOfree(vol->buff);			/* done with this buffer */
    vol->total_free_clusters = compute_total_free(vol);
    vol->buff = 0;
    vol->state = MOUNT_BEGIN;		/* done */
    vol->status = FSYS_MOUNT_SUCC|SEVERITY_INFO; /* mounted with success */
#if !FSYS_READ_ONLY
    vol->free_start = INT_MAX;		/* start it at max */
#endif
    sts = qio_freemutex(&vol->mutex, ioq);
    ioq = qio->callers_ioq;
    ioq->iostatus = vol->status;
    qio_complete(ioq);
    return;
}

#if KICK_THE_DOG
static void kick_the_dog(void *arg) {
    struct tq *tq;

    WDOG = 0;			/* kick the dog */
    tq = (struct tq *)arg;
    tq->delta = 500000;		/* 500,000 usecs or 0.5 secs */
    tq_ins(tq);			/* requeue ourself */
}
#endif
    
extern void ide_squawk(int row, int col);
extern void ide_unsquawk(void);

/*****************************************************************
 * fsys_mountw() - mount a volume and wait for completion. 
 *
 * At entry:
 *	where - null terminated string with name of physical device 
 *	what - null terminated string with name of virtual device
 *
 * At exit:
 *	returns  0 if volume is successfully mounted.
 *	returns  FSYS_MOUNT_xxx if other errors.
 */

int fsys_mountw(const char *where, const char *what) {
    FsysVolume *vol;
    const QioDevice *d;
    QioIOQ *ioq, *fioq;
    int sts;
    struct stat fs;
#if KICK_THE_DOG
    struct tq timer;
#endif
    
    if (prc_get_astlvl() >= 0) return FSYS_MOUNT_BADLVL;
    ide_init();				/* make sure drive is init'd */
    d = qio_lookupdvc(what);		/* see if our mount point is installed */
    if (!d) return FSYS_MOUNT_NSV;	/* no such volume */
    vol = (FsysVolume *)d->private;	/* get ptr to our volume */
    if (!vol) return FSYS_MOUNT_FATAL;
    if (vol->state) return FSYS_MOUNT_BUSY; /* volume is already mounting */
    if (vol->files) return FSYS_MOUNT_MOUNTED;	/* volume is already mounted */
#if KICK_THE_DOG
    timer.next = timer.que = 0;
    timer.func = kick_the_dog;
    timer.vars = (void *)&timer;
    timer.delta = 500000;
    tq_ins(&timer);
#endif
    ioq = qio_getioq();			/* get an IOQ struct */
    ioq->timeout = 5000000;
    sts = qio_open(ioq, where, O_RDWR);
    while (!sts) { sts = ioq->iostatus; }	/* wait for it */
    if (QIO_ERR_CODE(sts)) {
	qio_freeioq(ioq);
#if KICK_THE_DOG
	tq_del(&timer);
#endif
	return sts;			/* didn't work */
    }
    sts = qio_fstat(ioq, &fs);		/* get stats about the physical device */
    while (!sts) { sts = ioq->iostatus; }	/* wait for it */
    if (QIO_ERR_CODE(sts)) {
	int o;
	o = qio_close(ioq);
	while (!o) { o = ioq->iostatus; }
	qio_freeioq(ioq);
#if KICK_THE_DOG
	tq_del(&timer);
#endif
	return sts;			/* could not stat the physical device */
    }
    vol->iofd = ioq->file;		/* remember the FD we're to use */
    {
	U32 lim;
	lim = fs.st_size;		/* assume size of drive */
#if defined(FSYS_MAX_LBA) && FSYS_MAX_LBA
	if (FSYS_MAX_LBA < lim) lim = FSYS_MAX_LBA;
#endif
	lim = lim - (lim%FSYS_MAX_ALTS); /* make total a multiple of MAX_ALTS */
	vol->maxlba = lim;
    }
    vol->reader.callers_ioq = ioq;
    fioq = &vol->reader.our_ioq;
    fioq->file = ioq->file;
    ioq->iostatus = 0;
    ioq->iocount = 0;
    ioq->timeout = 10000000;		/* give 'em 10 seconds or so to mount */
    fsys_qmount(fioq);			/* queue the mount */
    while (!(sts=ioq->iostatus)) { ; }	/* wait for mount to complete */
    qio_freeioq(ioq);			/* we're done with the ioq */
#if KICK_THE_DOG
    tq_del(&timer);
#endif
    return sts;				/* return with whatever status was reported */
}

#if !FSYS_READ_ONLY
static void mk_freelist(FsysRetPtr *ilist, int nelts, int size) {
    int ii;
    unsigned long prev;
    FsysRetPtr *list = ilist;

    memset((char *)list, 0, nelts*sizeof(FsysRetPtr));
    prev = 1;				/* start allocating free blocks at 1 */
    for (ii=0; ii < FSYS_MAX_ALTS; ++ii) {
	int amt;
	unsigned long hb;

	hb = FSYS_HB_ALG(ii, FSYS_HB_RANGE);
	amt = hb - prev;
	FSYS_SQK(( OUTWHERE "mk_freelist: hb=%ld, amt=%ld, prev=%ld.\n",
    		hb, amt, prev));
	if (amt) {
	    list->start = prev;
	    list->nblocks = amt;
#if (FSYS_OPTIONS&FSYS_FEATURES&FSYS_FEATURES_SKIP_REPEAT)
	    list->repeat = 1;
	    list->skip = 0;
#endif
	    ++list;
	}
	prev = hb+1;
    }
    if (prev < size) {
	list->start = prev;
	list->nblocks = size-prev;
#if (FSYS_OPTIONS&FSYS_FEATURES&FSYS_FEATURES_SKIP_REPEAT)
	list->repeat = 1;
	list->skip = 0;
#endif
	++list;
    }
#if FSYS_SQUAWKING
    FSYS_SQK(( OUTWHERE "Dump of freelist:\n"));
    for (; ilist < list; ++ilist) {
	FSYS_SQK(( OUTWHERE "\tstart=%ld, nblock=%ld\n", ilist->start, ilist->nblocks));
    }
#endif
    return;
}

static int fsys_mkalloc( FsysFindFreeT *freet ) {
    int ii, alloc;

    alloc = freet->request;
    for (ii=0; ii < FSYS_MAX_FHPTRS; ++ii) {
	if (fsys_findfree( freet )) break; /* no more free space */
#if (FSYS_OPTIONS&FSYS_FEATURES&FSYS_FEATURES_SKIP_REPEAT)
# error You need to rewrite fsys_mkalloc and add repeat/skip support.
#endif
	alloc -= freet->reply->nblocks;
	if (alloc <= 0) break;
	freet->reply += 1;
    }
    return alloc;
}

typedef struct {
    FsysQio q;			/* !!! this absolutely needs to be the first member !!! */
    FsysInitVol *iv;
    struct act_q act;
    int state;
    int substate;
    int status;
    FsysHomeBlock *hb;
    FsysHeader ihdr, fhdr, rhdr;
    FsysRetPtr *fake_free;
    FsysRetPtr freep, tmprp;
    FsysRamRP ramrp;
    unsigned long *dir;
    unsigned long *index;
    unsigned long ilbas[FSYS_MAX_ALTS];
    unsigned long max_lba;
    int free_nelts;
} FsysFinit;

static void compute_home_blocks(FsysFinit *fin) {
    FsysHomeBlock *hb;
    FsysInitVol *iv;
    U32 *ips;
    int ii;
    unsigned long sa, *tmp;

    hb = fin->hb;
    ips = fin->ilbas;
    iv = fin->iv;
    hb->id = FSYS_ID_HOME;
    hb->hb_minor = FSYS_VERSION_HB_MINOR;
    hb->hb_major = FSYS_VERSION_HB_MAJOR;
    hb->hb_size = sizeof(FsysHomeBlock);
    hb->fh_minor = FSYS_VERSION_FH_MINOR;
    hb->fh_major = FSYS_VERSION_FH_MAJOR;
    hb->fh_size = sizeof(FsysHeader);
    hb->fh_ptrs = FSYS_MAX_FHPTRS;
#if (FSYS_FEATURES&FSYS_FEATURES_EXTENSION_HEADER)
    hb->efh_minor = FSYS_VERSION_EFH_MINOR;
    hb->efh_major = FSYS_VERSION_EFH_MAJOR;
    hb->efh_size = sizeof(FsysEHeader);
    hb->efh_ptrs = FSYS_MAX_EFHPTRS;
#else
    hb->efh_minor = 0;
    hb->efh_major = 0;
    hb->efh_size = 0;
    hb->efh_ptrs = 0;
#endif
    hb->rp_minor = FSYS_VERSION_RP_MINOR;
    hb->rp_major = FSYS_VERSION_RP_MAJOR;
    hb->rp_size = sizeof(FsysRetPtr);
    hb->cluster = FSYS_CLUSTER_SIZE;
    hb->maxalts = FSYS_MAX_ALTS;
    hb->atime = hb->ctime = hb->mtime = (unsigned long)time(0);
    hb->btime = 0;
    hb->options = FSYS_OPTIONS;
    hb->features = FSYS_FEATURES;
    for (ii=0; ii < FSYS_MAX_ALTS; ++ii) {
	hb->index[ii] = *ips++;
    }
    hb->max_lba = fin->max_lba;
    hb->def_extend = iv->def_extend;
    for (tmp=(unsigned long *)hb, sa=0, ii=0; ii < 512/4; ++ii) sa += *tmp++;
    hb->chksum = 0-sa;
    return;
}

enum init_e {
    INIT_BEGIN,
    INIT_MKFREE,
    INIT_WRITE_INDEX_FH,
    INIT_WRITE_INDEX,
    INIT_WRITE_FREE_FH,
    INIT_WRITE_FREE,
    INIT_WRITE_ROOT_FH,
    INIT_WRITE_ROOT,
    INIT_WRITE_HOME,
    INIT_NEXT_ALT
};

static void init_file_system(QioIOQ *ioq) {
    int ii, bcnt, sts=0;
    FsysFinit *fin;
    FsysInitVol *iv;
    unsigned long *indxp;

    fin = (FsysFinit *)ioq;
    iv = fin->iv;
    while (1) {
	switch (fin->state) {
	    case INIT_BEGIN: {
		QioIOQ *eioq;
		eioq = fin->q.callers_ioq;
		if (!iv) {
		    sts = FSYS_INITFS_NOIV;
initfs_error:
		    eioq->iostatus = fin->status = sts;
		    return;
		}
		if (iv->cluster != 1) {
		    sts = FSYS_INITFS_CLUSTERNOT1;
		    goto initfs_error;
		}
		if (iv->index_sectors + iv->free_sectors + iv->root_sectors >= fin->max_lba) {
		    sts = FSYS_INITFS_TOOMANYCLUST;
		    goto initfs_error;
		}
		if (!iv->cluster) iv->cluster = FSYS_CLUSTER_SIZE;
		if (!iv->free_sectors) iv->free_sectors = 50;
		if (!iv->index_sectors) iv->index_sectors = 50;
		if (!iv->root_sectors) iv->root_sectors = 10;
		if (!iv->def_extend) iv->def_extend = FSYS_DEFAULT_EXTEND;
		fin->fake_free = (FsysRetPtr *)QIOmalloc(iv->free_sectors*512);
		if (!fin->fake_free) {
		    sts = FSYS_INITFS_NOMEM;
		    goto initfs_error;
		}
		fin->free_nelts = (iv->free_sectors*512)/sizeof(FsysRetPtr);
		fin->index = (unsigned long *)QIOcalloc(iv->index_sectors*512, 1);	    
		if (!fin->index) {
		    QIOfree(fin->fake_free);
		    sts = FSYS_INITFS_NOMEM;
		    goto initfs_error;
		}
		fin->dir = (unsigned long *)QIOcalloc(iv->root_sectors*512, 1);
		if (!fin->dir) {
		    QIOfree(fin->fake_free);
		    QIOfree(fin->index);
		    sts = FSYS_INITFS_NOMEM;
		    goto initfs_error;
		}
		fin->hb = (FsysHomeBlock *)QIOcalloc(512, 1);
		if (!fin->hb) {
		    sts = FSYS_INITFS_NOMEM;
		    QIOfree(fin->fake_free);
		    QIOfree(fin->index);
		    QIOfree(fin->dir);
		    goto initfs_error;
		}
		fin->state = INIT_MKFREE;
		fin->act.action = (void (*)(void *))init_file_system;
		fin->act.param = (void *)ioq;
		prc_q_ast(QIO_ASTLVL, &fin->act);	/* jump to AST level */
		QIO_FIN_SHIM();
		return;
	    }

	    case INIT_MKFREE: {
		FsysFindFreeT freet;
		unsigned char *s;

		/* First create a free list that accounts for the holes caused by home blocks */
		mk_freelist(fin->fake_free, fin->free_nelts, fin->max_lba);	/* assume a n block filesystem */

		/* start an index.sys file */
		fsys_mkheader(&fin->ihdr, 1);	/* make an index file header */
		fin->ihdr.size = 3*FSYS_MAX_ALTS*sizeof(long);
		fin->ihdr.id = FSYS_ID_INDEX;
		fin->ihdr.type = FSYS_TYPE_INDEX;
		fsys_mkheader(&fin->fhdr, 1);	/* make a freemap file header */
		fsys_mkheader(&fin->rhdr, 1);	/* make a root file header */
		fin->rhdr.type = FSYS_TYPE_DIR;

		freet.skip = 0;
		freet.exact = 0;
		freet.actelts = FSYS_MAX_ALTS;
		freet.totelts = fin->free_nelts;	    	    
		freet.freelist = fin->fake_free;
		freet.hint = 0;

		for (sts=bcnt=0; bcnt < FSYS_MAX_ALTS; ++bcnt) {
		    /* get a free block for the index.sys file header */

		    freet.lo_limit = FSYS_COPY_ALG(bcnt, fin->max_lba);
		    freet.request = 1;
		    freet.reply = &fin->freep;
		    if (fsys_findfree( &freet )) { /* get a free block */
no_free:
			sts = FSYS_INITFS_NOFREE;
			break;
		    }
		    /* point index to itself */
		    indxp = fin->index+(FSYS_INDEX_INDEX*FSYS_MAX_ALTS);
		    indxp[bcnt] = fin->freep.start;

		    /* tell home block where index.sys's file header is */
		    fin->ilbas[bcnt] = fin->freep.start;

		    /* allocate some blocks for the index file itself */
		    fin->ihdr.clusters = freet.request = iv->index_sectors;
		    freet.reply = fin->ihdr.pointers[bcnt];
		    if (fsys_mkalloc( &freet )) goto no_free;

		    freet.request = 1;
		    freet.reply = &fin->freep;
		    /* get a free block for the freelist.sys file header */
		    if (fsys_findfree( &freet )) goto no_free;

		    /* point index file to freelist.sys's file header */
		    indxp = fin->index+(FSYS_INDEX_FREE*FSYS_MAX_ALTS);
		    indxp[bcnt] = fin->freep.start;
		    
		    /* allocate some blocks for the freelist file itself */
		    fin->fhdr.clusters = freet.request = iv->free_sectors;
		    freet.reply = fin->fhdr.pointers[bcnt];
		    if (fsys_mkalloc( &freet )) goto no_free;

		    freet.request = 1;
		    freet.reply = &fin->freep;
		    /* get a free block for the root directory file header */
		    if (fsys_findfree( &freet )) goto no_free;

		    /* point index file to root directory file */
		    indxp = fin->index+(FSYS_INDEX_ROOT*FSYS_MAX_ALTS);
		    indxp[bcnt] = fin->freep.start;
		    
		    /* create a file header for root directory and allocate some blocks for the file itself */
		    freet.request = iv->root_sectors;
		    fin->rhdr.clusters = freet.request = iv->root_sectors;
		    freet.reply = fin->rhdr.pointers[bcnt];
		    if (fsys_mkalloc( &freet )) goto no_free;

		}

		if (sts) break;

		compute_home_blocks(fin);

		s = (unsigned char *)fin->dir;
		*s++ = FSYS_INDEX_ROOT;		/* ".." points to parent */
		*s++ = FSYS_INDEX_ROOT>>8;
		*s++ = FSYS_INDEX_ROOT>>16;
		*s++ = 1;			/* parent's generation number starts a 1 */
		*s++ = 3;			/* string length (3) */
		*s++ = '.';			/* filename (..) */
		*s++ = '.';
		*s++ = 0;			/* null terminate the string */
		*s++ = FSYS_INDEX_ROOT;		/* "." points to ourself */
		*s++ = FSYS_INDEX_ROOT>>8;
		*s++ = FSYS_INDEX_ROOT>>16;
		*s++ = 1;			/* owner's generation number starts at 1 */
		*s++ = 2;			/* string length (2) */
		*s++ = '.';			/* filename */
		*s++ = 0;			/* null terminate the string */
		*s++ = 0;			/* index of 0 means end of list */
		*s++ = 0;
		*s++ = 0;
		fin->rhdr.size = s - (U8*)fin->dir;

		for (ii=0; ii < fin->free_nelts; ++ii) {
		    if (fin->fake_free[ii].start == 0 && fin->fake_free[ii].nblocks == 0) break;
		}
		fin->fhdr.size = (ii*sizeof(FsysRetPtr)+511)&-512;
		fin->substate = 0;
		fin->tmprp.start = 0;		/* whole disk starts at sector 0 */
		fin->tmprp.nblocks = fin->max_lba;	/* the whole damn disk is one file */
#if (FSYS_OPTIONS&FSYS_FEATURES&FSYS_FEATURES_SKIP_REPEAT)
		fin->tmprp.repeat = 1;
		fin->tmprp.skip = 0;
#endif
		fin->ramrp.rptrs = &fin->tmprp;
		fin->ramrp.num_rptrs = 1;
		fin->ramrp.next = 0;
		fin->ramrp.rptrs_size = 0;
		fin->q.ramrp = &fin->ramrp;
		fin->q.compl = init_file_system;
		fin->state = INIT_WRITE_HOME;
		continue;
	    }

	    case INIT_WRITE_HOME:
		/* write a home block */
		fin->ramrp.rptrs = &fin->tmprp;
		fin->q.buff = (U8*)fin->hb;
		fin->q.sector = FSYS_HB_ALG(fin->substate, FSYS_HB_RANGE);
		fin->q.u_len = 512;
		fin->state = INIT_WRITE_INDEX_FH;
		fsys_qwrite(ioq);
		return;

	    case INIT_WRITE_INDEX_FH:
		if (QIO_ERR_CODE(ioq->iostatus)) {
		    fin->status = FSYS_INITFS_BADHB;
		    break;
		}
		/* write the file header for index.sys */
		indxp = fin->index+(FSYS_INDEX_INDEX*FSYS_MAX_ALTS);
		fin->q.buff = (U8*)&fin->ihdr;
		fin->q.sector = indxp[fin->substate];
		fin->q.u_len = 512;
		fin->state = INIT_WRITE_INDEX;
		fsys_qwrite(ioq);
		return;

	    case INIT_WRITE_INDEX:
		if (QIO_ERR_CODE(ioq->iostatus)) {
		    fin->status = FSYS_INITFS_BADINDX;
		    break;
		}
		/* write the index.sys file */
		fin->ramrp.rptrs = fin->ihdr.pointers[fin->substate];
		fin->q.buff = (U8*)fin->index;
		fin->q.sector = 0;
		fin->q.u_len = iv->index_sectors*512;
		fin->state = INIT_WRITE_FREE_FH;
		fsys_qwrite(ioq);
		return;

	    case INIT_WRITE_FREE_FH:
		if (QIO_ERR_CODE(ioq->iostatus)) {
		    fin->status = FSYS_INITFS_BADINDXF;
		    break;
		}
		/* write the file header for freelist.sys */
		fin->ramrp.rptrs = &fin->tmprp;
		indxp = fin->index+(FSYS_INDEX_FREE*FSYS_MAX_ALTS);
		fin->q.buff = (U8*)&fin->fhdr;
		fin->q.sector = indxp[fin->substate];
		fin->q.u_len = 512;
		fin->state = INIT_WRITE_FREE;
		fsys_qwrite(ioq);
		return;

	    case INIT_WRITE_FREE:
		if (QIO_ERR_CODE(ioq->iostatus)) {
		    fin->status = FSYS_INITFS_BADFREE;
		    break;
		}
		/* write the freelist.sys file */
		fin->ramrp.rptrs = fin->fhdr.pointers[fin->substate];
		fin->q.buff = (U8*)fin->fake_free;
		fin->q.sector = 0;
		fin->q.u_len = iv->free_sectors*512;
		fin->state = INIT_WRITE_ROOT_FH;
		fsys_qwrite(ioq);
		return;

	    case INIT_WRITE_ROOT_FH:
		if (QIO_ERR_CODE(ioq->iostatus)) {
		    fin->status = FSYS_INITFS_BADFREEF;
		    break;
		}
		/* write the file header for root directory */
		fin->ramrp.rptrs = &fin->tmprp;
		indxp = fin->index+(FSYS_INDEX_ROOT*FSYS_MAX_ALTS);
		fin->q.buff = (U8*)&fin->rhdr;
		fin->q.sector = indxp[fin->substate];
		fin->q.u_len = 512;
		fin->state = INIT_WRITE_ROOT;
		fsys_qwrite(ioq);
		return;

	    case INIT_WRITE_ROOT:
		if (QIO_ERR_CODE(ioq->iostatus)) {
		    fin->status = FSYS_INITFS_BADROOT;
		    break;
		}
		/* write the root directory file */
		fin->ramrp.rptrs = fin->rhdr.pointers[fin->substate];
		fin->q.buff = (U8*)fin->dir;
		fin->q.sector = 0;
		fin->q.u_len = iv->root_sectors*512;
		fin->state = INIT_NEXT_ALT;
		fsys_qwrite(ioq);
		return;

	    case INIT_NEXT_ALT:
		if (QIO_ERR_CODE(ioq->iostatus)) {
		    fin->status = FSYS_INITFS_BADROOTF;
		    break;
		}
		fin->state = INIT_WRITE_HOME;
		++fin->substate;
		if (fin->substate < FSYS_MAX_ALTS) continue;
		sts = FSYS_INITFS_SUCC|SEVERITY_INFO;	/* normal success */
		break;

	    default:
		sts = FSYS_INITFS_FATAL;
		break;
	}			/* -- switch state */
	break;
    }				/* -- while (1) */
    QIOfree(fin->fake_free);
    QIOfree(fin->index);
    QIOfree(fin->dir);
    QIOfree(fin->hb);
    fin->status = sts;
    fin->state = 0;
    ioq = fin->q.callers_ioq;
    ioq->iostatus = sts;
    qio_complete(ioq);
    return;
}

static int fsys_rmdir( QioIOQ *ioq, const char *name ) {
    if (!ioq) return QIO_INVARG;
    return (ioq->iostatus = FSYS_IO_NOSUPP);
}

/* rename file named 'name1' to 'name2' */

static void rename_q(QioIOQ *ioq) {
    FsysLookUpFileT src, dst;
    FsysVolume *vol;
    int sts;
    const char *fname;

    vol = (FsysVolume *)ioq->private;
    dst.vol = vol;
    dst.top = 0;
    dst.path = (const char *)ioq->pparam1;
    do {
	FsysDirEnt *dp;
	char *s;
	sts = lookup_filename(&dst);		/* make sure dst is legal */
	if (sts != FSYS_LOOKUP_NOPATH) {
	    if (sts == (FSYS_LOOKUP_SUCC|SEVERITY_INFO)) {
		ioq->iostatus = FSYS_CREATE_NAMEINUSE;	/* name is already in use */
	    } else {
		ioq->iostatus = FSYS_CREATE_NOPATH;	/* no path */
	    }
	    break;
	}
	src.vol = vol;
	src.top = 0;
	src.path = ioq->pparam0;
	sts = lookup_filename(&src);
	if ( sts != (FSYS_LOOKUP_SUCC|SEVERITY_INFO)) {
	    ioq->iostatus = sts;		/* no source */
	    break;
	}
	fname = strrchr((char *)ioq->pparam1, QIO_FNAME_SEPARATOR); /* get name of dest */
	if (!fname) fname = (const char *)ioq->pparam1;
	dp = (FsysDirEnt *)QMOUNT_ALLOC(vol, sizeof(FsysDirEnt)+strlen(fname)+1);
	s = (char *)(dp+1);
	strcpy(s, fname);
	dp->name = s;
	dp->gen_fid = src.dir->gen_fid; /*(src.dir->generation<<FSYS_DIR_GENSHF) | (src.dir->gen_fid&FSYS_DIR_FIDMASK); */
	dp->next = 0;
/* !!Memory leak here!!!*/
	remove_ent(src.owner->directory, src.fname);
	insert_ent(dst.owner->directory, dp);
	add_to_dirty(vol, src.owner - vol->files, 0); /* put old directory on the dirty list */
	add_to_dirty(vol, dst.owner - vol->files, 0); /* put new directory on the dirty list */
    } while (0);
    ioq->private = 0;
    qio_freefile(qio_fd2file(ioq->file));
    ioq->file = -1;
    qio_freemutex(&vol->mutex, ioq);
    qio_complete(ioq);
    return;
}

static int fsys_rename( QioIOQ *ioq, const char *source, const char *dest ) {
    FsysVolume *vol;
    QioFile *file;

    if ( !source || *source == 0 ) return (ioq->iostatus = QIO_INVARG);
    if ( !dest || *dest == 0 ) return (ioq->iostatus = QIO_INVARG);
    file = qio_fd2file(ioq->file);		/* get pointer to file */
    vol = (FsysVolume *)file->dvc->private;	/* point to our mounted volume */
    if (!vol) return (ioq->iostatus = FSYS_LOOKUP_FNF);
    if (!vol->files) (ioq->iostatus = FSYS_LOOKUP_FNF);
    ioq->pparam0 = (void *)source;
    ioq->pparam1 = (void *)dest;
    ioq->private = (void *)vol;
    ioq->iostatus = 0;
    return qio_getmutex(&vol->mutex, rename_q, ioq);
}

#endif			/* !FSYS_READ_ONLY */

static void lseek_q(QioIOQ *ioq) {
    QioFile *fp;
    off_t where;
    int whence;

    fp = qio_fd2file(ioq->file);
    where = ioq->iparam0;
    whence = ioq->iparam1;
    switch (whence) {
	case SEEK_SET:
	    fp->pos = where;
	    break;

	case SEEK_END:
	    fp->pos = fp->size + where;
	    break;

	case SEEK_CUR:
	    fp->pos += where;
	    break;
    }
    if (fp->pos > fp->size) fp->pos = fp->size;
    ioq->iostatus = FSYS_IO_SUCC|SEVERITY_INFO;
    ioq->iocount = fp->pos;
    qio_complete(ioq);
    qio_freemutex(&fp->mutex, ioq);
    return;
}

/* fsys_lseek - is called directly as a result of the user calling qio_lseek()
 * To protect the pos field of the file, this function has to be serialized
 * with other calls to lseek and read/write. This is done by loading the 
 * parameters into the IOQ, waiting on the mutex for the file then calling
 * lseek_q().
 */

static int fsys_lseek( QioIOQ *ioq, off_t where, int whence ) {
    QioFile *fp;
    int sts;

    if (!ioq) return QIO_INVARG;

    ioq->iparam0 = where;
    ioq->iparam1 = whence;
    fp = qio_fd2file(ioq->file);
    sts = qio_getmutex(&fp->mutex, lseek_q, ioq);
    return sts;
}

static void fsys_read_done( QioIOQ *ioq ) {
    FsysQio *q;
    QioIOQ *hisioq;
    QioFile *fp;
    FsysVolume *v;
    FsysRamFH *rfh;
    int fid;

    q = (FsysQio *)ioq;
    hisioq = q->callers_ioq;
    hisioq->iocount += q->total;		/* record total bytes xferred so far */
    fp = qio_fd2file(hisioq->file);
    v = (FsysVolume *)fp->dvc->private;
    fid = (int)fp->private;
    rfh = v->files + (fid&0x00FFFFFF);
    if (QIO_ERR_CODE(ioq->iostatus) && ioq->iostatus != QIO_EOF && !(fp->mode&FSYS_OPNCPY_M)) {
	++q->o_which;
	if (q->o_which < FSYS_MAX_ALTS) {	/* if we haven't tried all reads */
	    FsysRamRP *rp;
	    rp = rfh->ramrp + q->o_which;	/* get next retrieval pointer set */
	    if (rp->num_rptrs) {		/* if there are alternate retrevial pointers */
		USED_ALT();
		rfh->active_rp = q->o_which;
		q->o_where = q->sector = q->o_where + q->total/512;
		q->o_len = q->u_len = q->o_len - q->total;
		q->o_buff = q->buff = (void *)((U32)q->o_buff + q->total);
		q->ramrp = rp;			/* point to new retreival pointers */
		q->state = 0;			/* make sure we start at beginning */
		q->total = 0;			/* start the read over at 0 */
		fsys_qread(ioq);		/* and re start the read */
		return;
	    }
	}
    }
    hisioq->iostatus = ioq->iostatus;	/* record last status */
    fp->pos = q->o_where*512 + q->total; /* advance the files' sector pointer */
    v = (FsysVolume *)fp->dvc->private;
    fsys_freeqio(q);
    qio_complete(hisioq);
    qio_freemutex(&fp->mutex, hisioq);
    return;
}

static void readwpos_q(QioIOQ *ioq) {
    FsysQio *q;
    QioFile *fp;
    FsysRamFH *rfh;
    off_t where;

    q = (FsysQio *)ioq->pparam0;
    rfh = (FsysRamFH *)ioq->pparam1;
    fp = q->fsys_fp;

    if (!(fp->mode&O_CREAT) && (fp->mode&FSYS_OPNCPY_M)) { /* if reading a specific file */
	int t;
	t = (((U32)fp->mode&FSYS_OPNCPY_M)>>FSYS_OPNCPY_V) - 1;
	q->ramrp = rfh->ramrp + t;
    } else {
	q->ramrp = rfh->ramrp + rfh->active_rp;
    }
    q->o_which = rfh->active_rp;

    where = ioq->iparam0;
    if (where + q->o_len > rfh->size) {
	if (where >= rfh->size) {
	    fp->pos = rfh->size;		/* set position to end of file */
	    ioq->iostatus = QIO_EOF;		/* signal end of file */
	    ioq->iocount = 0;			/* no data xferred */
	    fsys_freeqio(q);			/* done with this */
	    qio_complete(ioq);			/* done */
	    qio_freemutex(&fp->mutex, ioq);
	    return;
	}
	q->o_len = q->u_len = rfh->size - where; /* max out the length */
    }
    fsys_qread(&q->our_ioq);
    return;
}

static int validate_read( QioIOQ *ioq, void *buf, long len) {
    FsysQio *q;
    QioFile *fp;
    FsysVolume *v;
    unsigned int fid;
    FsysRamFH *rfh;

    if (!ioq || len < 0) return QIO_INVARG;
    fp = qio_fd2file(ioq->file);
    v = (FsysVolume *)fp->dvc->private;
    fid = (int)fp->private;
    if ((fid&0x00FFFFFF) >= v->files_ffree) return (ioq->iostatus = FSYS_IO_NOTOPEN);
    rfh = v->files + (fid&0x00FFFFFF);
    if (!rfh->valid) return (ioq->iostatus = FSYS_IO_NOTOPEN);
    if (rfh->generation != (fid>>24)) return (ioq->iostatus = FSYS_IO_NOTOPEN);
    q = fsys_getqio();
    if (!q) return (ioq->iostatus = FSYS_IO_NOQIO);
    q->our_ioq.file = v->iofd;			/* physical I/O to this channel */
    q->callers_ioq = ioq;
    q->o_buff = q->buff = buf;
    q->o_len = q->u_len = len;
    q->compl = fsys_read_done;
    q->fsys_fp = fp;
    ioq->pparam0 = (void *)q;
    ioq->pparam1 = (void *)rfh;
    return 0;
}

/* fsys_readwpos - is called directly as a result of the user calling qio_readwpos()
 * To protect the pos field of the file, this function has to be serialized
 * with other calls to read/write/lseek before using or updating anything in the
 * file struct. This is done by loading the caller's parameters into the IOQ and
 * waiting on the mutex for the file then calling readwpos_q().
 */

static int fsys_readwpos( QioIOQ *ioq, off_t where, void *buf, long len ) {
    FsysQio *q;
    int sts;

    sts = validate_read( ioq, buf, len );
    if (sts) return sts;
    q = (FsysQio *)ioq->pparam0;
    ioq->iparam0 = where;
    q->o_where = q->sector = where/512;
    sts = qio_getmutex(&q->fsys_fp->mutex, readwpos_q, ioq);
    if (sts) fsys_freeqio(q);
    return sts;
}

static void read_q( QioIOQ *ioq ) {
    FsysQio *q;
    off_t where;

    q = (FsysQio *)ioq->pparam0;
    where = q->fsys_fp->pos;
    q->o_where = q->sector = where/512;
    ioq->iparam0 = where;
    readwpos_q(ioq);
    return;
}
    
/* fsys_read - is called directly as a result of the user calling qio_read()
 * To protect the pos field of the file, this function has to be serialized
 * with other calls to read/write/lseek before using or updating anything in the
 * QioFile struct. This is done by loading the caller's parameters into the IOQ and
 * waiting on the mutex for the file then calling read_q().
 */

static int fsys_read( QioIOQ *ioq, void *buf, long len ) {
    FsysQio *q;
    int sts;

    sts = validate_read( ioq, buf, len );
    if (sts) return sts;
    q = (FsysQio *)ioq->pparam0;
    sts = qio_getmutex(&q->fsys_fp->mutex, read_q, ioq);
    if (sts) fsys_freeqio(q);
    return sts;
}

static void fsys_write_done( QioIOQ *ioq ) {
    FsysQio *q;
    QioIOQ *hisioq;
    QioFile *fp;
    FsysVolume *v;
    unsigned int fid;
    FsysRamFH *rfh;
    int lim;

    q = (FsysQio *)ioq;
    if (QIO_ERR_CODE(ioq->iostatus)) q->o_iostatus = ioq->iostatus;
    fp = q->fsys_fp;
    v = (FsysVolume *)fp->dvc->private;
    hisioq = q->callers_ioq;
    fp = qio_fd2file(hisioq->file);
    fid = (int)fp->private;
    rfh = v->files + (fid&0x00FFFFFF);
    if (!(fp->mode&FSYS_OPNCPY_M)) {
	++q->o_which;
	if (q->o_which < FSYS_MAX_ALTS) {	/* if we haven't tried all writes */
	    FsysRamRP *rp;
	    rp = rfh->ramrp + q->o_which;	/* get next retrieval pointer set */
	    if (rp->num_rptrs) {		/* if there are alternate retrevial pointers */
		q->ramrp = rp;		/* point to new batch */
		q->sector = q->o_where;	/* rewind the significant pointers */
		q->u_len = q->o_len;
		q->buff = (void *)q->o_buff;
		q->total = 0;		/* reset the total */
		q->state = 0;		/* make sure we start at beginning */
		fsys_qwrite(ioq);		/* and re start the write */
		return;
	    }
	}
    }
    lim = q->total;			/* total number of bytes xferred */
    if (lim > q->o_len) lim = q->o_len;	/* limit it to the number the user asked */
    hisioq->iocount = lim;		/* record total bytes xferred */
    if (q->o_iostatus) {
	hisioq->iostatus = q->o_iostatus;	/* record last error status */
    } else {
	hisioq->iostatus = ioq->iostatus;
    }
    fp->pos = q->o_where*512 + lim;	/* advance the files' sector pointer */
    if (rfh->size < fp->pos) {
	rfh->size = fp->pos;
	rfh->valid |= RAMFH_UPD;	/* update FH at close */
    }
    fsys_freeqio(q);
    qio_complete(hisioq);
    qio_freemutex(&fp->mutex, &q->our_ioq);
    return;
}

static int validate_write( QioIOQ *ioq, const void *buf, long len ) {
    FsysQio *q;
    QioFile *fp;
    FsysVolume *v;
    unsigned int fid;
    FsysRamFH *rfh;

    if (!ioq) return QIO_INVARG;
    fp = qio_fd2file(ioq->file);
    v = (FsysVolume *)fp->dvc->private;
    fid = (int)fp->private;
    if ((fid&0x00FFFFFF) >= v->files_ffree) return (ioq->iostatus = FSYS_IO_NOTOPEN);
    rfh = v->files + (fid&0x00FFFFFF);
    if (!rfh->valid) return (ioq->iostatus = FSYS_IO_NOTOPEN);
    if (rfh->generation != (fid>>24)) return (ioq->iostatus = FSYS_IO_NOTOPEN);
    q = fsys_getqio();
    if (!q) return (ioq->iostatus = FSYS_IO_NOQIO);

    q->o_which = 0;
    q->o_len = q->u_len = len;
    q->o_buff = q->buff = (void *)buf;
    q->o_iostatus = 0;				/* assume no errors */
    q->our_ioq.file = v->iofd;			/* physical I/O to this channel */
    q->callers_ioq = ioq;
    q->ramrp = rfh->ramrp;
    q->compl = fsys_write_done;
    q->fsys_fp = fp;
    ioq->pparam0 = (void *)q;
    return 0;
}

/* fsys_writewpos - is called directly as a result of the user calling qio_writewpos()
 * To protect the pos field of the file, this function has to be serialized
 * with other calls to read/write/lseek before using or updating anything in the
 * file struct. This is done by loading the caller's parameters into the IOQ,
 * waiting on the mutex for the file then calling writewpos_q().
 */

static int fsys_writewpos( QioIOQ *ioq, off_t where, const void *buf, long len ) {
    FsysQio *q;
    int sts;

    sts = validate_write(ioq, buf, len);
    if (sts) return sts;
    q = (FsysQio *)ioq->pparam0;
    q->o_where = q->sector = where/512;
    sts = qio_getmutex(&q->fsys_fp->mutex, fsys_qwrite, &q->our_ioq);
    if (sts) fsys_freeqio(q);
    return sts;
}

static void write_q( QioIOQ *ioq ) {
    FsysQio *q;
    off_t where;

    q = (FsysQio *)ioq;
    where = q->fsys_fp->pos;
    q->o_where = q->sector = where/512;
    fsys_qwrite(&q->our_ioq);
    return;
}
    
static int fsys_write( QioIOQ *ioq, const void *buf, long len ) {
    int sts;
    FsysQio *q;

    sts = validate_write( ioq, buf, len);
    if (sts) return sts;
    q = (FsysQio *)ioq->pparam0;
    sts = qio_getmutex(&q->fsys_fp->mutex, write_q, &q->our_ioq);
    if (sts) fsys_freeqio(q);
    return sts;
}

#if !FSYS_READ_ONLY || FSYS_UPD_FH
static void ioctl_setfh( QioIOQ *ioq ) {
    QioFile *fp;
    FsysVolume *vol;
    FsysFHIoctl *ctl;
    FsysRamFH *rfh;
    int fid, afid;
# if !FSYS_READ_ONLY
    FsysRamRP *rp;
    int ii, jj, copies;
# endif

    fp = qio_fd2file(ioq->file);
    vol = (FsysVolume *)fp->dvc->private;
    fid = (int)fp->private;
    afid = fid & 0x00FFFFFF;
    rfh = vol->files + afid;
    ctl = (FsysFHIoctl *)ioq->pparam0;
    if ((ctl->fields&FSYS_FHFIELDS_CTIME)) rfh->ctime = ctl->ctime;
    if ((ctl->fields&FSYS_FHFIELDS_MTIME)) rfh->mtime = ctl->mtime;
# if (FSYS_FEATURES&FSYS_OPTIONS&FSYS_FEATURES_ABTIME)
    if ((ctl->fields&FSYS_FHFIELDS_ATIME)) rfh->atime = ctl->atime;
    if ((ctl->fields&FSYS_FHFIELDS_BTIME)) rfh->btime = ctl->btime;
# endif    
# if !FSYS_READ_ONLY
    for (ii=copies=0; ii < FSYS_MAX_ALTS; ++ii) {	/* compute how many copies */
	rp = rfh->ramrp + ii;
	if (rp->num_rptrs) ++copies;
    }
    if ((ctl->fields&FSYS_FHFIELDS_COPIES)) {
	for (; copies < ctl->copies; ++copies) {
	    rp = rfh->ramrp + copies;
	    if (rp->num_rptrs) continue;		/* already have a copy here */
	    ii = extend_file(vol, rfh->clusters, rp, copies);
	    if (ii) {
		ioq->iostatus = ii;
		goto ioctl_done;
	    }
	}
    }
    if ((ctl->fields&FSYS_FHFIELDS_ALLOC)) {
	int def;
	def = (ctl->alloc+511)/512;
	if (def > rfh->clusters) {
	    def -= rfh->clusters;
	    if (def*copies >= vol->total_free_clusters) {
		ioq->iostatus = FSYS_EXTEND_FULL;	/* no room on disk */
		goto ioctl_done;
	    }
	    for (jj=0; jj < copies; ++jj) {
		rp = rfh->ramrp + jj;
		if (!rp->num_rptrs) continue;		/* no copy here */
		ii = extend_file(vol, def, rp, jj);
		if (ii) {
		    ioq->iostatus = ii;
		    break;				/* ran out of room */
		}
	    }
	    rfh->clusters += def;			/* bump allocation record */
	}
    }	    
    if ((ctl->fields&FSYS_FHFIELDS_DEFEXT)) {
	rfh->def_extend = (ctl->def_extend+511)/512;
    }
# endif
    if ((ctl->fields&FSYS_FHFIELDS_SIZE)) {
	if (ctl->size > rfh->clusters*512) {
	    rfh->size = fp->size = rfh->clusters*512;
	} else {
	    rfh->size = fp->size = ctl->size;
	}
    }
    add_to_dirty(vol, afid, 0);				/* record changed FH */
    ioq->iostatus = FSYS_IO_SUCC|SEVERITY_INFO;
# if !FSYS_READ_ONLY
ioctl_done:
# endif
    qio_freemutex(&vol->mutex, ioq);
    qio_complete(ioq);
}
#endif

static int fsys_ioctl( QioIOQ *ioq, unsigned int cmd, void *arg ) {
    int sts, ii, jj;
    QioFile *fp;
    FsysFHIoctl *ctl;
    FsysVolume *vol;

    if (!ioq) return QIO_INVARG;
    fp = qio_fd2file(ioq->file);
    vol = (FsysVolume *)fp->dvc->private;
    switch (cmd) {
	default: sts = FSYS_IO_NOSUPP;
	    break;
	case FSYS_IOC_GETFH: {
	    int fid, afid;
	    FsysRamFH *rfh;
	    FsysRamRP *rp;

	    if (!(ctl = (FsysFHIoctl *)arg)) {
		sts = QIO_INVARG;
		break;
	    }
	    fid = (int)fp->private;
	    afid = fid & 0x00FFFFFF;
	    rfh = vol->files + afid;
	    ctl->fields = FSYS_FHFIELDS_CTIME|FSYS_FHFIELDS_MTIME|FSYS_FHFIELDS_ALLOC
	    		  |FSYS_FHFIELDS_DEFEXT|FSYS_FHFIELDS_SIZE|FSYS_FHFIELDS_COPIES
#if (FSYS_FEATURES&FSYS_OPTIONS&FSYS_FEATURES_ABTIME)
	    	          |FSYS_FHFIELDS_ATIME|FSYS_FHFIELDS_BTIME
#endif
	    		  ;
	    ctl->ctime = rfh->ctime;
	    ctl->mtime = rfh->mtime;
#if (FSYS_FEATURES&FSYS_OPTIONS&FSYS_FEATURES_ABTIME)
	    ctl->atime = rfh->atime;
	    ctl->btime = rfh->btime;
#else
	    ctl->atime = ctl->btime = 0;
#endif
	    ctl->alloc = rfh->clusters*512;
	    ctl->def_extend = rfh->def_extend*512;
	    ctl->size = fp->size;
	    ctl->pos = fp->pos;
	    ctl->fid = fid;
	    for (ii=jj=0; ii < FSYS_MAX_ALTS; ++ii) {	/* compute how many copies */
		rp = rfh->ramrp + ii;
		if (rp->num_rptrs) ++jj;
	    }
	    ctl->copies = jj;
	    ctl->dir = rfh->directory != 0;
	    ioq->iostatus = FSYS_IO_SUCC|SEVERITY_INFO;
	    qio_complete(ioq);
	    return 0;
	}
	case FSYS_IOC_SETFH:
	    if (!(ctl = (FsysFHIoctl *)arg)) {
		sts = QIO_INVARG;
		break;
	    }
#if !FSYS_READ_ONLY || FSYS_UPD_FH
# if FSYS_READ_ONLY && FSYS_UPD_FH
	    if ((ctl->fields&(FSYS_FHFIELDS_ALLOC|FSYS_FHFIELDS_COPIES|FSYS_FHFIELDS_DEFEXT))) {
		sts = FSYS_IO_NOSUPP;
		break;
	    }
# else
	    if ((ctl->fields&FSYS_FHFIELDS_COPIES) && ctl->copies > FSYS_MAX_ALTS) {
		sts = QIO_INVARG;
		break;
	    }
# endif
	    ioq->iparam0 = cmd;
	    ioq->pparam0 = arg;
	    sts = qio_getmutex(&vol->mutex, ioctl_setfh, ioq);
	    if (sts) break;
	    return 0;
#else
	    sts = FSYS_IO_NOSUPP;
	    break;
#endif
    }
    return (ioq->iostatus = sts);
}

#if !FSYS_READ_ONLY || FSYS_UPD_FH
static void fsys_closeq(QioIOQ *ioq) {
    QioFile *file;
    int fid, afid;
    FsysRamFH *rfh;
    FsysVolume *vol;

    file = qio_fd2file(ioq->file);
    vol = (FsysVolume *)file->dvc->private;
    fid = (int)file->private;
    afid = fid & 0x00FFFFFF;
    rfh = vol->files + afid;
# if !FSYS_READ_ONLY || FSYS_UPD_FH
    if ((rfh->valid&RAMFH_UPD)) {
	add_to_dirty(vol, afid, 0);
	rfh->valid &= ~RAMFH_UPD;	/* not dirty anymore */
    }
# endif
    file->private = 0;
    file->dvc = 0;
    qio_freefile(file);		/* put file back on free list */
    ioq->file = -1;		/* not open anymore */
    qio_freemutex(&vol->mutex, ioq);
    ioq->iostatus = FSYS_IO_SUCC|SEVERITY_INFO;
    qio_complete(ioq);
    return;
}
#endif

static int fsys_close( QioIOQ *ioq) {
    QioFile *file;
    FsysVolume *vol;
    int fid, afid;
    FsysRamFH *rfh;

    if (!ioq) return QIO_INVARG;
    file = qio_fd2file(ioq->file);
    if (!file) return (ioq->iostatus = QIO_NOTOPEN);

    vol = (FsysVolume *)file->dvc->private;
    if (!vol) return (ioq->iostatus = FSYS_OPEN_NOTOPEN);
    fid = (int)file->private;
    afid = fid & 0x00FFFFFF;
    if (afid >= vol->files_ffree) return (ioq->iostatus = FSYS_IO_NOTOPEN);
    rfh = vol->files + afid;
    if (!rfh->valid) return (ioq->iostatus = FSYS_IO_NOTOPEN);
    if (rfh->generation != (fid>>24)) return (ioq->iostatus = FSYS_IO_NOTOPEN);
#if !FSYS_READ_ONLY || FSYS_UPD_FH
    return qio_getmutex(&vol->mutex, fsys_closeq, ioq);
#else
    file->private = 0;
    file->dvc = 0;
    qio_freefile(file);		/* put file back on free list */
    ioq->file = -1;		/* not open anymore */
    ioq->iostatus = FSYS_IO_SUCC|SEVERITY_INFO;
    qio_complete(ioq);
    return 0;
#endif
}

static int fsys_trunc( QioIOQ *ioq ) {
    if (!ioq) return QIO_INVARG;
    return (ioq->iostatus = FSYS_IO_NOSUPP);
}

static int fsys_statfs( QioIOQ *ioq, const char *name, void *fsarg ) {
    struct statfs *sfs;
    sfs = (struct statfs *)fsarg;
    if (!ioq) return QIO_INVARG;
    return (ioq->iostatus = FSYS_IO_NOSUPP);
}

static int fsys_fstat( QioIOQ *ioq, struct stat *st ) {
    QioFile *file;
    FsysVolume *vol;
    FsysRamFH *rfh;
    int fid, afid;

    file = qio_fd2file(ioq->file);		/* get pointer to file */
    if (!file) return (ioq->iostatus = FSYS_OPEN_NOTOPEN);
    vol = (FsysVolume *)file->dvc->private;
    if (!vol) return (ioq->iostatus = FSYS_OPEN_NOTOPEN);
    fid = (int)file->private;
    afid = fid & 0x00FFFFFF;
    if (afid >= vol->files_ffree) return (ioq->iostatus = FSYS_IO_NOTOPEN);
    rfh = vol->files + afid;
    if (!rfh->valid) return (ioq->iostatus = FSYS_IO_NOTOPEN);
    if (rfh->generation != (fid>>24)) return (ioq->iostatus = FSYS_IO_NOTOPEN);
    st->st_mode = rfh->directory ? S_IFDIR : S_IFREG;
    st->st_size = file->size;
#if !WATCOM_LIBC
    st->st_blksize = 512;
    st->st_blocks = (file->size+511)/512;
#endif
#if (FSYS_FEATURES&FSYS_OPTIONS&FSYS_FEATURES_CMTIME)
    st->st_ctime = rfh->ctime;
    st->st_mtime = rfh->mtime;
#endif
#if (FSYS_FEATURES&FSYS_OPTIONS&FSYS_FEATURES_ABTIME)
    st->st_atime = rfh->atime;
#endif
    ioq->iostatus = FSYS_IO_SUCC|SEVERITY_INFO;
    qio_complete(ioq);
    return 0;
}

static int fsys_cancel( QioIOQ *ioq ) {
    if (!ioq) return QIO_INVARG;
    return (ioq->iostatus = FSYS_IO_NOSUPP);
}

static int fsys_isatty( QioIOQ *ioq ) {
    if (!ioq) return QIO_INVARG;
    return (ioq->iostatus = FSYS_IO_NOSUPP);
}

static DIR *dir_pool_head;
static int num_dirs;

/************************************************************
 * fsys_getDIR - Get a DIR from the system's pool
 * 
 * At entry:
 *	no requirements
 *
 * At exit:
 *	returns pointer to queue or 0 if none available.
 */
static DIR *fsys_getDIR(void) {
    ++num_dirs;
    return (DIR*)qio_getioq_ptr((QioIOQ **)&dir_pool_head, sizeof(DIR));
}

/************************************************************
 * fsys_freeDIR - Free a DIR as obtained from a previous
 * call to fsys_getDIR().
 * 
 * At entry:
 *	que - pointer to queue element to put back in pool.
 *
 * At exit:
 *	0 if success or 1 if queue didn't belong to pool.
 */
static int fsys_freeDIR(DIR *que) {
    --num_dirs;
    return qio_freeioq_ptr((QioIOQ *)que, (QioIOQ **)&dir_pool_head);
}

static int fsys_opendir( QioIOQ *ioq, void **dirp, const char *name ) {
    FsysVolume *vol;
    const QioDevice *dvc;
    DIR *dp;
    int sts;
    FsysLookUpFileT luf;

    dvc = (const QioDevice *)ioq->private;
    vol = (FsysVolume *)dvc->private;		/* point to our mounted volume */
    if (!vol || !vol->files) return (ioq->iostatus = FSYS_OPEN_NOTMNT);
    dp = fsys_getDIR();
    if (!dp) return (ioq->iostatus = FSYS_IO_NODIRS);
    luf.vol = vol;
    luf.top = 0;
    luf.path = name;
    sts = lookup_filename(&luf);
    if (QIO_ERR_CODE(sts)) {
	fsys_freeDIR(dp);
	return (ioq->iostatus = sts);
    }
    if (!(dp->hash=luf.file->directory)) {
	fsys_freeDIR(dp);
	return (ioq->iostatus = FSYS_LOOKUP_NOTDIR);
    }
    dp->vol = vol;
    *dirp = dp;
    ioq->iostatus = FSYS_IO_SUCC|SEVERITY_INFO;
    qio_complete(ioq);
    return 0;
}

static int fsys_readdir( QioIOQ *ioq, void *dirp, void *directp ) {
    DIR *dp;
    struct direct *direct;

    dp = (DIR *)dirp;
    direct = (struct direct *)directp;
    if (dp->current) dp->current = dp->current->next;
    if (!dp->current) {
	for (;dp->entry < FSYS_DIR_HASH_SIZE; ++dp->entry) {
	    if ((dp->current = dp->hash[dp->entry])) break;
	}
	++dp->entry;			/* this always needs bumping, even if we found one */
    }
    if (dp->current) {
	direct->name = dp->current->name;
	direct->fid = (dp->current->gen_fid);
	ioq->iostatus = FSYS_IO_SUCC|SEVERITY_INFO;
    } else {
	direct->name = 0;
	direct->fid = 0;
	ioq->iostatus = QIO_EOF;
    }
    qio_complete(ioq);
    return 0;
}

static int fsys_rewdir( QioIOQ *ioq, void *dirp ) {
    DIR *dp;
    dp = (DIR *)dirp;
    dp->current = 0;
    dp->entry = 0;
    ioq->iostatus = FSYS_IO_SUCC|SEVERITY_INFO;
    qio_complete(ioq);
    return 0;
}

static int fsys_closedir( QioIOQ *ioq, void *dirp ) {
    DIR *dp;
    dp = (DIR *)dirp;
    fsys_freeDIR(dp);
    ioq->iostatus = FSYS_IO_SUCC|SEVERITY_INFO;
    qio_complete(ioq);
    return 0;
}

static int fsys_seekdir( QioIOQ *ioq, void *dirp ) {
    if (!ioq) return QIO_INVARG;
    return (ioq->iostatus = FSYS_IO_NOSUPP);
}

static int fsys_telldir( QioIOQ *ioq, void *dirp ) {
    if (!ioq) return QIO_INVARG;
    return (ioq->iostatus = FSYS_IO_NOSUPP);
}

static const QioFileOps fsys_fops = {
    fsys_lseek,	/* lseek to specific byte in file */
    fsys_read, 	/* Read from a file */
    fsys_write,	/* Write to a file */
    fsys_ioctl,	/* I/O control */
    fsys_open,	/* open file */
    fsys_close,	/* close previously opened file */
#if !FSYS_READ_ONLY
    fsys_delete,/* delete a file */
    fsys_fsync,	/* sync the file system */
    fsys_mkdir,	/* make a directory */
    fsys_rmdir,	/* remove a directory */
    fsys_rename,/* rename a directory */
#else
    0,		/* no delete */
# if FSYS_UPD_FH
    fsys_fsync,
# else
    0,		/* no fsync */
# endif
    0,		/* no mkdir */
    0,		/* no rmdir */
    0,		/* no rename */
#endif
    fsys_trunc,	/* truncate a file */
    fsys_statfs,/* stat a file system */
    fsys_fstat,	/* stat a file */
    fsys_cancel, /* cancel I/O */
    fsys_isatty, /* maybe a tty */
    fsys_readwpos,	/* read with combined lseek */
    fsys_writewpos,	/* write with combined lseek */
    fsys_opendir,	/* open directory */
    fsys_seekdir,	/* seek directory */
    fsys_telldir,	/* tell directory */
    fsys_rewdir,	/* rewind directory */
    fsys_readdir,	/* read directory entry */
    fsys_closedir	/* close directory */
};

static const QioDevice vol0_dvc = {
    "d0",				/* device name */
    2,					/* length of name */
    &fsys_fops,				/* list of operations allowed on this device */
    0,					/* no mutex required for null device */
    0,					/* unit 0 */
    (void *)(volumes+0)			/* volume 0 */
};

#if FSYS_MAX_VOLUMES > 1
static const QioDevice vol1_dvc = {
    "d1",				/* device name */
    2,					/* length of name */
    &fsys_fops,				/* list of operations allowed on this device */
    0,					/* no mutex required for null device */
    1,					/* unit 1 */
    (void *)(volumes+1)			/* volume 1 */
};
#endif

#if FSYS_MAX_VOLUMES > 2
static const QioDevice vol2_dvc = {
    "d2",				/* device name */
    2,					/* length of name */
    &fsys_fops,				/* list of operations allowed on this device */
    0,					/* no mutex required for null device */
    2,					/* unit 2 */
    (void *)(volumes+2)			/* volume 2 */
};
#endif

#if FSYS_MAX_VOLUMES > 3
static const QioDevice vol3_dvc = {
    "d3",				/* device name */
    2,					/* length of name */
    &fsys_fops,				/* list of operations allowed on this device */
    0,					/* no mutex required for null device */
    3,					/* unit 3 */
    (void *)(volumes+3)			/* volume 3 */
};
#endif

#if !FSYS_READ_ONLY
int fsys_initfs(const char *what, FsysInitVol *iv) {
    volatile FsysFinit fin;
    int sts;
    QioIOQ *ioq;
    QioFile *file;
    const QioDevice *dvc;

    if (prc_get_astlvl() >= 0) return FSYS_INITFS_BADLVL;	/* cannot call this at AST level */
    memset((char *)&fin, 0, sizeof(fin));
    ioq = qio_getioq();
    if (ioq) {
	sts = qio_open(ioq, (void *)what, O_RDWR);
	while (!sts) { sts = ioq->iostatus; }
	if (!QIO_ERR_CODE(sts)) {
	    struct stat drvstat;
	    file = qio_fd2file(ioq->file);
	    if (!file || !(dvc=file->dvc)) {
		sts = QIO_FATAL;
	    } else {
		fin.q.our_ioq.file = ioq->file;
		fin.iv = iv;
		sts = qio_fstat(ioq, &drvstat);
		while (!sts) { sts = ioq->iostatus; }
		if (!QIO_ERR_CODE(sts)) {
		    U32 lim;
		    lim = drvstat.st_size;
#if defined(FSYS_MAX_LBA) && FSYS_MAX_LBA
		    if (FSYS_MAX_LBA < lim) lim = FSYS_MAX_LBA;
#endif
		    if (iv->max_lba > 0 && iv->max_lba < lim) lim = iv->max_lba;
		    lim = lim - (lim%FSYS_MAX_ALTS); /* make total a multiple of MAX_ALTS */
		    fin.max_lba = lim;
		    fin.q.callers_ioq = ioq;
		    ioq->iostatus = 0;
		    ioq->iocount = 0;
		    init_file_system((QioIOQ *)&fin);
		    while (!(sts=ioq->iostatus)) { ; }
		}
	    }
	    qio_close(ioq);
	}
	qio_freeioq(ioq);
	return sts;
    }
    return QIO_NOIOQ;
}
#endif

void fsys_init(void) {
    int ii;
#if TEST_DISK_TIMEOUT
    {
	int oldopt = prc_delay_options(PRC_DELAY_OPT_TEXT2FB|PRC_DELAY_OPT_SWAP|PRC_DELAY_OPT_CLEAR);
	txt_str(-1, AN_VIS_ROW/2, "Fake disk timeouts enabled", RED_PAL);
	prc_delay(4*60);
	prc_delay_options(oldopt);
    }
#endif
    for (ii=0; ii < n_elts(volumes); ++ii) volumes[ii].id = FSYS_ID_VOLUME;
#if (FSYS_SQUAWKING || FSYS_FREE_SQUAWKING || FSYS_SYNC_SQUAWKING) && !FSYS_SQUAWKING_STDIO
    if (!fsys_iop) fsys_iop = iio_open(1);	/* open a connection to thread 1 */
#endif
    qio_install_dvc(&vol0_dvc);
#if FSYS_MAX_VOLUMES > 1
    qio_install_dvc(&vol1_dvc);
#endif
#if FSYS_MAX_VOLUMES > 2
    qio_install_dvc(&vol2_dvc);
#endif
#if FSYS_MAX_VOLUMES > 3
    qio_install_dvc(&vol3_dvc);
#endif
    return;
}

#if !defined(NO_FSYS_TEST) || !NO_FSYS_TEST
#if 1
# ifndef LED_ON
#  define LED_ON(x)	do { *(VU32*)LED_OUT &= ~(1<<B_LED_##x); } while (0)
# endif
# ifndef LED_OFF
#  define LED_OFF(x)	do { *(VU32*)LED_OUT |= (1<<B_LED_##x); } while (0)
# endif
#else
# ifndef LED_ON
#  define LED_ON(x)	do { ; } while (0)
# endif
# ifndef LED_OFF
#  define LED_OFF(x)	do { ; } while (0)
# endif
#endif

#if 0
#include <glide.h>
static void (*oldvb)(void);
static struct tq vb_q;

static void fsys_vb_qr(void *p) {
    U32 cookie;

    cookie = txt_setpos(0);
    txt_hexnum(-1, 3, ctl_read_sw(0), 8, RJ_ZF, WHT_PAL);
    txt_hexnum(-1, 4, ctl_read_debug(0), 8, RJ_ZF, WHT_PAL);
    txt_setpos(cookie);
    sst_text2fb(0);
    sst_bufswap();
    grBufferClear( 0, 0, GR_WDEPTHVALUE_FARTHEST );
    return;
}

static void fsys_vb_t(void *p) {
    vb_q.func = fsys_vb_qr;
#if 1
    prc_q_ast(QIO_ASTLVL, (struct act_q *)&vb_q );
#else
    prc_q_action((struct act_q *)&vb_q );
#endif
}

static void fsys_vb(void) {
    oldvb();
    if (!vb_q.que) {
	vb_q.func = fsys_vb_t;
	vb_q.vars = 0;
	vb_q.delta = 5000;
	tq_ins(&vb_q);
    }
    return;
}
#endif

#if 0 && MALLOC_DEBUG
static int alloc_amt;

static void *get_mem(int amt) {
    alloc_amt += amt;
    return QIOmalloc(amt);
}

static void free_mem(int amt, void *ptr) {
    alloc_amt -= amt ;
    QIOfree(ptr);
    return;
}

#define GET_MEM(x) get_mem(x)
#define FREE_MEM(a, x) free_mem(a, x)
#else
#define GET_MEM(x) QIOmalloc(x)
#define FREE_MEM(a, x) QIOfree(x)
#endif

typedef struct chksums {
    U32 fid;
    U32 chksum;
} ChkSum;

typedef struct dir_walker {
    DIR *dp;
    QioIOQ *ioq;
    char *data_buff;
    int data_buff_size;
    int errors;
    int cs_errors;
    int cs;
    int file_size;
    ChkSum *cksums;
    ChkSum *this_cs;
    int numb_cksums;
    int banners;
    int correctables;
    int used_alts;
} Walker;

#define WALK_EXIT_OK	0	/* walk completed with success */
#define WALK_EXIT_ABORT	1	/* operator requests abort */
#define WALK_EXIT_ERR	2	/* walk completed with error */

#define WALK_ANN_ROW	(AN_VIS_ROW/3)
#define WALK_ERR_ROW	(AN_VIS_ROW/3+4)
#define WALK_COL	(-1)

#define WALK_CKSUM_ROW	(WALK_ERR_ROW+7)
#define WALK_CKSUM_MSG	"File checksum errors:          "
#define WALK_CKSUM_COL	((AN_VIS_COL-sizeof(WALK_CKSUM_MSG)-1-4)/2)

#define WALK_UCORR_ROW	(WALK_ERR_ROW+8)
#define WALK_UCORR_MSG	"Uncorrectable disk errors:     "
#define WALK_UCORR_COL	((AN_VIS_COL-sizeof(WALK_UCORR_MSG)-1-4)/2)

#define WALK_CORR_ROW	(WALK_ERR_ROW+9)
#define WALK_CORR_MSG	"Correctable disk read errors:  "
#define WALK_CORR_COL	((AN_VIS_COL-sizeof(WALK_CORR_MSG)-1-4)/2)

#define WALK_ALTS_ROW	(WALK_ERR_ROW+10)
#define WALK_ALTS_MSG	"Alternates used:               "
#define WALK_ALTS_COL	((AN_VIS_COL-sizeof(WALK_ALTS_MSG)-1-4)/2)

static void find_cs(int fid, Walker *wp) {
    int ii;
    ChkSum *csp;
    csp = wp->cksums;
    wp->this_cs = 0;
    if (csp) for (ii=0; ii < wp->numb_cksums; ++ii, ++csp) {
	if (csp->fid == fid) {
	    wp->this_cs = csp;
	    break;
	}
    }
    return;
}

#ifndef QUIET_CHECK
#define QUIET_CHECK	1	/* don't display filenames */
#endif

static int read_check(QioIOQ *ioq, Walker *wp) {
    int sts, cs;
    U32 *up;
#ifdef EER_FSYS_USEALT
    int used_alts;
#endif
#ifdef EER_DSK_CORR
    int corrs;
#endif
    cs = 0;
    wp->file_size = 0;
    while (1) {
	if ((ctl_read_sw(0)&SW_NEXT)) return WALK_EXIT_ABORT;
#ifdef EER_FSYS_USEALT
	used_alts = eer_gets(EER_FSYS_USEALT);
#endif
#ifdef EER_DSK_CORR
	corrs = eer_gets(EER_DSK_CORR);
#endif
#if TEST_DISK_TIMEOUT
	if ((ctl_read_sw(SW_ACTION)&SW_ACTION)) {
	    ioq->timeout = 1000;		/* short timeout */
	} else {
	    ioq->timeout = 0;
	}
#endif
	sts = qio_read(ioq, wp->data_buff, wp->data_buff_size);
	while (!sts) { sts = ioq->iostatus; }
#ifdef EER_FSYS_USEALT
	if (used_alts != eer_gets(EER_FSYS_USEALT)) ++wp->used_alts;
#endif
#ifdef EER_DSK_CORR
	if (corrs != eer_gets(EER_DSK_CORR)) wp->correctables += eer_gets(EER_DSK_CORR)-corrs;
#endif
	if (QIO_ERR_CODE(sts)) {
	    if (sts == QIO_EOF) {
		wp->cs = cs;
		return 0;
	    }
	    qio_errmsg(sts, wp->data_buff, wp->data_buff_size);
	    txt_str(-1, WALK_ERR_ROW, wp->data_buff, YEL_PAL);
	    break;
	}
	wp->file_size += ioq->iocount;
	up = (U32*)wp->data_buff;
	if (wp->this_cs) {
	    if ((ioq->iocount&3)) {
		char *scp;
		scp = wp->data_buff + ioq->iocount;
		switch (ioq->iocount&3) {
		    case 1: *scp++ = 0;
		    case 2: *scp++ = 0;
		    case 3: *scp++ = 0;
		}
	    }
	    for (sts=0; sts < ioq->iocount; sts += 4) {
		cs += *up++;
	    }
	}
    }	
    ++wp->errors;
    return WALK_EXIT_ERR;
}

#if defined(TEST_DISK_ERRORS) && TEST_DISK_ERRORS
# define FAKE_CS_ERROR (ctl_read_sw(IO_MISC6 << SH_MISC)&(IO_MISC6 << SH_MISC))
#else
# define FAKE_CS_ERROR 0
#endif

#if !QUIET_CHECK
static int walk_directory(Walker *wp, const char *dir_name) {
    int sts, dnlen, memamt;
    struct direct dir;
    char *new_name, *cp;
    QioIOQ *ioq, *nioq;
    FsysOpenT ot;

    ioq = wp->ioq;
    dnlen = strlen(dir_name);
    
    st_insn(AN_VIS_ROW-2, t_msg_ret_menu, t_msg_next, INSTR_PAL);
    while (1) {
	U32 pos_cookie;
	if (ctl_read_sw(SW_NEXT)&SW_NEXT) {
	    sts = WALK_EXIT_ABORT;
	    break;
	}
	sts = qio_readdir(ioq, wp->dp, &dir);
	while (!sts) { sts = ioq->iostatus; }
	if (QIO_ERR_CODE(sts)) {
	    if (sts == QIO_EOF) {
		sts = 0;
	    } else {
		qio_errmsg(sts, wp->data_buff, wp->data_buff_size);
		txt_str(-1, WALK_ERR_ROW, wp->data_buff, YEL_PAL);
		++wp->errors;
	    }
	    break;
	}
	if (strcmp(dir.name, ".") == 0 || strcmp(dir.name, "..") == 0) continue;
	sts = strlen(dir.name);
	memamt = sts+dnlen+2;
	new_name = GET_MEM(memamt);
	strcpy(new_name, dir_name);	/* start with old name */
	cp = new_name + strlen(new_name);
	*cp++ = QIO_FNAME_SEPARATOR;
	strcpy(cp, dir.name);		/* filename */
	txt_str(4, WALK_ANN_ROW, "Checking:", WHT_PAL);
	txt_clr_wid(4, WALK_ANN_ROW+2, AN_VIS_COL-6);
	if (sts+dnlen+1 > AN_VIS_COL-2-4-5) {
	    txt_str(4, WALK_ANN_ROW+2, "... ", WHT_PAL);
	    txt_cstr(new_name + sts+dnlen+1 - (AN_VIS_COL-6), GRN_PAL);
	} else {
	    txt_str(4, WALK_ANN_ROW+2, new_name, GRN_PAL);
	}
	pos_cookie = txt_setpos(0);
	prc_delay(0);
	nioq = qio_getioq();
	if (!nioq) {
	    txt_str(-1, WALK_ERR_ROW, "Ran out of IOQ's", RED_PAL);
	    ++wp->errors;
	    sts = WALK_EXIT_ERR;	/* procedure error */
	    break;
	}	    
	nioq->timeout = ioq->timeout;	/* set same as caller's timeout */
	ot.spc.path = new_name;
	ot.spc.mode = O_RDONLY;
	ot.fid = 0;
	sts = qio_openspc(nioq, &ot.spc);
	while (!sts) { sts = nioq->iostatus; }
	if (QIO_ERR_CODE(sts)) {
	    qio_errmsg(sts, wp->data_buff, wp->data_buff_size);
	    txt_str(-1, WALK_ERR_ROW, wp->data_buff, YEL_PAL);
	    ++wp->errors;
	    sts = WALK_EXIT_ERR;
	} else {
	    if (ot.mkdir) {	/* if new file is a directory */
		DIR *olddp;

		qio_close(nioq);	/* don't need this resource */
		olddp = wp->dp;
		sts = qio_opendir(nioq, (void *)&wp->dp, new_name); /* open directory */
		while (!sts) { sts = nioq->iostatus; }
		if (QIO_ERR_CODE(sts)) {
		    wp->dp = olddp;
		    qio_errmsg(sts, wp->data_buff, wp->data_buff_size);
		    txt_str(-1, WALK_ERR_ROW, wp->data_buff, YEL_PAL);
		    ++wp->errors;
		    sts = WALK_EXIT_ERR;
		} else {
		    sts = walk_directory(wp, new_name);	/* then walk the directory */
		    qio_closedir(nioq, wp->dp);
		    wp->dp = olddp;
		}
	    } else {
		ChkSum *csp;
		find_cs(ot.fid, wp);		/* find checksum in checksum file */
		if (wp->this_cs) {
		    txt_setpos(pos_cookie);
		    txt_cstr(" (CS)", WHT_PAL);
		    prc_delay(0);
		}
		sts = read_check(nioq, wp);	/* read check the file */
		if (!sts && (csp=wp->this_cs)) {
		    if (csp->chksum != wp->cs || FAKE_CS_ERROR) {
#define BAD_CS_MSG1 "Checksum error on file."
#define BAD_CS_MSG2 "expected"
#define BAD_CS_MSG3 "computed"
			txt_str(-1, WALK_ERR_ROW, BAD_CS_MSG1, YEL_PAL);
			txt_str((AN_VIS_COL-3-sizeof(BAD_CS_MSG2)-1-8)/2,
    				WALK_ERR_ROW+1, BAD_CS_MSG2, YEL_PAL);
			txt_cstr(" 0x", GRN_PAL);
			txt_chexnum(csp->chksum, 8, RJ_ZF, GRN_PAL);
			txt_str((AN_VIS_COL-3-sizeof(BAD_CS_MSG3)-1-8)/2,
    				WALK_ERR_ROW+2, BAD_CS_MSG3, YEL_PAL);
			txt_cstr(" 0x", RED_PAL);
			txt_chexnum(wp->cs, 8, RJ_ZF, RED_PAL);
#if 0
txt_str(-1, WALK_ERR_ROW+3, "FID  ", WHT_PAL);
txt_chexnum(ot.fid, 8, RJ_ZF, WHT_PAL);
txt_str(-1, WALK_ERR_ROW+4, "Size ", WHT_PAL);
txt_chexnum(ot.eof, 10, RJ_ZF, WHT_PAL);
#endif
		    	sts = WALK_EXIT_ERR;
			++wp->errors;
		    }
		}
#ifdef EER_DSK_CORR
		if (wp->correctables) {
		    if (!(wp->banners&1)) {
			txt_str(WALK_CORR_COL, WALK_CORR_ROW, WALK_CORR_MSG, MNORMAL_PAL);
			wp->banners |= 1;
		    }
		    txt_decnum(WALK_CORR_COL+sizeof(WALK_CORR_MSG)-1,
			    WALK_CORR_ROW, wp->correctables, 4, RJ_BF, YEL_PAL);
		}
#endif
#ifdef EER_FSYS_USEALT
		if (wp->used_alts) {
		    if (!(wp->banners&2)) {
			txt_str(WALK_ALTS_COL, WALK_ALTS_ROW, WALK_ALTS_MSG, MNORMAL_PAL);
			wp->banners |= 2;
		    }
		    txt_decnum(WALK_ALTS_COL+sizeof(WALK_ALTS_MSG)-1,
			    WALK_ALTS_ROW, wp->used_alts, 4, RJ_BF, YEL_PAL);
		}
#endif
		qio_close(nioq);	/* done with this */
	    }
	}
	qio_freeioq(nioq);
	FREE_MEM(memamt, new_name);
	if (sts == WALK_EXIT_ABORT) break;
	if (sts == WALK_EXIT_ERR) {
	    st_insn(AN_VIS_ROW-3, "To continue,", t_msg_action, INSTR_PAL);
	    while (!(sts=ctl_read_sw(SW_ACTION|SW_NEXT)&(SW_ACTION|SW_NEXT))) { prc_delay(0); }
	    txt_clr_wid(2, AN_VIS_ROW-3, AN_VIS_COL-4);
	    if ((sts&SW_NEXT)) {
		sts = WALK_EXIT_ABORT;
		break;
	    }
	    txt_clr_wid(4, WALK_ERR_ROW+0, AN_VIS_COL-6);
	    txt_clr_wid(4, WALK_ERR_ROW+1, AN_VIS_COL-6);
	    txt_clr_wid(4, WALK_ERR_ROW+2, AN_VIS_COL-6);
	    txt_clr_wid(4, WALK_ERR_ROW+3, AN_VIS_COL-6);
	}
    }
    return sts;
}
#endif

#if QUIET_CHECK
static int wait_for_reply(void) {
    int sts, rtc;

    st_insn(AN_VIS_ROW-3, "To continue,", t_msg_action, INSTR_PAL);
    rtc = eer_rtc;
    while (!(sts=ctl_read_sw(SW_ACTION|SW_NEXT)&(SW_ACTION|SW_NEXT)) &&
	(eer_rtc - rtc) < 3*60) { prc_delay(0); }
    txt_clr_wid(2, AN_VIS_ROW-3, AN_VIS_COL-4);
    if ((sts&SW_NEXT)) {
	return WALK_EXIT_ABORT;
    }
    txt_clr_wid(4, WALK_ERR_ROW+0, AN_VIS_COL-6);
    txt_clr_wid(4, WALK_ERR_ROW+1, AN_VIS_COL-6);
    txt_clr_wid(4, WALK_ERR_ROW+2, AN_VIS_COL-6);
    txt_clr_wid(4, WALK_ERR_ROW+3, AN_VIS_COL-6);
    return 0;
}
#endif

#if FSYS_MAX_VOLUMES > 1
extern int ide_choose_drv(int choices);
#endif

int fsys_test(const struct menu_d *smp) {
    QioIOQ *ioq;
    int sts, row, active;
    static int been_here;
    FsysOpenT ot;
    char data_buffer[65536+QIO_CACHE_LINE_SIZE];
    char rawfn[10], volfn[10];
    Walker walk;
    char *msg;
    FsysVolume *vol;
    QioFile *fp;

#if !QUIET_CHECK
    DIR *dp;
#endif

    memset((char *)&walk, 0, sizeof(walk));
    walk.data_buff = (char *)(((int)data_buffer + QIO_CACHE_LINE_SIZE-1) & -QIO_CACHE_LINE_SIZE);
    walk.data_buff_size = 65536;
    memset(walk.data_buff, 0, walk.data_buff_size);

#if FSYS_MAX_VOLUMES > 1
    active = ide_choose_drv((1<<FSYS_MAX_VOLUMES)-1);
#else
    active = 0;
#endif
#if FSYS_MAX_VOLUMES > 9
# error You need to rework this code
#endif
    rawfn[0] = QIO_FNAME_SEPARATOR;
    rawfn[1] = 'r';
    rawfn[2] = 'd';
    rawfn[3] = '0' + active;
    rawfn[4] = 0;
    volfn[0] = QIO_FNAME_SEPARATOR;
    volfn[1] = 'd';
    volfn[2] = '0' + active;
    volfn[3] = 0;
    if (!(been_here&(1<<active))) {
#ifdef EER_FSYS_USEALT
	int alts;
	alts = eer_gets(EER_FSYS_USEALT);
#endif
	if (!been_here) {
	    ide_squawk(AN_VIS_ROW/2, (AN_VIS_COL-39-FSYS_MAX_VOLUMES-1)/2);
	    ide_init();
	    ide_unsquawk();
	}
#define MOUNTING_MSG "Mounting filesystem"
	if (smp) txt_str((AN_VIS_COL-sizeof(MOUNTING_MSG)-1-4-(FSYS_MAX_VOLUMES>1?2:0))/2,
			  AN_VIS_ROW/2, MOUNTING_MSG, WHT_PAL);
#if FSYS_MAX_VOLUMES > 1
	txt_cstr(" ", WHT_PAL);
	txt_cdecnum(active, 1, RJ_BF, WHT_PAL);
#endif
	txt_cstr(" ...", WHT_PAL);
	prc_delay(0);
	sts = fsys_mountw(rawfn, volfn);
	txt_clr_wid(2, AN_VIS_ROW/2, AN_VIS_COL-4);
	if (QIO_ERR_CODE(sts) && sts != FSYS_MOUNT_MOUNTED) {
	    txt_str(-1, WALK_ERR_ROW, "Failed to mount filesystem.", WHT_PAL);
	    qio_errmsg(sts, walk.data_buff, walk.data_buff_size);
	    txt_str(-1, WALK_ERR_ROW+2, walk.data_buff, YEL_PAL);
	    st_insn(AN_VIS_ROW-2, t_msg_ret_menu, t_msg_next, INSTR_PAL);
	    while (!(ctl_read_sw(SW_NEXT)&SW_NEXT)) { prc_delay(0); }
	    return 1;
	}
#ifdef EER_FSYS_USEALT
	walk.used_alts += eer_gets(EER_FSYS_USEALT) - alts;
#endif
	been_here |= 1<<active;
    }
    if (smp) st_insn(AN_VIS_ROW-2, t_msg_ret_menu, t_msg_next, INSTR_PAL);
    ioq = qio_getioq();
    if (!ioq) {
	txt_str(-1, WALK_ERR_ROW, "Ran out of IOQ's", RED_PAL);
	goto err_exit;
    }	    
    volfn[3] = QIO_FNAME_SEPARATOR;
    volfn[4] = '.';
    volfn[5] = 0;
    sts = qio_open(ioq, volfn, O_RDONLY);
    while (!sts) sts = ioq->iostatus;
    if (QIO_ERR_CODE(sts)) {
	strcpy(data_buffer, "Error opening ");
	strcat(data_buffer, volfn);
	msg = data_buffer;
	qio_freeioq(ioq);
	txt_str(-1, AN_VIS_ROW-7, msg, WHT_PAL);
	qio_errmsg(sts, walk.data_buff, walk.data_buff_size);
	txt_str(-1, AN_VIS_ROW-6, walk.data_buff, YEL_PAL);
err_exit:
	st_insn(AN_VIS_ROW-2, t_msg_ret_menu, t_msg_next, INSTR_PAL);
	while (!(ctl_read_sw(SW_NEXT)&SW_NEXT)) { prc_delay(0); }
	return 1;
    }
    fp = qio_fd2file(ioq->file);
    vol = (FsysVolume *)fp->dvc->private;
#define DISK_DRIVE_SIZ "Disk space available:  "
#define SPACE_USED_MSG "Filesystem occupies:   "
#define FILES_USED_MSG "Total files used:      "
    row = 4;
    {
	struct stat st;
	U32 lim;
	sts = stat(rawfn, &st);
	if (!sts && vol->maxlba != (lim=(st.st_size - (st.st_size%FSYS_MAX_ALTS)))) {
	    txt_str((AN_VIS_COL-sizeof(DISK_DRIVE_SIZ)-1-7)/2, row++, DISK_DRIVE_SIZ, WHT_PAL);
	    sts = (lim+100000)/200000;
	    txt_cdecnum(sts/10, 3, RJ_BF, WHT_PAL);
	    txt_cstr(".", WHT_PAL);
	    txt_cdecnum(sts - (sts/10)*10, 1, RJ_ZF, WHT_PAL);
	    txt_cstr("GB", WHT_PAL);
	    txt_str((AN_VIS_COL-sizeof(SPACE_USED_MSG)-1-7)/2, row++, SPACE_USED_MSG, WHT_PAL);
	    sts = (vol->maxlba+100000)/200000;
	    txt_cdecnum(sts/10, 3, RJ_BF, WHT_PAL);
	    txt_cstr(".", WHT_PAL);
	    txt_cdecnum(sts - (sts/10)*10, 1, RJ_ZF, WHT_PAL);
	    txt_cstr("GB", WHT_PAL);
	}
    }
    txt_str((AN_VIS_COL-sizeof(FILES_USED_MSG)-1-7)/2, row++, FILES_USED_MSG, WHT_PAL);
    txt_cdecnum(vol->files_ffree, 5, RJ_BF, WHT_PAL);
    sts = qio_close(ioq);
    while (!sts) sts = ioq->iostatus;
    ioq->timeout = 3000000;		/* 3 second timeout */
    strcpy(data_buffer, volfn);
#ifndef FSYS_CHECKSUM_FILENAME
# if QIO_FNAME_SEPARATOR == '/'
#  define FSYS_CHECKSUM_FILENAME "/diags/checksums"
# else
#  define FSYS_CHECKSUM_FILENAME "\\diags\\checksums"
# endif
#endif
    strcat(data_buffer, FSYS_CHECKSUM_FILENAME);
    ot.spc.path = data_buffer;
    ot.spc.mode = O_RDONLY;
    ot.fid = 0;
    sts = qio_openspc(ioq, &ot.spc);
    while (!sts) { sts = ioq->iostatus; }
    walk.cksums = 0;
    walk.numb_cksums = 0;
    walk.errors = 0;
    if (!QIO_ERR_CODE(sts)) {
	if (walk.data_buff_size <= ot.alloc) {	/* no room for file */
	    txt_str(-1, AN_VIS_ROW-7, "Not enough memory to hold checksum file.", WHT_PAL);
	} else {
	    sts = qio_read(ioq, walk.data_buff, walk.data_buff_size);
	    while (!sts) { sts = ioq->iostatus; }
	    if (QIO_ERR_CODE(sts)) {
		txt_str(-1, AN_VIS_ROW-7, "Error reading checksum file.", WHT_PAL);
		qio_errmsg(sts, walk.data_buff, walk.data_buff_size);
		txt_str(-1, AN_VIS_ROW-6, walk.data_buff, YEL_PAL);
	    } else {
		walk.cksums = (ChkSum *)walk.data_buff;
		walk.numb_cksums = ioq->iocount/sizeof(ChkSum);
		walk.data_buff += (ioq->iocount+QIO_CACHE_LINE_SIZE-1)&-QIO_CACHE_LINE_SIZE;
		walk.data_buff_size -= ioq->iocount;
		walk.data_buff_size &= -512;
	    }
	}
	qio_close(ioq);		/* we're done with this */
    }    
    if (walk.data_buff_size <= 4096) {
#if QUIET_CHECK
no_mem:
#endif
	txt_str(-1, WALK_ERR_ROW, "Sorry, not enough free memory to run this test", RED_PAL);
	while (!(ctl_read_sw(SW_ACTION|SW_NEXT)&(SW_ACTION|SW_NEXT))) { prc_delay(0); }
	ctl_read_sw(-1);
	qio_freeioq(ioq);
	return 0;
    }	
#if QUIET_CHECK
    do {
	sts = qio_open(ioq, volfn, O_RDONLY);		/* get a pointer to volume */
	while (!sts) { sts = ioq->iostatus; }
	if (QIO_ERR_CODE(sts)) {
	    qio_errmsg(sts, walk.data_buff, walk.data_buff_size);
	    txt_str(-1, WALK_ERR_ROW, walk.data_buff, YEL_PAL);
	    sts = 0;
	} else {
#if FSYS_MAX_ALTS > 4
# error *** You will have to fix this!!!
#endif
	    U8 *history;
	    int fid, pass, row;
	    qio_close(ioq);
	    history = QIOcalloc(vol->files_ffree, 1);	/* one byte per file */
	    if (!history) goto no_mem;
#define CHECK_MSG "Checking file: "
	    txt_str((AN_VIS_COL-sizeof(CHECK_MSG)-5)/2, WALK_ANN_ROW, CHECK_MSG, WHT_PAL);
	    for (pass=0; pass < FSYS_MAX_ALTS; ++pass) {
		for (fid=0; fid < vol->files_ffree; ++fid) {
		    FsysOpenT ot;
		    FsysRamFH *rfh;
		    int afid;
		    
		    rfh = vol->files + fid;
		    if (!rfh->valid) continue;
		    if (!rfh->ramrp[pass].rptrs) {
			history[fid] |= 1 << (pass*2);	/* this copy is unusable */
			continue; /* has no alternate */
		    }
		    memset((char *)&ot, 0, sizeof(ot));
		    ot.spc.path = volfn;
		    ot.spc.mode = O_RDONLY|O_OPNCPY;
		    afid = ot.fid = (rfh->generation << 24) | fid;
		    ot.copies = pass;
		    if (walk.cksums) find_cs(afid, &walk);
		    txt_decnum((AN_VIS_COL-sizeof(CHECK_MSG)-5)/2+sizeof(CHECK_MSG),
    				WALK_ANN_ROW, fid, 5, RJ_BF, GRN_PAL);
		    txt_cstr(".", GRN_PAL);
		    txt_cdecnum(pass, 1, RJ_ZF, GRN_PAL);
		    prc_delay(0);
		    sts = qio_openspc(ioq, &ot.spc);
		    while (!sts) { sts = ioq->iostatus; }
		    if (QIO_ERR_CODE(sts)) {
			qio_errmsg(sts, walk.data_buff, walk.data_buff_size);
			txt_str(-1, WALK_ERR_ROW, walk.data_buff, YEL_PAL);
			history[fid] |= 1 << (pass*2);
			++walk.errors;
			sts = wait_for_reply();
		    } else {
			ChkSum *csp;
			sts = read_check(ioq, &walk);
			qio_close(ioq);
			if (sts == WALK_EXIT_ERR) {
			    history[fid] |= 1 << (pass*2);
			}
#if defined(TEST_DISK_ERRORS) && TEST_DISK_ERRORS
# define FAKE_CS_ERROR (ctl_read_sw(IO_MISC6 << SH_MISC)&(IO_MISC6 << SH_MISC))
#else
# define FAKE_CS_ERROR 0
#endif
			if (!sts && ((csp=walk.this_cs) || FAKE_CS_ERROR )) {
			    if (!csp || (csp->chksum != walk.cs)) {
#define BAD_CS_MSG1 "Checksum error on file."
				txt_str(-1, WALK_ERR_ROW, BAD_CS_MSG1, YEL_PAL);
				history[fid] |= 2 << (pass*2);
				++walk.cs_errors;
				sts = 1;
			    }
			}
			if (walk.errors) {
			    if (!(walk.banners&1)) {
				txt_str(WALK_UCORR_COL, WALK_UCORR_ROW, WALK_UCORR_MSG, MNORMAL_PAL);
				walk.banners |= 1;
			    }
			    txt_decnum(WALK_UCORR_COL+sizeof(WALK_UCORR_MSG)-1,
				    WALK_UCORR_ROW, walk.errors, 4, RJ_BF, RED_PAL);
			}
			if (walk.cs_errors) {
			    if (!(walk.banners&2)) {
				txt_str(WALK_CKSUM_COL, WALK_CKSUM_ROW, WALK_CKSUM_MSG, MNORMAL_PAL);
				walk.banners |= 2;
			    }
			    txt_decnum(WALK_CKSUM_COL+sizeof(WALK_CKSUM_MSG)-1,
				    WALK_CKSUM_ROW, walk.cs_errors, 4, RJ_BF, RED_PAL);
			}
#ifdef EER_DSK_CORR
			if (walk.correctables) {
			    if (!(walk.banners&4)) {
				txt_str(WALK_CORR_COL, WALK_CORR_ROW, WALK_CORR_MSG, MNORMAL_PAL);
				walk.banners |= 4;
			    }
			    txt_decnum(WALK_CORR_COL+sizeof(WALK_CORR_MSG)-1,
				    WALK_CORR_ROW, walk.correctables, 4, RJ_BF, YEL_PAL);
			}
#endif
#ifdef EER_FSYS_USEALT
			if (walk.used_alts) {
			    if (!(walk.banners&8)) {
				txt_str(WALK_ALTS_COL, WALK_ALTS_ROW, WALK_ALTS_MSG, MNORMAL_PAL);
				walk.banners |= 8;
			    }
			    txt_decnum(WALK_ALTS_COL+sizeof(WALK_ALTS_MSG)-1,
				    WALK_ALTS_ROW, walk.used_alts, 4, RJ_BF, YEL_PAL);
			}
#endif
			if (sts) sts = wait_for_reply();
		    }
		    if (sts == WALK_EXIT_ABORT) break;
		}
		if (sts == WALK_EXIT_ABORT) break;
	    }
	    if (sts != WALK_EXIT_ABORT) {
		for (row=WALK_ANN_ROW; row <= WALK_ERR_ROW; ++row) {
		    txt_clr_wid(2, row, AN_VIS_COL-4);
		}
#if 0
		for (row=AN_VIS_ROW-8; row <= AN_VIS_ROW-5; ++row) {
		    txt_clr_wid(2, row, AN_VIS_COL-4);
		}
#endif
		if (sts == WALK_EXIT_OK) {
		    if (!walk.errors && !walk.cs_errors && !walk.used_alts) {
			if (!walk.correctables) {
#define AOK_MSG "Filesystem is "
			    txt_str((AN_VIS_COL-sizeof(AOK_MSG)-1-4)/2, AN_VIS_ROW/2, AOK_MSG, WHT_PAL);
			    txt_cstr("A-OK", GRN_PAL);
			} else {
			    txt_str(-1, AN_VIS_ROW/2-1, "The errors listed will be corrected by h/w.",
					    WHT_PAL);
			    txt_str((AN_VIS_COL-16)/2+1, AN_VIS_ROW/2+1, "Filesystem is ", WHT_PAL);
			    txt_cstr("OK", GRN_PAL);
			}
		    } else {
			int cs_err=0, fatal=0, jj;
			for (sts=0; sts < vol->files_ffree; ++sts) {
			    int hw = 0;
			    if ((history[sts]&0xAA)) {
				++cs_err;
			    } else {
				for (jj=0; jj < FSYS_MAX_ALTS; ++jj) {
				    if ((history[sts]&(1<<jj*2))) ++hw;
				}
				if (hw >= FSYS_MAX_ALTS) ++fatal;
			    }
			}
			if (fatal || cs_err) {
			    int c;
			    char *str;
			    str = (fatal+cs_err > 1) ?
			    	"Some of the errors listed cannot be corrected." :
			    	"The errors listed cannot be corrected.";
			    txt_str(-1, AN_VIS_ROW/2-1, str, YEL_PAL);
			    if (fatal) {
				txt_str(-1, AN_VIS_ROW/2+1, "The filesystem is broken and is not usable", RED_PAL);
			    } else {
#define NFG_MSG_P " files are corrupt. The game might not work."
#define NFG_MSG_S " file is corrupt. The game might not work."
				if (cs_err > 1) {
				    c = (AN_VIS_COL-sizeof(NFG_MSG_P)-1-4)/2;
				    str = NFG_MSG_P;
				} else {
				    c = (AN_VIS_COL-sizeof(NFG_MSG_S)-1-4)/2;
				    str = NFG_MSG_S;
				}
				txt_decnum(c, AN_VIS_ROW/2+1, cs_err, 4, RJ_BF, RED_PAL);
				txt_cstr(str, YEL_PAL);
			    }
			} else {
			    txt_str(-1, AN_VIS_ROW/2-1, "The errors listed can be corrected by s/w.", WHT_PAL);
			    txt_str(-1, AN_VIS_ROW/2+1, "The filesystem is unhealthy but remains usable", YEL_PAL);
			}
		    }
		} else {
		    txt_str(-1, AN_VIS_ROW/2-1, "Due to the severity of the errors detected,", WHT_PAL);
		    txt_str(-1, AN_VIS_ROW/2, "the filesystem is probably not usable", YEL_PAL);
		}
		sts = 0;
	    }
	    QIOfree(history);
	}
    } while (0);
#else
    sts = qio_opendir(ioq, (void *)&dp, volfn);	/* open root directory */
    while (!sts) { sts = ioq->iostatus; }
    if (QIO_ERR_CODE(sts)) {
	qio_errmsg(sts, walk.data_buff, walk.data_buff_size);
	txt_str(-1, WALK_ERR_ROW, walk.data_buff, YEL_PAL);
	sts = 0;
    } else {
	if (walk.numb_cksums) txt_str(6, AN_VIS_ROW-5, "(CS) = File's checksum is being computed and compared", WHT_PAL);
	walk.dp = dp;
	walk.ioq = ioq;
	sts = walk_directory(&walk, volfn);
	qio_closedir(ioq, (void *)dp);
	if (sts != WALK_EXIT_ABORT) {
	    int row;
	    for (row=WALK_ANN_ROW; row <= WALK_ERR_ROW; ++row) {
		txt_clr_wid(2, row, AN_VIS_COL-4);
	    }
	    for (row=AN_VIS_ROW-8; row <= AN_VIS_ROW-5; ++row) {
		txt_clr_wid(2, row, AN_VIS_COL-4);
	    }
	    if (sts == WALK_EXIT_OK && !walk.errors) {
		txt_str(-1, AN_VIS_ROW/2, "No uncorrectable errors detected.", WHT_PAL);
		txt_str(-1, AN_VIS_ROW/2+1, "Filesystem is ", WHT_PAL);
		txt_cstr("OK", GRN_PAL);
	    } else {
		txt_str(-1, AN_VIS_ROW/2, "Filesystem is not OK", YEL_PAL);
		txt_str((AN_VIS_COL-17-6-21)/2, AN_VIS_ROW/2+2, "Found a total of ", WHT_PAL);
		txt_cdecnum(walk.errors, 6, RJ_BF, RED_PAL);
		txt_cstr(" uncorrectable errors", WHT_PAL);
	    }
	    sts = 0;
	}
    }
    if (walk.numb_cksums) txt_clr_wid(6, AN_VIS_ROW-5, AN_VIS_COL-6-2);
#endif
    if (!sts) while (!(ctl_read_sw(SW_NEXT)&SW_NEXT)) { prc_delay(0); }
    qio_freeioq(ioq);
    ctl_read_sw(-1);
    return 0;
}
#endif			/* !NO_FSYS_TEST */
@


1.75
log
@Got rid of bit fields.
@
text
@d2 1
a2 1
 * $Id: fsys.c,v 1.72 1997/10/30 21:35:50 shepperd Exp shepperd $
d25 4
d38 4
a41 2

#if FSYS_SQUAWKING || FSYS_FREE_SQUAWKING || FSYS_SYNC_SQUAWKING
d47 7
a53 2
# define FSYS_SQK(x) iio_printf x
# define OUTWHERE fsys_iop,
d59 8
a66 2
# define SYNSQK(x) iio_printf x
# define OUTWHERE fsys_iop,
d317 2
a318 1
    int nelts;		/* number of elements in freelist */
d358 1
a358 1
#if 0 && FSYS_FREE_SQUAWKING
d363 6
a368 5
	iio_printf(fsys_iop, "%6d: findfree before. rqst=%d, hint=%d, lo_lim=%d, items=%d.\n",
	    eer_rtc, ft->request, ft->hint, ft->lo_limit, ft->nelts);
	for (ii=0; ii < ft->nelts; ++ii, ++dst) {
	    iio_printf(fsys_iop, "\t    %3d: start=%7d, nblocks=%7d\n",
		ii, dst->start, dst->nblocks);
d376 1
a376 1
    for (ii=0; ii < ft->nelts; ++ii, ++fp) { /* look through the list for one that fits */
d385 22
a406 1
	if (fp->start < ft->lo_limit) continue; /* keep looking */
d453 1
a453 3
    FSYS_SQK(( OUTWHERE "%6d: find_free returns %d. rqst=%d, start=%d, nblocks=%d.\n",
    	eer_rtc, free->start == 0, ft->request, free->start, free->nblocks));
#if 0 && FSYS_FREE_SQUAWKING
d458 5
a462 5
	iio_printf(fsys_iop, "        after. %d items. Patched entry %d\n",
	    ft->nelts, ft->which_elem);
	for (ii=0; ii < ft->nelts; ++ii, ++dst) {
	    iio_printf(fsys_iop, "\t   %c%3d: start=%7d, nblocks=%7d\n",
		ii == ft->which_elem ? '*' : ' ', ii, dst->start, dst->nblocks);
d464 2
a465 2
	iio_printf(fsys_iop, "        Returned to caller: start=%d, nblocks=%d\n",
	    free->start, free->nblocks);
d467 3
d515 3
a517 1
    freet.nelts = vol->free_ffree;
a538 1
	freet.lo_limit = FSYS_HB_ALG(where, vol->maxlba);
d541 7
a547 1
	    return FSYS_EXTEND_FULL;		/* disk has become full */
d549 1
d714 2
d729 9
a737 1
	if (ioq->iostatus) return 1;
d740 2
d770 2
d827 1
d866 8
d1199 2
a1200 2
    iio_printf(fsys_iop, "%6d: Increasing size of free list. free_ffree=%d, free_elems = %d\n",
		eer_rtc, vol->free_ffree, vol->free_elems);
d1689 2
a1690 1
	    freet.nelts = vol->free_ffree;
d1696 1
a1696 1
		freet.lo_limit = FSYS_HB_ALG(bcnt, vol->maxlba);
d1706 1
d1749 1
a1749 1
	for (ii=0; ii < FSYS_MAX_ALTS; ++ii) {		/* add retrieval pointers to the file */
d1755 7
a1761 9
	    if (ii < dtls->copies) {
		where = dtls->placement + ii;
		if (where >= FSYS_MAX_ALTS) where = FSYS_MAX_ALTS-1;
		sts = extend_file(vol, rfh->clusters, rp, where);
		if (sts) {
		    zap_file( &luf );			/* remove all traces of this file */
		    ioq->iostatus = sts;
		    break;
		}
d1989 1
a1989 1
	    if (his && ((his->copies < 1 || his->copies > FSYS_MAX_ALTS) ||
d1994 1
d2448 1
a2448 1
#  if FSYS_SQUAWKING
d2450 1
a2450 1
		    extern void fsys_dump_bytes(IcelessIO *iop, U8*s, int siz);
d2452 1
a2452 1
		    fsys_dump_bytes(fsys_iop, (U8*)syn->output, dst - (char *)syn->output);
d2723 3
d2728 3
a2730 3
		    iio_printf(fsys_iop, "%6d: sync error writing INDEX %d. u_len=%d, sector=%d\n",
			    eer_rtc, syn->alts, qio->u_len, syn->start);
		    iio_printf(fsys_iop, "        Reason: \"%s\"\n", emsg);
d2750 1
a2750 1
		    iio_printf(fsys_iop, "%6d: sync_upd_free: %d entries\n", eer_rtc, vol->free_ffree);
d2752 2
a2753 2
			iio_printf( fsys_iop, "        %3d: start=%7d, nblocks=%6d\n",
				ii, rp->start, rp->nblocks);
d2775 3
a2777 3
		    iio_printf(fsys_iop, "%6d: sync error writing FREE %d. u_len=%d, sector=%d\n",
			    eer_rtc, syn->alts, qio->u_len, syn->start);
		    iio_printf(fsys_iop, "        Reason: \"%s\"\n", emsg);
d2902 1
d3008 1
a3008 1
		qio->sector = FSYS_HB_ALG(vol->substate, vol->maxlba); /* relative sector number */
d3015 8
d3031 4
a3034 3
		    if (++vol->substate < FSYS_MAX_ALTS) {
			vol->state = MOUNT_RD_HOME;
			continue;		/* recurse (read next home block) */
d3036 5
a3040 1
		    vol->state = MOUNT_SEARCH_HOME;	/* search for home block */
d3047 1
d3055 1
a3055 1
		nxt = (vol->substate-FSYS_MAX_ALTS+1)*256 + 1;
d3116 1
a3116 1
			if (!sect || (!(sect&0x80000000) && sect >= vol->maxblocks)) {	/* if value is illegal */
d3419 5
a3423 5
    vol->maxlba = fs.st_size - (fs.st_size % FSYS_MAX_ALTS); /* keep device size in sectors */
#if !WATCOM_LIBC
    vol->maxblocks = fs.st_blocks;	/* get physical limit */
#else
    vol->maxblocks = vol->maxlba;	/* get physical limit (same as max sectors in DOS/Windows) */
d3425 3
d3444 1
a3444 1
static void mk_freelist(FsysRetPtr *list, int nelts, int size) {
d3447 1
d3455 1
a3455 1
	hb = FSYS_HB_ALG(ii, size);
d3457 2
d3477 6
d3484 1
a3525 1
    int size;
a3530 1
    size = fin->max_lba;
d3564 1
d3647 1
d3669 2
a3670 1
		freet.nelts = fin->free_nelts;
d3677 1
a3677 1
		    freet.lo_limit = FSYS_HB_ALG(bcnt, fin->max_lba);
d3778 1
a3778 1
		fin->q.sector = FSYS_HB_ALG(fin->substate, fin->max_lba);
d4817 8
a4824 1
		    fin.max_lba = drvstat.st_size;
d4852 1
a4852 1
#if FSYS_SQUAWKING || FSYS_FREE_SQUAWKING || FSYS_SYNC_SQUAWKING
d5294 3
a5296 1
    strcpy(rawfn, "/rd");
d5299 2
a5300 1
    strcpy(volfn, "/d");
d5343 3
a5345 1
    strcat(volfn, "/.");
d5364 1
a5364 1
#define SPACE_USED_MSG "Filesystem space used: "
d5367 18
a5384 13
    if (vol->maxlba != vol->maxblocks) {
	txt_str((AN_VIS_COL-sizeof(DISK_DRIVE_SIZ)-1-7)/2, row++, DISK_DRIVE_SIZ, WHT_PAL);
	sts = (vol->maxblocks+100000)/200000;
	txt_cdecnum(sts/10, 3, RJ_BF, WHT_PAL);
	txt_cstr(".", WHT_PAL);
	txt_cdecnum(sts - (sts/10)*10, 1, RJ_ZF, WHT_PAL);
	txt_cstr("GB", WHT_PAL);
	txt_str((AN_VIS_COL-sizeof(SPACE_USED_MSG)-1-7)/2, row++, SPACE_USED_MSG, WHT_PAL);
	sts = (vol->maxlba+100000)/200000;
	txt_cdecnum(sts/10, 3, RJ_BF, WHT_PAL);
	txt_cstr(".", WHT_PAL);
	txt_cdecnum(sts - (sts/10)*10, 1, RJ_ZF, WHT_PAL);
	txt_cstr("GB", WHT_PAL);
d5392 8
a5399 1
    strcat(data_buffer, "/diags/checksums");
@


1.74
log
@Fixed more Watcom compiler warnings.
@
text
@d2 1
a2 1
 * $Id: fsys.c,v 1.73 1997/11/01 22:48:35 shepperd Exp shepperd $
d173 1
a173 1
    int cnt;				/* max number of sectors */
d901 1
a901 1
    if (!de->name || !de->fid || !de->generation) {
d910 1
a910 1
    if (!de->name || !de->fid || !de->generation) {
d950 1
a950 1
    if (!new->name || !new->fid || !new->generation) {
d1022 1
a1022 1
	if (!dir || !(fid=dir->fid)) {
d1026 1
a1026 1
	if (top->generation != dir->generation) {
d1041 1
a1041 1
    if (dir && (fid=dir->fid)) {
d1043 1
a1043 1
	if (lu->file->generation == dir->generation) {
d1589 1
a1589 1
	    luf.dir->generation = gen;		/* restore generation number in directory */
d1642 1
a1642 2
	    dp->generation = rfh->generation;
	    dp->fid = fid;
d1721 1
a1721 2
	    inddir->fid = luf.owner - vol->files;
	    inddir->generation = luf.owner->generation;
d1727 1
a1727 2
	    inddir->fid = rfh - vol->files;
	    inddir->generation = rfh->generation;
d2060 1
a2060 1
	inddir->fid = 0;		/* assume invalid entry */
d2063 1
a2063 2
	    inddir->fid = fid;
	    inddir->generation = gen;
d2091 1
a2091 2
	    inddir->fid = fid;
	    inddir->generation = gen;
d2354 4
a2357 4
			*dst++ = dir->fid;
			*dst++ = dir->fid>>8;
			*dst++ = dir->fid>>16;
			*dst++ = dir->generation;
d3837 1
a3837 2
	dp->generation = src.dir->generation;
	dp->fid = src.dir->fid;
d4566 1
a4566 1
	direct->fid = (dp->current->generation << 24) | dp->current->fid;
d4960 6
@


1.73
log
@Fixed Watcom compiler warnings.
@
text
@d2 1
a2 1
 * $Id: fsys.c,v 1.72 1997/10/30 21:35:50 shepperd Exp shepperd $
d4762 1
a4762 1
#if !NO_FSYS_TEST
d5366 1
a5366 1
#if TEST_DISK_ERRORS
@


1.72
log
@Changed fundemental types for read/write to off_t for postion
and long for length.
@
text
@d2 1
a2 1
 * $Id: fsys.c,v 1.71 1997/10/04 20:35:23 shepperd Exp shepperd $
a9 1
#include <sys/types.h>
d14 5
d24 4
a27 4
#define QIO_LOCAL_DEFINES 1
#include <qio.h>
#include <fsys.h>
#include <eer_defs.h>
d31 2
@


1.71
log
@xxx_reent are pointers now rather than structs.
@
text
@d2 1
a2 1
 * $Id: fsys.c,v 1.70 1997/09/24 22:49:26 shepperd Exp shepperd $
a22 2
#include <glide.h>
#include <intvecs.h>
a23 1
#include <iio_proto.h>
d30 1
d3328 1
d3330 3
d3874 1
a3874 1
    size_t where;
d3908 1
a3908 1
static int fsys_lseek( QioIOQ *ioq, size_t where, int whence ) {
d3968 1
a3968 1
    size_t where;
d4000 1
a4000 1
static int validate_read( QioIOQ *ioq, void *buf, int len) {
d4035 1
a4035 1
static int fsys_readwpos( QioIOQ *ioq, size_t where, void *buf, int len ) {
d4051 1
a4051 1
    size_t where;
d4068 1
a4068 1
static int fsys_read( QioIOQ *ioq, void *buf, int len ) {
d4133 1
a4133 1
static int validate_write( QioIOQ *ioq, const void *buf, int len ) {
d4171 1
a4171 1
static int fsys_writewpos( QioIOQ *ioq, size_t where, const void *buf, int len ) {
d4186 1
a4186 1
    size_t where;
d4195 1
a4195 1
static int fsys_write( QioIOQ *ioq, const void *buf, int len ) {
d4462 1
d4465 1
d4756 1
d4774 1
d5527 1
@


1.70
log
@Calls ide_squawk before doing an ide_init() in fsys_test.
@
text
@d2 1
a2 1
 * $Id: fsys.c,v 1.69 1997/09/24 21:35:14 shepperd Exp shepperd $
d806 3
a808 3
# define QM_ALLOC_CALLOC(x,y) guts_calloc_r( (void *)&qio_reent, x, y, file, lineno)
# define QM_ALLOC_REALLOC(x,y) guts_realloc_r( (void *)&qio_reent, x, y, file, lineno)
# define QM_ALLOC_FREE(x) guts_free_r((void *)&qio_reent, x, file, lineno)
@


1.69
log
@Fixed fsys_test to handle multiple volumes. Calles
ide_choose_drv() to do a drive select.
@
text
@d2 1
a2 1
 * $Id: fsys.c,v 1.68 1997/09/19 22:51:22 shepperd Exp shepperd $
d3265 3
d5181 5
a5185 1
	if (!been_here) ide_init();
@


1.68
log
@Removed a bunch of redundant code.
@
text
@d2 1
a2 1
 * $Id: fsys.c,v 1.67 1997/09/19 22:31:45 shepperd Exp shepperd $
d5134 4
d5140 1
a5140 1
    int sts, row;
d5144 1
d5159 15
a5173 1
    if (!been_here) {
d5178 9
a5186 2
	ide_init();
	if (smp) txt_str(-1, AN_VIS_ROW/2, "Mounting filesystem ...", WHT_PAL);
d5188 1
a5188 1
	sts = fsys_mountw("/rd0", "/d0");
d5201 1
a5201 1
	been_here = 1;
d5209 2
a5210 1
    sts = qio_open(ioq, "/d0/.", O_RDONLY);
d5213 3
a5215 1
	msg = "Error opening /d0/.";
d5250 3
a5252 1
    ot.spc.path = "/d0/diags/checksums";
d5292 1
a5292 1
	sts = qio_open(ioq, "/d0/.", O_RDONLY);		/* get a pointer to volume */
d5322 1
a5322 1
		    ot.spc.path = "/d0";
d5474 1
a5474 1
    sts = qio_opendir(ioq, (void *)&dp, "/d0/.");	/* open root directory */
d5484 1
a5484 1
	sts = walk_directory(&walk, "/d0");
@


1.67
log
@Fixed bug introduced with the FSYS_MAX_CAPACITY and
using drives that have not yet been authored with the
MAX. Added some status messages in the fsys_test screen.
@
text
@d2 1
a2 1
 * $Id: fsys.c,v 1.66 1997/09/04 06:03:15 shepperd Exp shepperd $
a5140 1
    struct stat drvstat;
d5183 1
a5183 1
    sts = qio_open(ioq, "/rd0", O_RDONLY);
d5186 1
a5186 2
	msg = "Error opening /rd0 for read.";
stat_err:
a5194 17
    }		
    sts = qio_fstat(ioq, &drvstat);
    while (!sts) sts = ioq->iostatus;
    if (QIO_ERR_CODE(sts)) {
	int lstat;
	msg = "Error fstat'ing /rd0.";
	lstat = qio_close(ioq);
	while (!lstat) lstat = ioq->iostatus;
	goto stat_err;
    }
    sts = qio_close(ioq);
    while (!sts) sts = ioq->iostatus;
    sts = qio_open(ioq, "/d0/.", O_RDONLY);
    while (!sts) sts = ioq->iostatus;
    if (QIO_ERR_CODE(sts)) {
	msg = "Error opening /d0/.";
	goto stat_err;
d5202 1
a5202 1
    if (drvstat.st_size != drvstat.st_blocks) {
d5204 1
a5204 1
	sts = (drvstat.st_blocks+100000)/200000;
d5210 1
a5210 1
	sts = (drvstat.st_size+100000)/200000;
@


1.66
log
@Protected references to callers_ioq.
@
text
@d2 1
a2 1
 * $Id: fsys.c,v 1.65 1997/09/04 01:07:49 shepperd Exp shepperd $
d3024 15
a3038 5
		    for (ii=0; ii < FSYS_MAX_ALTS; ++ii) { /* check to see if any of them are bad */
			sect = *p++;
			if (!sect || (sect&0x80000000) || sect >= vol->maxlba) {
			    bad = 1;
			    break;
d3041 10
a3050 4
		    if (bad) {				/* if any are bad, they all are suspect */
#if !FSYS_READ_ONLY
			if ((*ulp&0x80000000)) {	/* maybe the first one is simply a unused marker */
			    add_to_unused(vol, vol->files_indx); /* it is, add it to the unused list */
a3051 3
#endif
			p = ulp;
			for (ii=0; ii < FSYS_MAX_ALTS; ++ii) *p++ |= 0x80000000; /* make them all illegal */
d3201 1
d3203 12
a3214 3
		    if (ulp[0] != vol->index_lbas[0] || /* validate the index file */
		    	ulp[1] != vol->index_lbas[1] || 
		    	ulp[2] != vol->index_lbas[2]) {
d3327 1
d5136 1
a5136 1
    int sts;
d5141 4
d5182 12
d5197 42
a5238 1
    }	    
a5286 2
	    QioFile *fp;
	    FsysVolume *vol;
a5291 2
	    fp = qio_fd2file(ioq->file);
	    vol = (FsysVolume *)fp->dvc->private;
@


1.65
log
@Added $Id$ and copyright boilerplate.
Passed user's timeout value to hd read/write routines.
Added a FSYS_DEFAULT_TIMEOUT which can be used if user
timeout not provided. Added some timeout test code.
@
text
@d2 1
a2 1
 * $Id$
d587 2
a588 1
		ioq->timeout = arg->callers_ioq->timeout;
d590 1
a590 1
		if (!ioq->timeout) ioq->timeout = FSYS_DEFAULT_TIMEOUT;
d592 1
d714 2
a715 1
		ioq->timeout = arg->callers_ioq->timeout;
d717 1
a717 1
		if (!ioq->timeout) ioq->timeout = FSYS_DEFAULT_TIMEOUT;
d719 1
@


1.64
log
@Corrected setting of fsys_sync_time.
@
text
@d1 9
d51 1
d587 4
a590 1
		ioq->timeout = 0;
d712 4
d4696 8
d4878 7
@


1.63
log
@Added function fsys_sync_delay() allowing one to change the
rate at which the sync task runs.
@
text
@d2717 3
d2733 3
d2769 1
a2769 1
    old = fsys_sync_time;
@


1.62
log
@Removed reference to bss_end so it didn't clobber any
malloc'd regions. fsys_test() needs a large stack now.
@
text
@d2744 2
d2753 1
a2753 1
    f->sync_t.delta = FSYS_SYNC_TIMER; /* requeue the sync timer */
d2756 24
@


1.61
log
@Fixed yet another bug where I forgot to preclear the index
bit map. This is the real reason the bug fixed in the prior
version manifested itself randomly.
@
text
@d5047 1
a5047 1
    extern char bss_end[];
d5055 2
a5056 2
    walk.data_buff = (char *)(((int)bss_end + QIO_CACHE_LINE_SIZE-1) & -QIO_CACHE_LINE_SIZE);
    walk.data_buff_size = ((((int)&walk-8192)&-8192) - (int)walk.data_buff) & -512;
@


1.60
log
@Added more sync squawk code.
@
text
@d1136 1
a1136 1
	int newsize;
d1143 2
d2543 1
a2543 1
		if (!syn->substate) {
@


1.59
log
@Fixed bug in index file update if more sectors of index
file are to be written than sync buffer size allows.
@
text
@d2535 1
a2535 1
		int nelems;
d2540 10
d2599 3
a2602 5
		start_bytes = start*512;
		if (sects_bytes > syn->buffer_size) {
		    sects = syn->buffer_size/512;
		    sects_bytes = syn->buffer_size;
		}
d2605 3
a2607 2
		if (start_bytes+sects_bytes > vol->files_ffree*FSYS_MAX_ALTS*sizeof(U32)) {
		    int len = vol->files_ffree*FSYS_MAX_ALTS*sizeof(U32) - start_bytes;
@


1.58
log
@Oops, forgot to remove local prototype of ide_init().
@
text
@d1416 1
a1416 1
	add_to_dirty(vol, FSYS_INDEX_INDEX, 0);
d2568 1
a2568 1
		while (!sects) {
d2588 1
a2588 2
		    if (sects > syn->buffer_size/512) break;
		}
d2592 1
a2592 1
		    sects = syn->buffer_size;
@


1.57
log
@Added call to ide_init() in fsys_mountw().
@
text
@a5036 1
    extern void ide_init(void);
@


1.56
log
@Corrected bug in fsys_ioctl(SETFH).
@
text
@d3202 1
@


1.55
log
@fsys_ioctl should return errors on read only filesystems.
Made fsys_ioctl(SETFH) lock filesystem instead of file so
file extends can happen.
@
text
@d4269 2
a4270 1
	    break;
@


1.54
log
@Added a new fsys_ioctl() function.
@
text
@d4114 1
d4120 2
d4123 2
a4124 1
    int fid, afid, ii, jj, copies;
d4132 7
a4142 6
    if ((ctl->fields&FSYS_FHFIELDS_CTIME)) rfh->ctime = ctl->ctime;
    if ((ctl->fields&FSYS_FHFIELDS_MTIME)) rfh->mtime = ctl->mtime;
#if (FSYS_FEATURES&FSYS_OPTIONS&FSYS_FEATURES_ABTIME)
    if ((ctl->fields&FSYS_FHFIELDS_ATIME)) rfh->atime = ctl->atime;
    if ((ctl->fields&FSYS_FHFIELDS_BTIME)) rfh->btime = ctl->btime;
#endif    
d4175 4
a4185 3
    if ((ctl->fields&FSYS_FHFIELDS_DEFEXT)) {
	rfh->def_extend = (ctl->def_extend+511)/512;
    }
d4188 1
d4190 2
a4191 1
    qio_freemutex(&fp->mutex, ioq);
d4194 1
d4200 1
d4204 1
a4209 1
	    FsysVolume *vol;
a4216 1
	    vol = (FsysVolume *)fp->dvc->private;
d4254 7
d4265 1
d4268 4
a4271 1
	    sts = qio_getmutex(&fp->mutex, ioctl_setfh, ioq);
d4273 1
@


1.53
log
@Index file wasn't being automatically extended.
Index sectors weren't being updated correctly if they
straddled a sector boundary.
Zero filled to end of file on Index file writes.
@
text
@d4114 78
a4191 1
static int fsys_ioctl( QioIOQ *ioq, unsigned int arg1, unsigned long arg2 ) {
d4193 62
a4254 1
    return (ioq->iostatus = FSYS_IO_NOSUPP);
@


1.52
log
@Fixed bug in fsys_lseek (it wasn't returning the pos value).
@
text
@d508 1
a508 1
		    rp->rptrs = (FsysRetPtr *)QIOmalloc(NUM_RET_PTR_TOP*sizeof(FsysRetPtr));
d515 1
a515 1
		    trp = (FsysRamRP *)QIOmalloc(sizeof(FsysRamRP)+NUM_RET_PTR_CHAIN*sizeof(FsysRetPtr));
d1036 2
a1037 2
	vol->unused = (U32*)QMOUNT_REALLOC(vol, vol->unused, vol->unused_elems*sizeof(long));
	if (!vol->unused) {
d1040 1
d1075 2
a1076 2
	vol->dirty = (U32*)QMOUNT_REALLOC(vol, vol->dirty, new*sizeof(long));
	if (!vol->dirty) {
d1079 1
d1098 2
d1108 3
a1110 2
    vol->free = (FsysRetPtr *)QMOUNT_REALLOC(vol, vol->free, size);
    if (!vol->free) return FSYS_EXTEND_NOMEM;	/* ran out of memory */
d1128 3
a1130 1
    int lw, bits;
d1139 2
a1140 3
	vol->index_bits = (U32*)QMOUNT_REALLOC(vol, vol->index_bits, newsize*sizeof(long));
	if (!vol->index_bits) {
	    vol->index_bits_elems = 0;
d1143 1
d1146 5
a1150 4
    lw = fid*FSYS_MAX_ALTS*sizeof(long); /* byte position in index file */
    lw /= 512;				/* sector position in index file */
    fid = lw&31;			/* bit position in bitmap element */
    lw /= 32;				/* longword element in bitmap */
d1154 4
d1383 1
d1387 2
a1388 2
	    vol->files = (FsysRamFH *)QMOUNT_REALLOC(vol, vol->files, new_size*sizeof(FsysRamFH));
	    if (!vol->files) {
d1391 3
a1393 2
	    vol->index = (U32*)QMOUNT_REALLOC(vol, vol->index, new_size*sizeof(U32)*FSYS_MAX_ALTS);
	    if (!vol->index) {
d1396 1
d1400 16
a1415 1
	vol->files[FSYS_INDEX_INDEX].size += sizeof(long)*FSYS_MAX_ALTS;
d1467 4
a1470 2
    add_to_unused(vol, fid);		/* mark FH as unused */
    upd_index_bits(vol, fid);		/* need to update index file */
d1582 1
a1582 1
		ioq->iostatus = fid ? fid : FSYS_CREATE_NOFH;
d1634 3
a1636 1
	rfh->def_extend = dtls->def_extend;
d1640 1
a1640 1
	    sectors = rfh->def_extend ? rfh->def_extend : FSYS_DEFAULT_EXTEND;
d1900 1
a1900 1
	ours = QIOmalloc(sizeof(FsysOpenFileT)+sizeof(FsysOpenT));
a1908 5
	    his->fid = 0;
	    his->parent = 0;
	    his->alloc = 0;
	    his->eof = 0;
	    his->placement = 0;
a1909 1
	    his->mkdir = 0;
d1960 1
a1960 1
	ours = QIOmalloc(sizeof(FsysOpenFileT)+sizeof(FsysOpenT));
a1967 5
	his->fid = 0;
	his->parent = 0;
	his->alloc = 0;
	his->eof = 0;
	his->placement = 0;
d2102 3
d2534 1
a2534 1
		int elem, sects, start;
d2590 6
a2595 1
		if (sects > syn->buffer_size/512) sects = syn->buffer_size/512;
d2597 7
a2603 1
		memcpy((char *)syn->output, (char *)(vol->index)+start*512, sects*512);
d2607 1
a2607 1
		qio->u_len = sects*512;
d3057 3
d3076 1
d3078 2
a3079 2
			vol->buff = (U32*)QMOUNT_REALLOC(vol, (void *)vol->buff, vol->buff_size); /* give back old buffer */
			if (!vol->buff) {
d3083 1
@


1.51
log
@Ooops. Replaced a line accidently deleted in the previous version.
@
text
@d3760 1
@


1.50
log
@Chasing a bug in new file creation with memory miser
mode on. It still might not be fixed.
@
text
@d1351 1
a1351 1
    int fid, gen;
a1370 1
	int ii;
a1381 2
	    memset((char *)(vol->files+vol->files_elems), 0, 32*sizeof(FsysRamFH));
	    memset((char *)(vol->index+vol->files_elems*FSYS_MAX_ALTS), 0, 32*sizeof(U32)*FSYS_MAX_ALTS);
a1384 4
	ulp = vol->index + fid*FSYS_MAX_ALTS;	/* point to index */
	for (ii=0; ii < FSYS_MAX_ALTS; ++ii) {
	    *ulp++ = 0x80000000 | gen;		/* make pointers to FH's invalid */
	}
d1386 5
@


1.49
log
@Fixed WDOG problem in standalone ST.
@
text
@d1371 1
d1388 4
a1392 1
	add_to_dirty(vol, FSYS_INDEX_INDEX, 0);
a1396 1
    upd_index_bits(vol, fid);
d1588 1
@


1.48
log
@Fixed more sync bugs. Sped up sync task.
@
text
@d19 4
d3124 1
a3124 1
#if defined(WDOG) && !BOOT_FROM_DISK
d3153 1
a3153 1
#if defined(WDOG) && !BOOT_FROM_DISK
d3164 1
a3164 1
#if defined(WDOG) && !BOOT_FROM_DISK
d3177 1
a3177 1
#if defined(WDOG) && !BOOT_FROM_DISK
d3189 1
a3189 1
#if defined(WDOG) && !BOOT_FROM_DISK
d3205 1
a3205 1
#if defined(WDOG) && !BOOT_FROM_DISK
@


1.47
log
@Fixed bug where alternate freelist was not written correctly.
Made mount more robust if some files are corrupt.
Added report of alternates used detected during mount.
@
text
@d19 1
a19 1
#if FSYS_SQUAWKING || FSYS_FREE_SQUAWKING
d30 7
d1046 1
a1046 1
static int add_to_dirty(FsysVolume *vol, int fid) {
d1057 8
a1064 6
    ulp = vol->dirty;
    for (ii=0; ii < vol->dirty_ffree; ++ii) {
	if (fid == *ulp++) {
	    FSYS_SQK(( OUTWHERE "%6d: add_to_dirty rejected fid %08lX cuz it's already there\n",
			    eer_rtc, fid));
	    return 0;		/* already in the dirty list */
d1114 1
a1114 1
    add_to_dirty(vol, FSYS_INDEX_FREE);		/* make sure the freelist gets updated */
d1190 3
a1192 1
    dst->start = dst->nblocks = 0;	/* always follow with a null entry */
d1287 1
d1290 8
a1297 2
	if (ii < vol->free_ffree) {	/* if in the middle */
	    memmove((char *)(vrp+1), (char *)vrp, (vol->free_ffree-ii)*sizeof(FsysRetPtr));
a1298 1
	++vol->free_ffree;
d1384 1
a1384 1
	add_to_dirty(vol, FSYS_INDEX_INDEX);
d1405 1
a1408 6
typedef struct fsys_delete_str {
    FsysVolume *vol;
    const char *path;
    QioIOQ *ioq;
} FsysDeleteT;

d1417 1
d1428 1
a1428 1
	*ndx++ = 0;
a1431 1
    add_to_dirty(vol, fid);		/* put FH on the dirty list */
d1433 1
a1433 1
    upd_index_bits(vol, fid);		/* need to update index file too */
a1437 1
    FsysDeleteT *del;
d1439 1
a1439 1
    FsysVolume *vol;
d1441 2
a1442 3
    del = (FsysDeleteT *)ioq->private;
    vol = del->vol;
    luf.vol = vol;
a1443 1
    luf.path = del->path;
d1452 6
a1457 3
    QIOfree(del);
    ioq->private = 0;
    qio_freemutex(&vol->mutex, ioq);
a1462 1
    FsysDeleteT *del;
d1471 2
a1472 4
    del = QIOmalloc(sizeof(FsysDeleteT));
    if (!del) return (ioq->iostatus = FSYS_DELETE_NOMEM);
    del->path = name;
    del->ioq = ioq;
d1474 1
a1474 2
    ioq->private = (void *)del;
    return qio_getmutex(&del->vol->mutex, delete_q, ioq);
d1595 1
a1595 1
	add_to_dirty(t->vol, fid);			/* put FH on the dirty list */
d1629 1
a1629 1
	    add_to_dirty(t->vol, luf.owner - t->vol->files); /* put owner directory on the dirty list too */
d2139 1
a2139 1
    SYNC_WRITE_INDEX,
d2141 1
a2141 1
    SYNC_WRITE_FREE,
d2158 2
d2162 1
d2188 1
d2196 1
a2196 1
		    FSYS_SQK(( OUTWHERE "%6d: sync: Begin, getting buffers.\n", eer_rtc));
d2211 2
a2212 1
		FSYS_SQK(( OUTWHERE "%6d: sync: Begin.\n", eer_rtc));
d2219 9
a2227 9
		    rfh = vol->files + FSYS_INDEX_FREE;
		    collapse_free(vol, INT_MAX);
		    ii = (vol->free_ffree * sizeof(FsysRetPtr) + 511) & -512;
		    if (ii > rfh->size) {
			rfh->size = ii;			/* record high water mark */
			vol->dirty_ffree = 0;		/* zap the dirty list */
			add_to_dirty(vol, FSYS_INDEX_FREE);	/* last on the dirty list */
			syn->substate = 0;		/* start looking again at top of list */
			continue;			/* re-iterate */
d2230 8
a2237 2
		    FSYS_SQK(( OUTWHERE "%6d: sync: dirty list processing complete. substate=%d\n",
		    	eer_rtc, syn->substate));
d2240 1
d2249 2
a2250 3
		ndx = vol->index + fid*FSYS_MAX_ALTS;
		FSYS_SQK(( OUTWHERE "%6d: sync: processing dirty fid: %08lX. valid=%d\n",
		    eer_rtc, fid,
d2253 1
a2253 1
		    FSYS_SQK(( OUTWHERE "%6d: sync: fid %08lX invalid. ffree=%d, valid=%d\n",
d2256 2
a2257 1
		    if (fid < vol->files_ffree && !(*ndx&0x80000000)) {	/* check that the index file is ok with an invalid RFH */
d2259 1
a2259 2
			ndx[0] = 0x80000001;	/* else force it */
			for (jj=1; jj < FSYS_MAX_ALTS; ++jj) ndx[jj] = 0;
d2287 1
a2287 1
		FSYS_SQK(( OUTWHERE "%6d: Writing directory\n", eer_rtc));
d2321 2
a2322 2
#if FSYS_SQUAWKING
		if ((rfh - vol->files) == FSYS_INDEX_ROOT) {
d2324 1
a2324 1
		    FSYS_SQK(( OUTWHERE "       Dump of root directory (%d bytes)\n", rfh->size));
d2327 1
a2327 1
#endif
d2335 1
a2335 1
		if (sects > rfh->clusters) {
d2353 1
a2353 2
		syn->alts = 0;			/* start at alternate 0 */
		qio->ramrp = rfh->ramrp;	/* point to retrieval pointer set */
d2358 2
a2359 2
		FSYS_SQK(( OUTWHERE "%6d: sync, directory upd: Queuing write 0. u_len=%d, sector=0\n",
	    		eer_rtc, qio->u_len));
d2369 2
a2370 15
		if (++syn->alts >= FSYS_MAX_ALTS) { /* wrote all of them */
		    syn->state = SYNC_READ_FIRSTFH; /* go update the file header */
		    continue;
		}
		fid = vol->dirty[syn->substate]; /* get fid of file to process */
		rfh = vol->files + fid;		/* point to FH */
		qio->ramrp = rfh->ramrp+syn->alts; /* point to next retrieval pointer set */
		qio->u_len = rfh->size;
		qio->buff = (U8*)syn->output;	/* point to output buffer */
		qio->state = 0;
		qio->sector = 0;
		FSYS_SQK(( OUTWHERE "%6d: sync, directory upd: Queuing write %d. u_len=%d, sector=0\n",
	    		eer_rtc, syn->alts, qio->u_len));
		fsys_qwrite(ioq);
		return;
d2374 1
a2374 1
#if 0	/* someday we might have to pre-read the old file header before updating */
d2391 1
a2391 1
#else
d2395 1
a2395 1
#endif
d2404 1
a2404 1
#if 0	/* someday we might have to pre-read the old file header before updating */
d2424 1
a2424 1
#endif
d2429 3
a2431 2
#if (FSYS_FEATURES&FSYS_FEATURES_CMTIME)
# if (FSYS_OPTIONS&FSYS_FEATURES_CMTIME)
d2434 1
a2434 1
# else
d2436 1
d2438 2
a2439 3
#endif
#if (FSYS_FEATURES&FSYS_FEATURES_ABTIME)
# if (FSYS_OPTIONS&FSYS_FEATURES_ABTIME)
d2442 1
a2442 1
# else
d2444 1
a2445 1
#endif
d2449 1
a2449 1
#if (FSYS_FEATURES&FSYS_OPTIONS&FSYS_FEATURES_PERMS)
d2452 1
a2452 1
#endif
d2461 1
a2461 1
#if !FSYS_READ_ONLY
d2470 1
a2470 1
#else
d2472 1
a2472 1
#endif
d2475 1
a2475 1
		ndx = vol->index + fid*FSYS_MAX_ALTS;
a2476 1
		syn->alts = 0;
d2482 2
a2483 2
		FSYS_SQK(( OUTWHERE "%6d: sync, FH upd: Queuing write 0. u_len=%d, sector=%d\n",
	    		eer_rtc, qio->u_len, qio->sector));
d2494 3
a2496 17
		fid = vol->dirty[syn->substate]; /* get fid of file to process next */
		rfh = vol->files + fid;		/* point to FH */
		if (++syn->alts >= FSYS_MAX_ALTS) { /* wrote all of them */
		    ++syn->substate;		/* next fid */
		    syn->state = SYNC_WALK_DIRTY; /* back to top of loop */
		    continue;
		}
		ndx = vol->index + fid*FSYS_MAX_ALTS + syn->alts;
		qio->ramrp = &syn->ramrp;	/* point to fake retrieval pointer */
		qio->u_len = 512;
		qio->buff = (U8*)syn->output;	/* point to output buffer */
		qio->state = 0;
		qio->sector = *ndx;
		FSYS_SQK(( OUTWHERE "%6d: sync, FH upd: Queuing write %d. u_len=%d, sector=%d\n",
	    		eer_rtc, syn->alts, qio->u_len, qio->sector));
		fsys_qwrite(ioq);
		return;
d2542 7
d2559 1
a2559 2
    		syn->substate = start + sects;
		syn->alts = 0;
d2561 2
a2562 2
		syn->state = SYNC_WRITE_INDEX;
		qio->ramrp = (vol->files+FSYS_INDEX_INDEX)->ramrp; /* point to first retrieval pointer set */
d2568 2
a2569 2
		FSYS_SQK(( OUTWHERE "%6d: sync, INDEX upd: Queuing write 0. u_len=%d, sector=%d\n",
	    		eer_rtc, qio->u_len, start));
d2574 1
a2574 2
	    case SYNC_WRITE_FREE:
	    case SYNC_WRITE_INDEX:
d2576 1
a2576 1
#if FSYS_FREE_SQUAWKING || FSYS_SQUAWKING
d2579 2
a2580 3
		    iio_printf(fsys_iop, "%6d: sync error writing %s %d. u_len=%d, sector=%d\n",
			    eer_rtc, syn->state == SYNC_WRITE_INDEX ? "INDEX" : "FREE",
			    syn->alts, qio->u_len, syn->start);
d2582 1
a2582 1
#endif
d2587 2
a2588 22
		++syn->alts;
		if (syn->alts >= FSYS_MAX_ALTS) {
		    syn->state = (syn->state == SYNC_WRITE_INDEX) ? SYNC_UPD_INDEX : SYNC_DONE;
		    continue;
		}
		if (syn->state == SYNC_WRITE_INDEX) {
		    qio->ramrp = (vol->files+FSYS_INDEX_INDEX)->ramrp + syn->alts; /* point to first retrieval pointer set */
		    qio->buff = (U8*)syn->output;	/* point to buffer */
		} else {
		    qio->ramrp = (vol->files+FSYS_INDEX_FREE)->ramrp + syn->alts; /* point to first retrieval pointer set */
		    qio->buff = (U8*)vol->free;		/* point to buffer */
		}
		qio->sector = syn->start;
		qio->u_len = syn->sects*512;
		qio->state = 0;
#if FSYS_FREE_SQUAWKING || FSYS_SQUAWKING
		iio_printf(fsys_iop, "%6d: sync, %s upd: Queuing write %d. u_len=%d, sector=%d\n",
	    		eer_rtc, syn->state == SYNC_WRITE_INDEX ? "INDEX" : "FREE",
	    		syn->alts, qio->u_len, syn->start);
#endif
		fsys_qwrite(ioq);
		return;
d2591 1
a2591 1
#if 0
d2596 2
a2597 2
#endif
#if FSYS_SQUAWKING || FSYS_FREE_SQUAWKING
d2607 2
a2608 2
#endif
		syn->state = SYNC_WRITE_FREE;
d2611 1
a2611 2
		syn->alts = 0;
		qio->ramrp = (vol->files+FSYS_INDEX_FREE)->ramrp; /* point to first retrieval pointer set */
d2616 2
a2617 4
#if FSYS_SQUAWKING || FSYS_FREE_SQUAWKING
		iio_printf(fsys_iop, "%6d: sync, FREE upd: Queuing write 0. u_len=%d, sector=%d\n",
	    		eer_rtc, qio->u_len, syn->start);
#endif
d2620 21
d2648 1
a2648 1
		FSYS_SQK(( OUTWHERE "%6d: Sync done\n", eer_rtc));
d2653 1
d2676 1
a2676 1
	FSYS_SQK(( OUTWHERE "%6d: sync: started. getting volume mutex\n", eer_rtc));
d2686 1
a2686 1
    FSYS_SQK(( OUTWHERE "%6d: sync: busy=%d, dirty_ffree=%d. Back to waiting\n",
d3701 2
a3702 2
	add_to_dirty(vol, src.owner - vol->files); /* put old directory on the dirty list */
	add_to_dirty(vol, dst.owner - vol->files); /* put new directory on the dirty list */
d4084 1
a4084 1
	add_to_dirty(vol, afid);
d4428 1
a4428 1
#if FSYS_SQUAWKING || FSYS_FREE_SQUAWKING
@


1.46
log
@Fixed even more file allocation and freelist mgr bugs.
@
text
@d315 1
a315 1
#if FSYS_FREE_SQUAWKING
d390 1
a390 1
#if FSYS_FREE_SQUAWKING
d1142 1
a1142 1
#if FSYS_FREE_SQUAWKING
d1192 1
a1192 1
#if FSYS_FREE_SQUAWKING
d1217 1
a1217 1
#if FSYS_FREE_SQUAWKING
d2580 8
d2599 1
d2602 1
a2605 1
		qio->buff = (U8*)syn->output;	/* point to input buffer */
d2607 2
a2608 1
		FSYS_SQK(( OUTWHERE "%6d: sync, %s upd: Queuing write %d. u_len=%d, sector=%d\n",
d2610 2
a2611 1
	    		syn->alts, qio->u_len, syn->start));
d2626 1
a2626 1
		    iio_printf(fsys_iop, "%6d: sync_upd_free: %d entries\n", vol->free_ffree);
d3081 11
d4847 4
d4864 3
d5037 1
d5041 1
d5043 1
a5043 1
		    if (!walk.errors && !walk.cs_errors) {
@


1.45
log
@Fixed a silly file allocation bug.
@
text
@d19 4
a24 1
IcelessIO *fsys_iop;
d241 3
a243 1
    int ii, tot;
d245 6
a250 1
    for (tot=ii=0; ii < vol->free_ffree; ++ii, ++rp) {
d257 4
d315 14
d390 15
d1084 4
a1087 2
    FSYS_SQK(( OUTWHERE "%6d: Increasing size of free list. free_ffree=%d, free_elems = %d\n",
		eer_rtc, vol->free_ffree, vol->free_elems));
d1089 3
a1091 2
    vol->free_elems += 100;			/* add 100 elements */
    vol->free = (FsysRetPtr *)QMOUNT_REALLOC(vol, vol->free, vol->free_elems*sizeof(FsysRetPtr));
d1093 1
a1093 2
    size = vol->free_elems*sizeof(FsysRetPtr);
    size = (size+511)/512;			/* round to cluster size */
d1095 1
d1098 1
a1108 18
#if 0
# define DBG_FREELIST(x) printf x
# define DMP_FREELIST(x) dump_free(x)
static void dump_free(FsysVolume *vol) {
    int ii;
    FsysRetPtr *rp;
    rp = vol->free;
    printf("dump_free: %d items\n", vol->free_ffree);
    for (ii=0; ii < vol->free_ffree; ++ii, ++rp) {
	printf("%6d: start=%4ld, nblocks=%4ld\n", ii, rp->start, rp->nblocks);
    }
    return;
}
#else
# define DBG_FREELIST(x) do { ; } while (0)
# define DMP_FREELIST(x) do { ; } while (0)
#endif

d1142 11
d1181 1
a1181 1
    memset((char *)dst, 0, sizeof(FsysRetPtr));
d1192 11
d1217 13
a1269 2
	    DBG_FREELIST(("back_to_free: Re-using slot %d, start=%ld, nblocks=%ld\n",
	    		vrp-vol->free, rp->start, rp->nblocks));
a1280 2
	DBG_FREELIST(("back_to_free: Inserting at slot %d, start=%ld, nblocks=%ld\n",
	    vrp-vol->free, rp->start, rp->nblocks));
a1294 2
    DBG_FREELIST(("Free_rps: At entry free_clusters=%4ld, alloc_clusters=%4ld\n",
    	vol->total_free_clusters, vol->total_alloc_clusters));
a1305 1
    		DMP_FREELIST(vol);
a1325 2
    DBG_FREELIST(("          At exit  free_clusters=%4ld, alloc_clusters=%4ld\n",
    	vol->total_free_clusters, vol->total_alloc_clusters));
a1414 1
	DMP_FREELIST(vol);
d2101 1
d2108 2
a2109 1
	    for (ii=0; ii < amt; ++ii) {
d2111 2
a2112 2
		dst->start = src->start;
		dst->nblocks = src->nblocks;
d2199 1
a2199 15
# if !FSYS_READ_ONLY
		collapse_free(vol, vol->free_start);
		rfh = vol->files + FSYS_INDEX_FREE;
		ii = vol->free_ffree * sizeof(FsysRetPtr);
		FSYS_SQK(( OUTWHERE "%6d: sync: Begin, dirty_ffree=%d, free_start=%d, free_ffree=%d, ii=%d, rfh->size=%d\n",
		    eer_rtc, vol->dirty_ffree, vol->free_start, vol->free_ffree, ii, rfh->size));
#  if 0
		if (vol->free_start >= vol->free_ffree || ii != rfh->size) {
		    rfh->size = ii;
		    add_to_dirty(vol, FSYS_INDEX_FREE);
		}
#  else
		rfh->size = ii;
#  endif
# endif
d2205 12
d2611 1
a2611 1
#if FSYS_SQUAWKING
d2615 1
a2615 1
		    FSYS_SQK(( OUTWHERE "      Freelist: %d entries\n", vol->free_ffree));
d2617 2
a2618 2
			FSYS_SQK(( OUTWHERE "      %3d: start=%7d, nblocks=%6d\n",
				ii, rp->start, rp->nblocks));
d2623 2
a2624 2
    		syn->start = 0; /* (vol->free_start*sizeof(FsysRetPtr))/512; */
		syn->sects = (vol->free_ffree*sizeof(FsysRetPtr) + 511)/512; /* ((vol->free_ffree - vol->free_start)*sizeof(FsysRetPtr)+511)/512; */
d2628 1
a2628 1
		qio->buff = (U8*)(vol->free)+syn->start*512;	/* point to output buffer */
d2631 4
a2634 2
		FSYS_SQK(( OUTWHERE "%6d: sync, FREE upd: Queuing write 0. u_len=%d, sector=%d\n",
	    		eer_rtc, qio->u_len, syn->start));
d2981 2
a2982 1
		    vol->index = (U32*)QMOUNT_ALLOC(vol, ii*FSYS_MAX_ALTS*sizeof(long)); /* room to read the whole index file */
a2992 1
		    vol->free_ffree = hdr->size/sizeof(FsysRetPtr);
d2994 1
a2994 5
# if !FSYS_TIGHT_MEM
		    vol->free_elems = (hdr->clusters*512)/sizeof(FsysRetPtr); /* give 'em room to grow painlessly */
# else
		    vol->free_elems = (hdr->clusters*32)/sizeof(FsysRetPtr); /* give 'em room to grow painlessly */
# endif
d2996 1
a2996 1
		    vol->free_elems = vol->free_ffree;	/* size of freemap file in elements */
d2998 2
a2999 1
		    vol->free = (FsysRetPtr *)QMOUNT_ALLOC(vol, vol->free_elems*sizeof(FsysRetPtr)); /* room to read the whole file */
d3006 1
a3006 1
		vol->rw_amt = hdr->size;
d3493 1
a3493 1
		fin->fhdr.size = ii*sizeof(FsysRetPtr);
d4412 2
a4413 2
#if FSYS_SQUAWKING
    fsys_iop = iio_open(1);		/* open a connection to thread 1 */
@


1.44
log
@Added debug printf's all over the place.
Corrected bug in sync task buffer allocation.
@
text
@d336 1
d338 7
a344 6
	free->start = fp->start;
	free->nblocks = ft->request;
	if (fp->nblocks < ft->request) fp->nblocks = 0;
	else fp->nblocks -= ft->request;
	if (fp->nblocks) {
	    fp->start += ft->request;		/* skip the amount we gave away */
d346 1
a346 1
	    fp->start = 0;
d360 2
d409 2
a410 1
    FSYS_SQK(( OUTWHERE "%6d: extend_file: asked for %d\n", eer_rtc, rqst));
@


1.43
log
@Adds and fixes to TEST_DISK_ERRORS code.
@
text
@d17 1
d19 8
d57 1
d61 1
d66 1
d405 2
d448 1
d455 1
d566 41
d650 2
a651 1
		    int ii, jj, fid, def;
a652 3
		    FsysVolume *v;
		    FsysRamFH *rfh;
		    FsysRamRP *rp;
d656 13
a668 23
			fid = (int)fp->private;
			rfh = v->files + (fid&0x00FFFFFF);
			def = arg->sector - rfh->clusters;
			if (def < 0) def = 0;
			def += rfh->def_extend ? rfh->def_extend : FSYS_DEFAULT_EXTEND;
			if (def*FSYS_MAX_ALTS >= v->total_free_clusters) {	/* maybe there's no room */
			    for (ii=jj=0; ii < FSYS_MAX_ALTS; ++ii) {	/* compute how many copies */
				rp = rfh->ramrp + ii;
				if (rp->num_rptrs) ++jj;
			    }
			    if (def*jj >= v->total_free_clusters) {	/* check again for room */
				ioq->iostatus = FSYS_EXTEND_FULL;	/* no room for extension */
				break;
			    }
			}
			for (jj=0; jj < FSYS_MAX_ALTS; ++jj) {
			    rp = rfh->ramrp + jj;
			    if (!rp->num_rptrs) continue;		/* no copy here */
			    ii = extend_file(v, def, rp, jj);
			    if (ii) {
				ioq->iostatus = ii;
				break;				/* ran out of room */
			    }
a669 3
			rfh->clusters += def;			/* add to total allocation */
			if (ioq->iostatus) break;
			continue;				/* recompute retrieval pointer set */
d698 17
d736 2
a737 2
#if 0
static void qmount_free(FsysVolume *vol, void *old) {
d741 1
a741 1
	    QIOfree(old);
a747 1
#endif
a748 1
#if FSYS_UMOUNT
d995 1
d997 2
d1004 5
a1008 1
	if (fid == *ulp++) return 0;		/* already in the dirty list */
d1019 1
d1021 1
d1024 1
d1036 2
d1045 2
d1079 2
d1084 1
d1096 2
d1104 3
d1138 9
d2083 5
d2089 1
a2089 1
    syn->buffers = (unsigned long *)QMOUNT_REALLOC(vol, syn->buffers, syn->buffer_size+QIO_CACHE_LINE_SIZE);
d2094 2
d2123 1
d2142 3
d2149 3
d2158 2
d2171 6
a2176 1
		if (fid > FSYS_INDEX_ROOT && !rfh->valid) { /* it isn't valid anymore */
d2178 1
a2178 1
		    if (!(*ndx&0x80000000)) {	/* check that the index file is ok with an invalid RFH */
d2209 1
d2243 7
d2277 1
a2277 1
		qio->u_len = sects*512;
d2281 2
d2303 2
d2418 2
d2443 2
d2512 2
d2539 3
d2546 1
d2551 12
d2572 2
d2583 1
d2610 1
d2620 2
d4354 3
@


1.42
log
@Moved test switch to bit 5.
@
text
@a4507 6
#if TEST_DISK_ERRORS
# define FAKE_CS_ERROR (ctl_read_sw(IO_MISC5 << SH_MISC)&(IO_MISC5 << SH_MISC))
#else
# define FAKE_CS_ERROR 0
#endif
	if ((ctl_read_sw(IO_MISC8 << SH_MISC)&(IO_MISC8 << SH_MISC))) {
d4738 7
a4744 2
			if (!sts && (csp=walk.this_cs)) {
			    if (csp->chksum != walk.cs) {
@


1.41
log
@Testing disk errors and messages.
@
text
@d4509 1
a4509 1
# define FAKE_CS_ERROR (ctl_read_sw(IO_MISC6 << SH_MISC)&(IO_MISC6 << SH_MISC))
@


1.40
log
@Bugs in sync'ing index file.
@
text
@d18 1
a18 1
/* #define TEST_DISK_ERRORS	1	set to enable error handler */
a4368 1
#if !TEST_DISK_ERRORS
a4369 1
#endif
a4427 1
#if !TEST_DISK_ERRORS
a4431 1
#endif
d4508 6
d4515 1
a4515 1
		    if (csp->chksum != wp->cs) {
@


1.39
log
@Changed text of "waiting" message. Allowed a FSYS_MOUNTED error
as being ok during fsys_test setup. Corrected centering of A-OK
message. Added support for standalone fsys_test function.
@
text
@d1004 1
a1004 1
static int upd_index_bits(FsysVolume *vol, int pos) {
d1008 1
a1008 2
    if (bits > vol->index_bits_elems) {
	unsigned long *new;
d1011 2
a1012 2
	new = (U32*)QMOUNT_ALLOC(vol, newsize*sizeof(long));
	if (!new) {
a1013 1
	    if (vol->index_bits) QIOfree(vol->index_bits);
a1015 2
	memcpy((char*)new, (char *)vol->index_bits, vol->index_bits_elems*sizeof(long));
	if (vol->index_bits) QIOfree(vol->index_bits);
a1016 1
	vol->index_bits = new;
d1018 1
a1018 1
    lw = pos*FSYS_MAX_ALTS*sizeof(long); /* byte position in index file */
d1020 1
a1020 1
    pos = lw&31;			/* bit position in bitmap element */
d1022 1
a1022 1
    vol->index_bits[lw] |= 1<<pos;	/* set bit in bitmap */
@


1.38
log
@Made all references to QioDevice const.
@
text
@d4625 1
a4625 1
	txt_str(-1, AN_VIS_ROW/2, "Please wait while filesystem is mounted...", WHT_PAL);
d4629 1
a4629 1
	if (QIO_ERR_CODE(sts)) {
d4639 1
a4639 1
    st_insn(AN_VIS_ROW-2, t_msg_ret_menu, t_msg_next, INSTR_PAL);
d4809 1
a4809 1
			    txt_str((AN_VIS_COL-sizeof(AOK_MSG)-1+4)/2, AN_VIS_ROW/2, AOK_MSG, WHT_PAL);
@


1.37
log
@Added a freeqio() call in readwpos_q routine.
,.
@
text
@d118 1
a118 1
    QioDevice *dvc;
d2927 1
a2927 1
    QioDevice *d;
d4000 1
a4000 1
    QioDevice *dvc;
d4005 1
a4005 1
    dvc = (QioDevice *)ioq->private;
d4171 1
a4171 1
    QioDevice *dvc;
@


1.36
log
@Now fsys_read, fsys_write and fsys_lseek correctly interlock
one another.
@
text
@d3629 1
@


1.35
log
@Always write the entire freelist no matter what. Grrrr.
@
text
@d3513 1
a3513 1
static int fsys_lseek( QioIOQ *ioq, size_t where, int whence ) {
d3515 2
a3516 1
    if (!ioq) return QIO_INVARG;
d3518 3
a3520 1
    fp = qio_fd2file(ioq->file);	/* !FIXME!!!! This needs a mutex protection */
d3537 22
a3558 1
    return 0;
d3600 36
d3639 1
a3639 1
static int fsys_readwpos( QioIOQ *ioq, size_t where, void *buf, int len ) {
a3646 4
#if 0
    len &= -512;			/* round request length to sector boundary */
    if (len == 0) return QIO_INVARG;
#endif
a3653 10
    if (where + len > rfh->size) {
	if (where >= rfh->size) {
	    fp->pos = rfh->size;		/* set position to end of file */
	    ioq->iostatus = QIO_EOF;		/* signal end of file */
	    ioq->iocount = 0;			/* no data xferred */
	    qio_complete(ioq);			/* done */
	    return 0;
	}
	len = rfh->size - where;		/* max out the length */
    }
d3658 1
a3658 10
    if (!(fp->mode&O_CREAT) && (fp->mode&FSYS_OPNCPY_M)) { /* if reading a specific file */
	int t;
	t = (((U32)fp->mode&FSYS_OPNCPY_M)>>FSYS_OPNCPY_V) - 1;
	q->ramrp = rfh->ramrp + t;
    } else {
	q->ramrp = rfh->ramrp + rfh->active_rp;
    }
    q->o_which = rfh->active_rp;
    q->o_where = q->sector = where/512;
    q->o_buff = q->buff = (void *)buf;
a3660 2
    q->astq.action = fsys_qread;
    q->astq.param = (void *)q;
d3662 2
a3663 1
    prc_q_ast(QIO_ASTLVL, &q->astq);
d3667 40
d3708 2
a3709 1
    QioFile *fp;
d3711 6
a3716 3
    if (!ioq) return QIO_INVARG;
    fp = qio_fd2file(ioq->file);
    return fsys_readwpos( ioq, fp->pos, buf, len);
d3768 1
d3772 1
a3772 1
static int fsys_writewpos( QioIOQ *ioq, size_t where, const void *buf, int len ) {
a3779 4
#if 0
    len &= -512;
    if (len == 0) return QIO_INVARG;
#endif
d3789 1
a3790 1
    q->o_where = q->sector = where/512;
a3797 2
    q->astq.action = fsys_qwrite;
    q->astq.param = (void *)q;
d3799 1
a3799 1
    prc_q_ast(QIO_ASTLVL, &q->astq);
d3803 31
d3835 2
a3836 1
    QioFile *fp;
d3838 6
a3843 3
    if (!ioq) return QIO_INVARG;
    fp = qio_fd2file(ioq->file);
    return fsys_writewpos( ioq, fp->pos, buf, len);
@


1.34
log
@Fixed bug in sync code not correctly updating directories.
Conditionally removed the qmount_alloc() function and calls
to it to save time and space.
@
text
@d2426 2
a2427 2
    		syn->start = (vol->free_start*sizeof(FsysRetPtr))/512;
		syn->sects = ((vol->free_ffree - vol->free_start)*sizeof(FsysRetPtr)+511)/512;
@


1.33
log
@Numerous memory allocation bugs corrected.
@
text
@d39 1
d42 10
a51 2
#define QMOUNT_ALLOC(vol, amt) qmount_alloc(vol, amt, __FILE__, __LINE__)
#define QMOUNT_REALLOC(vol, old, amt) qmount_realloc(vol, old, amt, __FILE__, __LINE__)
d53 2
a54 2
#define QMOUNT_ALLOC(vol, amt) qmount_alloc(vol, amt)
#define QMOUNT_REALLOC(vol, old, amt) qmount_realloc(vol, old, amt)
d56 1
d677 15
a710 14
#if 0
static void qmount_free(FsysVolume *vol, void *old) {
    int ii;
    for (ii=0; ii < vol->freem_indx; ++ii) {
	if (vol->freemem[ii] == old) {
	    QIOfree(old);
	    vol->freemem[ii] = 0;
	    break;
	}
    }
    return;
}
#endif

d724 1
a724 1
	    vol->freemem = QM_ALLOC_REALLOC(vol->freemem, vol->freem_elems*sizeof(void *));
d734 1
d777 1
d793 1
d2109 3
a2111 2
			if (lim-dst < (len=strlen(dir->name)+1)+1+4+4) {
			    len = dst - (char *)syn->output;
d2113 1
a2113 1
			    dst = (char *)syn->output + len;
d2128 6
d2137 1
d2166 1
a2166 1
		qio->buff = (U8*)syn->output;		/* point to input buffer */
d2653 1
d2655 1
@


1.32
log
@Added support for MALLOC_DEBUGing and reduced the memory
requirements of a loaded filesystem.
@
text
@d427 1
d438 1
d674 2
a675 2
	vol->freem_elems += 20;
	nmem = QM_ALLOC_REALLOC(vol->freemem, vol->freem_elems*sizeof(void *));
d677 1
a677 1
	    QM_ALLOC_FREE(ans);
d1161 1
a1161 1
	if (cur->rptrs) QIOfree(cur->rptrs);
d1163 1
d1991 1
a1991 1
    syn->output = (unsigned long *)(((U32)syn->buffers+QIO_CACHE_LINE_SIZE-1)&-QIO_CACHE_LINE_SIZE);
a2406 1
		memcpy((char *)syn->output, (char *)(vol->free)+syn->start*512, syn->sects*512);
d2409 1
a2409 1
		qio->buff = (U8*)syn->output;	/* point to output buffer */
@


1.31
log
@Made QUIET_CHECK externally adjustable.
@
text
@d39 1
a39 1
#if DEBUG_MALLOC
d41 5
d72 1
a72 1
#if DEBUG_MALLOC
d89 1
a89 1
#if DEBUG_MALLOC
d417 8
a424 1
		    rp->rptrs = (FsysRetPtr *)QIOmalloc(8*sizeof(FsysRetPtr));
d426 1
d429 1
a429 1
		    trp = (FsysRamRP *)QIOmalloc(sizeof(FsysRamRP)+8*sizeof(FsysRetPtr));
d436 1
a439 1
		rp->rptrs_size = 8;		/* this is how many are in there */
d653 13
a665 1
static void *qmount_alloc(FsysVolume *vol, int amt) {
d667 4
a670 2
    ans = QIOcalloc(amt, 1);
    if (!ans) return ans;
d673 1
a673 1
	nmem = QIOrealloc(vol->freemem, vol->freem_elems*sizeof(void *));
d675 1
a675 1
	    QIOfree(ans);
d698 1
a698 1
static void *qmount_realloc(FsysVolume *vol, void *old, int amt) {
d701 1
a701 1
    ans = QIOrealloc(old, amt);
d711 1
a711 1
	    vol->freemem = QIOrealloc(vol->freemem, vol->freem_elems*sizeof(void *));
d904 1
a904 1
	vol->unused = (U32*)qmount_realloc(vol, vol->unused, vol->unused_elems*sizeof(long));
d933 1
a933 1
	vol->dirty = (U32*)qmount_realloc(vol, vol->dirty, new*sizeof(long));
d955 1
a955 1
    vol->free = (FsysRetPtr *)qmount_realloc(vol, vol->free, vol->free_elems*sizeof(FsysRetPtr));
d996 1
a996 1
	new = (U32*)qmount_alloc(vol, newsize*sizeof(long));
d1193 1
a1193 1
	    vol->files = (FsysRamFH *)qmount_realloc(vol, vol->files, new_size*sizeof(FsysRamFH));
d1197 1
a1197 1
	    vol->index = (U32*)qmount_realloc(vol, vol->index, new_size*sizeof(U32)*FSYS_MAX_ALTS);
d1407 1
a1407 1
	    dp = (FsysDirEnt *)qmount_alloc(vol, sizeof(FsysDirEnt)+strlen(luf.fname)+1);
d1474 1
a1474 1
	    rfh->directory = (FsysDirEnt **)qmount_alloc(vol, FSYS_DIR_HASH_SIZE*sizeof(FsysDirEnt*) +
d1809 1
d1822 1
a1822 1
    inddir = (FsysDirEnt *)qmount_alloc(vol, totstr+	/* room for strings */
d1851 28
d1886 1
a1886 1
    int ii, jj, kk, amt;
d1889 1
d1901 1
a1901 1
	rfh->directory = (FsysDirEnt **)qmount_alloc(vol, FSYS_DIR_HASH_SIZE*sizeof(FsysDirEnt*));
a1905 2
    } else {
	rfh->directory = 0;
d1915 1
a1915 12
    for (amt=jj=0; jj < FSYS_MAX_ALTS; ++jj, ++rrp) {
	if (jj) {
	    if (hdr->pointers[jj-1][0].start == 0 ||
    	        hdr->pointers[jj-1][0].start == hdr->pointers[jj][0].start) {
		rrp->num_rptrs = 0;
		rrp->rptrs = 0;
#if !FSYS_READ_ONLY
		rrp->rptrs_size = 0;
#endif
		continue;
	    }
	}
d1919 16
a1934 4
	if (!(rrp->num_rptrs = ii)) continue;
#if !FSYS_READ_ONLY && !FSYS_TIGHT_MEM
	ii = rrp->rptrs_size+8;
	if (ii > FSYS_MAX_FHPTRS) ii = FSYS_MAX_FHPTRS;
d1936 2
a1937 2
	rrp->rptrs = (FsysRetPtr *)qmount_alloc(vol, ii*sizeof(FsysRetPtr));
	if (!rrp->rptrs) {	/* ooops, ran out of memory */
d1941 14
a1954 6
	src = hdr->pointers[jj];
	dst = rrp->rptrs;
	for (kk=0; kk < ii; ++kk, ++dst, ++src) {
	    dst->start = src->start;
	    dst->nblocks = src->nblocks;
	    amt += src->nblocks;
d1957 1
a1957 1
    vol->total_alloc_clusters += amt;
d1982 1
a1982 1
static int get_sync_buffers(FsysSyncT *syn) {
d1984 1
a1984 1
    syn->buffers = (unsigned long *)QIOrealloc(syn->buffers, 2*syn->buffer_size+QIO_CACHE_LINE_SIZE);
d1988 1
a1988 3
    syn->input = (unsigned long *)((QIO_MK_NONCACHE(syn->buffers)+QIO_CACHE_LINE_SIZE-1)&-QIO_CACHE_LINE_SIZE);
    syn->output = syn->input + syn->buffer_size/sizeof(long);
    flush_dcache();		/* the very first time just to be safe, zap all data cache */
d2015 2
a2016 2
		if (!syn->input) {		/* need to get some buffers */
		    if (get_sync_buffers(syn)) break;
d2085 2
a2086 2
		dst = (char *)syn->input;
		lim = dst + syn->buffer_size*2;	/* use both buffers for this */
d2093 4
a2096 4
			    len = dst - (char *)syn->input;
			    if (get_sync_buffers(syn)) break;
			    dst = (char *)syn->input + len;
			    lim = (char *)syn->input + 2*syn->buffer_size;
d2113 1
a2113 1
		sects = dst - (char *)syn->input; /* compute size of data */
d2118 1
a2118 1
		rfh->size = dst - (char *)syn->input;
d2141 1
a2141 1
		qio->buff = (U8*)syn->input;		/* point to input buffer */
d2161 1
a2161 1
		qio->buff = (U8*)syn->input;	/* point to output buffer */
d2177 1
a2177 1
		qio->buff = syn->input;		/* point to input buffer */
d2220 1
a2220 1
		fh = (FsysHeader *)syn->input;
d2274 1
a2274 1
		qio->buff = (U8*)syn->input;		/* point to input buffer */
d2297 1
a2297 1
		qio->buff = (U8*)syn->input;	/* point to input buffer */
d2542 1
a2542 1
		    vol->buff = (U32*)qmount_alloc(vol, 512);	/* get a temporary sector buffer */
d2727 2
a2728 1
#if !FSYS_READ_ONLY && !FSYS_TIGHT_MEM
d2730 3
d2734 2
a2735 2
		    vol->files = (FsysRamFH *)qmount_alloc(vol, ii*sizeof(FsysRamFH));
#if !FSYS_READ_ONLY && !FSYS_TIGHT_MEM
d2737 1
d2739 4
a2742 1
			vol->files = (FsysRamFH *)qmount_alloc(vol, ii*sizeof(FsysRamFH));
d2750 1
a2750 1
		    vol->index = (U32*)qmount_alloc(vol, ii*FSYS_MAX_ALTS*sizeof(long)); /* room to read the whole file */
d2756 4
d2762 2
a2763 1
#if !FSYS_READ_ONLY && !FSYS_TIGHT_MEM
d2765 3
d2771 1
a2771 1
		    vol->free = (FsysRetPtr *)qmount_alloc(vol, vol->free_elems*sizeof(FsysRetPtr)); /* room to read the whole file */
d2798 1
a2798 1
			vol->buff = (U32*)qmount_realloc(vol, (void *)vol->buff, vol->buff_size); /* give back old buffer */
d3447 1
a3447 1
	dp = (FsysDirEnt *)qmount_alloc(vol, sizeof(FsysDirEnt)+strlen(fname)+1);
d4140 1
a4140 1
#if DEBUG_MALLOC
d4153 1
@


1.30
log
@Fixed more fsys_test message handling.
@
text
@d4142 1
d4144 1
d4316 1
a4316 1
txt_str(-1, WALK_ERR_ROW+3, "FID ", WHT_PAL);
d4318 2
@


1.29
log
@Changed text of fsys_test error messages.
@
text
@d4524 3
d4617 1
a4617 1
			    if (!cs_err) {
@


1.28
log
@Added O_OPNCPY support (open a specific copy of a file and
prevent auto-switch to alternate). Replaced fsys_test with
one that spits out file numbers instead of filenames.
@
text
@d3552 15
a3566 13
    ++q->o_which;
    if (q->o_which < FSYS_MAX_ALTS) {	/* if we haven't tried all writes */
	FsysRamRP *rp;
	rp = rfh->ramrp + q->o_which;	/* get next retrieval pointer set */
	if (rp->num_rptrs) {		/* if there are alternate retrevial pointers */
	    q->ramrp = rp;		/* point to new batch */
	    q->sector = q->o_where;	/* rewind the significant pointers */
	    q->u_len = q->o_len;
	    q->buff = (void *)q->o_buff;
	    q->total = 0;		/* reset the total */
	    q->state = 0;		/* make sure we start at beginning */
	    fsys_qwrite(ioq);		/* and re start the write */
	    return;
d4365 1
d4383 1
d4457 1
d4459 1
d4595 1
a4595 1
			int fatal=0, jj;
d4599 1
a4599 1
				fatal = 1;
d4607 22
a4628 3
			if (fatal) {
			    txt_str(-1, AN_VIS_ROW/2-1, "The errors listed cannot be corrected.", YEL_PAL);
			    txt_str(-1, AN_VIS_ROW/2+1, "The filesystem is broken and is not usable", RED_PAL);
@


1.27
log
@Added code to make the mount procedure scan the entire disk
for a home block should it not be able to read one in the
expected places.
@
text
@d18 1
a18 1
#define FSYS_TEST_ERRORS	0	/* set to enable error handler */
d1556 8
d3448 1
a3448 1
    if (QIO_ERR_CODE(ioq->iostatus) && ioq->iostatus != QIO_EOF) {
d3508 7
a3514 1
    q->ramrp = rfh->ramrp + rfh->active_rp;
d4091 1
d4110 10
a4119 2
#define WALK_CORR_ROW	(WALK_ERR_ROW+8)
#define WALK_CORR_MSG	"Correctable errors:"
d4122 2
a4123 2
#define WALK_ALTS_ROW	(WALK_ERR_ROW+9)
#define WALK_ALTS_MSG	"   Alternates used:"
d4140 1
a4140 1
#define CHECK_NUMBERS	0
a4144 3
#if CHECK_NUMBERS
    int cnt=0;
#endif
d4154 1
a4154 1
#if !FSYS_TEST_ERRORS
a4172 18
#if CHECK_NUMBERS
#define BAD_CNT_MSG1 "File size error."
#define BAD_CNT_MSG2 "expected"
#define BAD_CNT_MSG3 "found   "
if (wp->this_cs && cnt*4 != 1*1024*1024) {
    txt_str(-1, WALK_ERR_ROW, BAD_CNT_MSG1, YEL_PAL);
    txt_str((AN_VIS_COL-3-sizeof(BAD_CNT_MSG2)-1-8)/2,
	    WALK_ERR_ROW+1, BAD_CNT_MSG2, YEL_PAL);
    txt_cstr(" 0x", GRN_PAL);
    txt_chexnum(1*1024*1024, 8, RJ_ZF, GRN_PAL);
    txt_str((AN_VIS_COL-3-sizeof(BAD_CNT_MSG3)-1-8)/2,
	    WALK_ERR_ROW+2, BAD_CNT_MSG3, YEL_PAL);
    txt_cstr(" 0x", RED_PAL);
    txt_chexnum(cnt*4, 8, RJ_ZF, RED_PAL);
    ++wp->errors;
    return WALK_EXIT_ERR;
}    
#endif
a4192 32
#if CHECK_NUMBERS
if (*up != cnt) {
    unsigned long ul;
    ul = ((cnt << (3*8))&0xFF000000) | 
    	 ((cnt << (1*8))&0x00FF0000) | 
    	 ((cnt >> (1*8))&0x0000FF00) | 
    	 ((cnt >> (3*8))&0x000000FF);
    if (*up != ul) {
#define BAD_CMP_MSG1 "Data mismatch on file."
#define BAD_CMP_MSG2 "expected"
#define BAD_CMP_MSG3 "or      "
#define BAD_CMP_MSG4 "found   "
	txt_str(-1, WALK_ERR_ROW, BAD_CMP_MSG1, YEL_PAL);
	txt_str((AN_VIS_COL-3-sizeof(BAD_CMP_MSG2)-1-8)/2,
		WALK_ERR_ROW+1, BAD_CMP_MSG2, YEL_PAL);
	txt_cstr(" 0x", GRN_PAL);
	txt_chexnum(cnt, 8, RJ_ZF, GRN_PAL);
	txt_str((AN_VIS_COL-3-sizeof(BAD_CMP_MSG3)-1-8)/2,
		WALK_ERR_ROW+2, BAD_CMP_MSG3, YEL_PAL);
	txt_cstr(" 0x", GRN_PAL);
	txt_chexnum(ul, 8, RJ_ZF, GRN_PAL);
	txt_str((AN_VIS_COL-3-sizeof(BAD_CMP_MSG4)-1-8)/2,
		WALK_ERR_ROW+2, BAD_CMP_MSG4, YEL_PAL);
	txt_cstr(" 0x", RED_PAL);
	txt_chexnum(*up, 8, RJ_ZF, RED_PAL);
	sts = WALK_EXIT_ERR;
	++wp->errors;
	return WALK_EXIT_ERR;
    }
}
++cnt;
#endif
d4201 1
d4215 1
a4215 1
#if !FSYS_TEST_ERRORS
d4361 19
a4381 1
    Walker walk;
d4384 2
a4385 1
    DIR *dp;
d4388 5
a4392 2
    static int been_here;
    FsysOpenT ot;
d4398 1
d4432 1
a4432 5
    if (QIO_ERR_CODE(sts)) {
	txt_str(-1, AN_VIS_ROW-8, "Failed to open checksum file.", WHT_PAL);
	qio_errmsg(sts, walk.data_buff, walk.data_buff_size);
	txt_str(-1, AN_VIS_ROW-7, walk.data_buff, YEL_PAL);
    } else {
d4434 1
a4434 1
	    txt_str(-1, AN_VIS_ROW-8, "Not enough memory to hold checksum file.", WHT_PAL);
d4439 1
a4439 1
		txt_str(-1, AN_VIS_ROW-8, "Error reading checksum file.", WHT_PAL);
d4441 1
a4441 1
		txt_str(-1, AN_VIS_ROW-7, walk.data_buff, YEL_PAL);
a4451 1
    if (!walk.numb_cksums) txt_str(-1, AN_VIS_ROW-5, "Checksums will not be computed.", YEL_PAL);
d4453 1
d4460 159
d4653 1
@


1.26
log
@Lots of changes. Added error logging to BRAM. Added reports
of correctable and uncorrectable errors during fsys_test.
Corrected bug in reader not advancing to alternate file on
read error. Changed text of some messages. Added fsys_delete
and fsys_rename (which doesn't work yet).
@
text
@d2417 1
d2515 5
a2519 5
 * all the home blocks have been tried. Technically, if it cannot find a home
 * block where one is expected, it could read the entire disk to find
 * a sector that we recognize as a home block, but I'll leave that as an
 * exercise to the maintainer. The read procedure hops back and forth between
 * states 1 and 2 a home block is successfully read.
a2538 1
			USED_ALT();
d2541 16
d2573 6
a2578 6
		for (ii=0; ii < FSYS_MAX_ALTS; ++ii) {
		    vol->index_lbas[ii] = hb->index[ii];	/* remember lba's for index file */
		}
		vol->substate = 0;
		vol->state = MOUNT_RD_FH;		/* goto to next state */
		continue;
@


1.25
log
@Moved the contents of qio_errs.h into qio.h and removed all
references to qio_errs.h.
@
text
@d16 1
d18 2
d45 12
d1266 2
a1267 1
    QioDevice *dvc;
d1269 5
a1273 4
    if (!ioq) return QIO_INVARG;
    if (!name) return (ioq->iostatus = FSYS_DELETE_INVARG);
    dvc = qio_lookupdvc(name);
    if (!dvc) return (ioq->iostatus = FSYS_DELETE_FNF);
d1276 1
a1276 6
    del->vol = (FsysVolume *)dvc->private;
    if (!del->vol || (del->vol->id != FSYS_ID_VOLUME)) {
	QIOfree(del);
	return (ioq->iostatus = FSYS_DELETE_FNF);
    }
    del->path = name + dvc->name_len + 1;
a1282 1

d2538 1
d2637 1
d2740 1
d3311 70
a3380 3
static int fsys_rename( QioIOQ *ioq, const char *name1, const char *name2 ) {
    if (!ioq) return QIO_INVARG;
    return (ioq->iostatus = FSYS_IO_NOSUPP);
d3414 2
d3419 24
a3442 2
    fp = q->fsys_fp;
    hisioq->iocount = q->total;		/* record total bytes xferred */
d3485 1
d3487 2
a3488 2
    q->u_len = len;
    q->buff = (void *)buf;
d3516 6
a3524 1
	rfh = q->o_rfh;
a3538 2
    hisioq = q->callers_ioq;
    fp = q->fsys_fp;
a3544 2
    v = (FsysVolume *)fp->dvc->private;
    fp = qio_fd2file(hisioq->file);
a3545 2
    fid = (int)fp->private;
    rfh = v->files + (fid&0x00FFFFFF);
a3575 1
    q->o_rfh = rfh;
d4066 3
d4079 8
d4109 6
a4114 1

d4118 1
d4120 7
d4129 6
d4228 1
d4233 1
d4271 1
d4289 1
a4289 1
		while (!sts) { sts = ioq->iostatus; }
d4332 20
d4385 1
d4407 7
d4475 2
a4476 1
		txt_str(-1, AN_VIS_ROW/2, "No errors detected. Filesystem is ", WHT_PAL);
d4480 1
a4480 1
		txt_str((AN_VIS_COL-17-6-7)/2, AN_VIS_ROW/2+2, "Found a total of ", WHT_PAL);
d4482 1
a4482 1
		txt_cstr(" errors", WHT_PAL);
@


1.24
log
@Added a fstat function. Returns file size, blksize and blocks.
st_mode is set to S_IFREG or S_IFDIR as appropriate.
@
text
@a12 1
#include <qio_errs.h>
@


1.23
log
@Fixed compile time errors when using FSYS_UPD_FH mode.
@
text
@d3574 30
a3603 3
static int fsys_fstat( QioIOQ *ioq, struct stat *stat ) {
    if (!ioq) return QIO_INVARG;
    return (ioq->iostatus = FSYS_IO_NOSUPP);
@


1.22
log
@Added a "sort of" read only mode. Allows one to update the FH
so the EOF and times fields can be altered.
@
text
@d76 1
a76 1
#if !FSYS_READ_ONLY
a852 1

d871 1
d873 1
d905 1
d907 1
d1940 2
a1941 1
		    syn->ramrp.num_rptrs = syn->ramrp.rptrs_size = 1;
d1943 2
d2175 1
d2184 3
@


1.21
log
@Made some error messages more descriptive.
@
text
@d1489 1
a1489 1
    if (t->mode&O_CREAT) {
a1500 1
	file->pos = 0;				/* !FIXME!!! start reading at virtual addr 0 */
d1530 8
d1633 1
a1633 1
	if ((file->mode&O_CREAT)) {
d1730 1
a1730 1
	ours->mode = O_CREAT;
d1855 1
a1855 1
#if !FSYS_READ_ONLY
d1877 1
a1877 1
#if !FSYS_READ_ONLY
d1883 1
d1890 1
d1894 1
d1896 1
d1944 1
d1952 1
d1958 1
d1960 3
d1970 1
d1977 1
d1981 1
d1987 3
d1993 1
d2081 1
d2214 1
d2322 1
a2322 1

d2324 1
d2327 1
d2439 1
a2439 1
#if !FSYS_READ_ONLY
d2619 1
a2619 1
#if !FSYS_READ_ONLY
d2623 1
a2623 1
#if !FSYS_READ_ONLY
d2642 1
a2642 1
#if !FSYS_READ_ONLY
d2732 1
a2732 1
#if !FSYS_READ_ONLY
d3360 1
d3492 1
a3492 1
#if !FSYS_READ_ONLY
d3504 1
d3509 1
d3539 1
a3539 1
#if !FSYS_READ_ONLY
d3712 3
d3716 1
@


1.20
log
@Added watchdog kicker in wait loops.
@
text
@d2952 7
a2958 6
	    case INIT_BEGIN:
		if (!iv ||			/* there must be an iv variable */
    		    iv->cluster != 1 ||		/* only cluster size of 1 supported at present */
		    iv->index_sectors + iv->free_sectors + iv->root_sectors >= fin->max_lba) {
		    ioq = fin->q.callers_ioq;
		    ioq->iostatus = fin->status = FSYS_INITFS_INVARG;
d2961 8
d2976 2
a2977 4
no_mem:
		    ioq = fin->q.callers_ioq;
		    ioq->iostatus = fin->status = FSYS_INITFS_NOMEM;
		    return;
d2983 2
a2984 1
		    goto no_mem;
d2990 2
a2991 1
		    goto no_mem;
d2995 1
a2995 1
		    fin->status = FSYS_INITFS_NOMEM;
d2999 1
a2999 1
		    return;
d3006 1
d3755 2
a3756 2
	qio_open(ioq, (void *)what, O_RDWR);
	while (!(sts=ioq->iostatus)) { ; }
d3765 2
a3766 2
		qio_fstat(ioq, &drvstat);
		while (!(sts=ioq->iostatus)) { ; }
@


1.19
log
@Put up a message while mounting the volume.
@
text
@d2723 11
d2752 4
a2755 1

d2763 7
d2771 3
a2773 2
    qio_open(ioq, where, O_RDWR);
    while (!(sts=ioq->iostatus)) { ; }	/* wait for it */
d2776 3
d2781 2
a2782 2
    qio_fstat(ioq, &fs);		/* get stats about the physical device */
    while (!(sts=ioq->iostatus)) { ; }	/* wait for it */
d2784 3
a2786 2
	qio_close(ioq);
	while (!ioq->iostatus) { ; }
d2788 3
d2800 1
d2804 3
d4071 1
a4071 2
		while (!sts && !ioq->iostatus) { ; }
		if (!sts) sts = ioq->iostatus;
@


1.18
log
@Fixed file space allocation algorithm.
@
text
@d4120 2
d4123 1
@


1.17
log
@Corrected bug in fsys_test where buffer size was set to a value
not a multiple of 512.
@
text
@a218 1
    int hi_limit;	/* allocate below this sector */
d268 2
a269 2
	if (ft->hint && fp->start == ft->hint) {
	    nearest_over = ii;
a272 1
	if (fp->start >= ft->hi_limit) continue; /* keep looking */
d279 4
a380 1
	freet.hi_limit = (where >= FSYS_MAX_ALTS-1) ? vol->maxlba : FSYS_HB_ALG(where+1, vol->maxlba);
a1352 1
		freet.hi_limit = (bcnt >= FSYS_MAX_ALTS-1) ? vol->maxlba : FSYS_HB_ALG(bcnt+1, vol->maxlba);
a2990 1
		    freet.hi_limit = (bcnt >= FSYS_MAX_ALTS-1) ? fin->max_lba : FSYS_HB_ALG(bcnt+1, fin->max_lba);
d3275 2
a3276 1
    if ((len&511)) return FSYS_IO_NOT512;
d3378 2
a3379 1
    if ((len&511)) return FSYS_IO_NOT512;
@


1.16
log
@Changed FID assignment algorithm slightly.
Sets and gets time fields from openT struct on file open
correctly now. Fixed bug in the 'write duplicate' loop.
@
text
@d4115 1
a4115 1
    walk.data_buff_size = ((char *)&walk-8192 - walk.data_buff) & -512;
d4158 2
a4159 1
		walk.data_buff_size -= (ioq->iocount+QIO_CACHE_LINE_SIZE-1)&-QIO_CACHE_LINE_SIZE;
@


1.15
log
@Fixed bug in fsys_test.
@
text
@d1317 2
a1318 4
	    ++gen;					/* bump generation */
	    if (gen > 255) gen = 1;			/* wrap it and skip 0 */
	    luf.dir->generation = gen;			/* update generation number in directory */
	    rfh->generation = gen;			/* file gets a new generation number */
d1320 2
a1321 2
	    dp = luf.dir;				/* remember where the directory is */
	    new = 0;
d1382 1
a1382 1
	rfh->mtime = rfh->ctime;			/* in this case, mod time = create time */
d1384 4
a1420 1
	    add_to_dirty(t->vol, luf.owner - t->vol->files); /* put owner directory on the dirty list */
d1422 1
d1431 1
a1431 1
	    char *strings;				/* pointer to place to put strings */
d1538 8
d3329 1
d3333 1
a3333 1
	rp = rfh->ramrp + q->o_which + 1;	/* get next retrieval pointer set */
a3335 1
	    ++q->o_which;		/* update index */
@


1.14
log
@Fixed a memory leak in fsys_readwpos().
@
text
@d4111 1
a4111 1
	    txt_str(-1, AN_VIS_ROW-8, "Failed to mount filesystem.", WHT_PAL);
d4113 1
a4113 1
	    txt_str(-1, AN_VIS_ROW-7, walk.data_buff, YEL_PAL);
d4115 1
a4115 1
	    if (!sts) while (!(ctl_read_sw(SW_NEXT)&SW_NEXT)) { prc_delay(0); }
@


1.13
log
@Forgot to set the file size to the QioFile struct at file
open. This made lseek fail.
@
text
@d37 3
d53 3
d70 3
a3274 2
    q = fsys_getqio();
    if (!q) return (ioq->iostatus = FSYS_IO_NOQIO);
d3284 2
d3495 1
d3507 1
d3522 1
d3801 20
d3957 1
a3957 1
    int sts, dnlen;
d3987 2
a3988 1
	new_name = QIOmalloc(sts+dnlen+2);
d4075 1
a4075 1
	QIOfree(new_name);
a4106 4
#if 0
    flush_dcache();
    walk.data_buff = (char *)((int)walk.data_buff | 0x20000000);
#endif
d4109 9
a4117 1
	fsys_mountw("/rd0", "/d0");
d4120 1
@


1.12
log
@Misc fixes.
@
text
@d1520 1
@


1.11
log
@Protected fsys_closeq with FSYS_READ_ONLY
@
text
@d633 1
d638 1
a638 1
	    QIOfree(vol->freemem[ii]);
d645 1
a2404 1
			qmount_free(vol, &vol->mutex);
@


1.10
log
@Changed text in filesystem test screen.
@
text
@d3398 1
d3423 1
@


1.9
log
@Fixed numerous bugs. Added a filesystem test.
@
text
@d4104 3
a4106 3
		walk.numb_cksums = ot.alloc/sizeof(ChkSum);
		walk.data_buff += (ot.alloc+QIO_CACHE_LINE_SIZE-1)&-QIO_CACHE_LINE_SIZE;
		walk.data_buff_size -= (ot.alloc+QIO_CACHE_LINE_SIZE-1)&-QIO_CACHE_LINE_SIZE;
d4126 1
d4151 1
@


1.8
log
@Fixed file reader bug.
@
text
@d2 4
a5 3
#include "config.h"
#include "os_proto.h"
#include "phx_proto.h"
d12 5
a16 3
#include "qio.h"
#include "qio_errs.h"
#include "fsys.h"
d471 1
d588 1
d600 1
a600 3
		    t = (t+511)/512;			/* round up to sector size */
		    t >>= 9;				/* compute sector count */
		    arg->sector += t;			/* advance logical sector number */
d1301 4
d3254 1
d3256 1
d3304 1
d3324 2
d3328 1
a3328 1
    hisioq->iocount = q->total;		/* record total bytes xferred */
d3336 1
a3336 1
    fp->pos = q->sector*512 + q->total;	/* advance the files' position */
d3356 1
d3358 1
d3398 25
d3425 1
a3427 1
    FsysVolume *vol;
d3434 1
d3442 2
a3443 5
    if ((rfh->valid&RAMFH_UPD)) {
	add_to_dirty(vol, afid);
	rfh->valid &= ~RAMFH_UPD;	/* not dirty anymore */
    }
#endif
d3451 1
d3729 425
@


1.7
log
@Added some dirent functions. They work, but I may have broken
the write code since I added a change to fix the "copies" option.
@
text
@a570 1
			    rfh->clusters += def;		/* add to total allocation */
d572 1
d1688 1
a1688 1
	his->copies = 1;
d3232 1
a3232 1
    fp->pos = q->sector*512 + q->total;	/* advance the files' sector pointer */
d3269 1
a3269 1
    q->sector = where/512;
d3308 2
@


1.6
log
@Corrected compile time errors when FSYS_READ_ONLY is true.
@
text
@d34 2
a35 2
extern FsysQio *qio_getioq_ptr(FsysQio **head, int size);
extern int qio_freeioq_ptr(FsysQio *q, FsysQio **head);
d47 1
a47 1
    return qio_getioq_ptr(&fsysqio_pool_head, sizeof(FsysQio));
d61 1
a61 1
    return qio_freeioq_ptr(que, &fsysqio_pool_head);
d2722 1
a2722 1
    qio_open(ioq, (void *)where, O_RDWR); /* open physical device for r/w */
d3216 1
a3216 1
    ioq->iostatus = FSYS_IO_SUCC;
d3297 15
d3315 5
a3319 1
    hisioq->iostatus = ioq->iostatus;	/* record last status */
d3352 6
d3360 1
a3360 4
    q->ramrp = rfh->ramrp + rfh->active_rp;
    q->sector = where/512;
    q->u_len = len;
    q->buff = (void *)buf;
a3376 7
static int fsys_readdir( QioIOQ *ioq, void *arg, int flags ) {
    struct dirent *dir;
    dir = (struct dirent *)arg;
    if (!ioq) return QIO_INVARG;
    return (ioq->iostatus = FSYS_IO_NOSUPP);
}

d3409 1
a3409 1
    ioq->iostatus = FSYS_IO_SUCC;
d3441 115
a3559 1
    fsys_readdir, /* read next directory entry */
d3581 8
a3588 2
    fsys_readwpos,
    fsys_writewpos
@


1.5
log
@This version of qio and fsys stuff all works. It isn't done yet,
but since it works, I checked in what there is so far.
/
@
text
@d64 1
d88 1
d164 1
d166 3
d1646 1
a1660 1
#if !FSYS_READ_ONLY
d1707 1
a1707 3
#else
    if (!ioq) return FSYS_CREATE_INVARG;
    return (ioq->iostatus = FSYS_CREATE_NOSUPP);
a1708 1
}
d1808 2
d1811 1
a1811 1
		rrp->rptrs = 0;
d1819 1
a1819 3
#if FSYS_READ_ONLY
	rrp->rptrs_size = ii;
#else
d1841 1
d2334 1
d2381 3
a2384 2
		struct tq *qt;
		struct act_q *q;
d2391 1
d2527 1
d2531 1
d2676 1
d2679 1
d3185 12
d3384 1
d3389 1
a3398 10
static int fsys_rmdir( QioIOQ *ioq, const char *name ) {
    if (!ioq) return QIO_INVARG;
    return (ioq->iostatus = FSYS_IO_NOSUPP);
}

static int fsys_rename( QioIOQ *ioq, const char *name1, const char *name2 ) {
    if (!ioq) return QIO_INVARG;
    return (ioq->iostatus = FSYS_IO_NOSUPP);
}

d3434 1
d3440 7
d3498 1
d3538 1
a3554 1
#endif			/* !FSYS_READ_ONLY */
@


1.4
log
@Still under development. Not quite ready for primetime.
@
text
@d28 35
a62 1
static FsysVolume volumes[FSYS_MAX_VOLUMES];
a106 4
 *	(NOTE: the returned struct is 2 U32's which will fit,
 *	and gcc will place, in a register pair on RISC
 *	and 68k processors; other processors may make a 'fake'
 *	struct on the stack and pass pointers to it).
d194 106
d316 1
a316 1
static int extend_file(FsysVolume *vol, FsysRamFH *fh, int rqst, FsysRamRP *rp, int where) {
d318 1
a318 1
    FsysRetPtr *arp;
d352 20
d374 1
a374 1
	if (rp->num_rptrs >= rp->rptrs_size) {
d378 25
a402 29
	    if (!cnt) {				/* at the top level, we don't need a RamRP */
		rp->rptrs = (FsysRetPtr *)QIOmalloc(8*sizeof(FsysRetPtr));
		if (!rp->rptrs) return FSYS_EXTEND_NOMEM;
	    } else {
		FsysRamRP *trp;
		trp = (FsysRamRP *)QIOmalloc(sizeof(FsysRamRP)+8*sizeof(FsysRetPtr));
		if (!trp) {
		    return FSYS_EXTEND_NOMEM;	/* oops, ran out of memory */
		}
		rp->next = trp;
		rp = trp;			/* tell last guy about new one */
		rp->rptrs = (FsysRetPtr *)(trp+1); /* point to an array of FsysRetPtr's */
	    }
	    rp->next = 0;			/* new guy is last on the list */
	    rp->num_rptrs = 0;			/* no pointers yet. */
	    rp->rptrs_size = 8;			/* this is how many are in there */
	}
	arp = rp->rptrs + rp->num_rptrs;	/* point to RP element */
	freet.reply = arp;
	freet.where = FSYS_HB_ALG(where, vol->maxlba);
	freet.request = rqst;
	if (fsys_findfree( &freet )) {
	    return FSYS_EXTEND_FULL;		/* disk has become full */
	}
	rqst -= arp->nblocks;			/* take the amount we obtained */
	vol->total_free_clusters -= arp->nblocks; /* take from volume total */
	vol->total_alloc_clusters += arp->nblocks; /* count allocated clusters */
	++rp->num_rptrs;			/* count the RP */
	++cnt;					/* count the RP */
d435 1
a435 1
    arg = (FsysQio *)ioq->private;
d443 1
a443 1
		ioq->complete = (void (*)(QioIOQ *))fsys_qread;
d446 1
d452 2
a453 1
		ltop = fsys_ltop(arg->ramrp, arg->sector, arg->seccnt);
d460 4
a463 6
		if (arg->phys != ltop.phys) {			/* if not next in line */
		    arg->phys = ltop.phys;
		    qio_lseek(ioq, ltop.phys, SEEK_SET);	/* need to set a new position */
		    return;
		}
		continue;
d466 1
a466 8
	    case 2:
		if (QIO_ERR_CODE(ioq->iostatus)) break;
		arg->state = 3;
		qio_read(ioq, arg->buff, arg->count*512);
		if (QIO_ERR_CODE(ioq->iostatus)) break;
		return;

	    case 3: {
d471 3
a473 3
		    arg->buff += t>>2;			/* bump buffer by 'word' count */
		    t >>= 9;				/* get sector count */
		    arg->seccnt -= t;			/* reduce total sector count */
d475 1
a475 2
		    arg->phys += t;			/* advance physical sector */
		    if (arg->seccnt <= 0) break;
a478 1
		arg->phys = 0;				/* force a seek next time */
d486 2
a487 1
    if (arg->compl) arg->compl(arg->c_arg);	/* call back caller's completion routine */
d514 1
a514 1
    arg = (FsysQio *)ioq->private;
d523 1
d529 3
a531 1
		ltop = fsys_ltop(arg->ramrp, arg->sector, arg->seccnt);
d533 38
a570 1
/* Insert file "extend" code here */
d576 4
a579 6
		if (arg->phys != ltop.phys) {
		    arg->phys = ltop.phys;
		    qio_lseek(ioq, ltop.phys, SEEK_SET);
		    return;
		}
		continue;
d582 1
a582 8
	    case 2:
		if (QIO_ERR_CODE(ioq->iostatus)) break;
		arg->state = 3;
		qio_write(ioq, arg->buff, arg->count*512);
		if (QIO_ERR_CODE(ioq->iostatus)) break;
		return;

	    case 3: {
d587 3
a589 1
		    arg->buff += t>>2;			/* advance buffer pointer by 'word' count */
a590 1
		    arg->seccnt -= t;			/* take from total sectors */
d592 1
a592 2
		    arg->phys += t;			/* advance physical sector number */
		    if (arg->seccnt <= 0) break;
d602 2
a603 1
    if (arg->compl) arg->compl(arg->c_arg); /* call back caller's completion routine */
d660 41
d730 6
d852 2
a853 1
static int fsys_sync(QioIOQ *ioq, int how);
d859 4
d868 3
a870 2
	vol->dirty_elems += 32;		/* room for 32 updates */
	vol->dirty = (U32*)qmount_realloc(vol, vol->dirty, vol->dirty_elems*sizeof(long));
d874 2
d879 1
a879 6
	QioIOQ *new;
	new = qio_getioq();			/* get an IOQ to launch the sync task */
	if (new) {
	    ii = fsys_sync(new, FSYS_SYNC_BUSY_BORROWIOQ); /* startup a sync task, delete the IOQ when done */
	    if (ii) qio_freeioq(new);		/* it didn't start, nevermind then */
	}
d890 1
a890 1
    vol->free = qmount_realloc(vol, vol->free, vol->free_elems*sizeof(FsysRetPtr));
d897 1
a897 1
	    sts = extend_file(vol, rfh, 10, rfh->ramrp + ii, ii);
d925 1
a925 1
    bits = ((vol->free_ffree+1)*FSYS_MAX_ALTS*sizeof(long)+511)/512; /* number of sectors required to hold index file */
d931 1
a931 1
	new = qmount_alloc(vol, newsize*sizeof(long));
d1111 1
d1126 3
a1128 2
	    vol->files_elems += 32;		/* ran out, so allocate some more */
	    vol->files = qmount_realloc(vol, vol->files, vol->files_elems*sizeof(FsysRamFH));
d1132 1
a1132 1
	    vol->index = (U32*)qmount_realloc(vol, vol->index, vol->files_elems*sizeof(U32)*FSYS_MAX_ALTS);
d1136 3
d1248 1
d1261 5
d1306 1
d1312 1
d1318 1
d1327 1
d1329 2
a1330 1
		freet.where = FSYS_HB_ALG(bcnt, vol->maxlba);
d1355 6
a1360 1
	rfh->mtime = (unsigned long)time(0);	/* set the modification time */
d1363 1
d1367 1
a1367 1
	    sectors = FSYS_DEFAULT_EXTEND;
d1385 1
a1385 1
		sts = extend_file(vol, rfh, rfh->clusters, rp, where);
d1398 1
a1398 1
	rfh->valid = 1;				/* mark entry as valid and useable */
d1408 3
a1410 1
	    rfh->directory = qmount_alloc(vol, FSYS_DIR_HASH_SIZE*sizeof(FsysDirEnt*));
d1416 1
a1416 6
	    inddir = (FsysDirEnt *)qmount_alloc(vol, 3+2+	/* room for strings */
					       2*sizeof(FsysDirEnt)); /* room for directory items */
	    if (!inddir) {
		ioq->iostatus = FSYS_CREATE_NOMEM;
		break;
	    }
a1417 1
	    strcpy(strings, "..");
d1419 3
a1425 2
	    strings += 3;
	    strcpy(strings, ".");
d1427 2
d1436 1
d1472 4
a1475 2

    do {
d1511 1
a1511 1
	file->private = (void*)((rfh->generation << 24) | fid);	/* FID of open file */
a1514 3
    qio_freemutex(&vol->mutex, ioq);	/* done with volume mutex */
    QIOfree(ioq->private);		/* done with this memory */
    ioq->private = 0;
d1521 2
d1524 1
d1583 4
d1676 1
a1676 1
	his->spc.mode = file->mode;
d1688 2
a1689 1
	ours->mode = mode;
d1784 1
a1784 1
	rfh->directory = qmount_alloc(vol, FSYS_DIR_HASH_SIZE*sizeof(FsysDirEnt*));
d1802 2
a1803 1
	    if (hdr->pointers[jj-1][0].start == hdr->pointers[jj][0].start) {
d1813 1
a1813 1
	rrp->num_rptrs = ii;
d1817 2
a1818 6
	if (vol->state < 5) {
	    ii = rrp->rptrs_size = FSYS_MAX_FHPTRS;
	} else {
	    ii = rrp->rptrs_size+8;
	    if (ii > FSYS_MAX_FHPTRS) ii = FSYS_MAX_FHPTRS;
	}
d1820 1
a1820 1
	rrp->rptrs = qmount_alloc(vol, ii*sizeof(FsysRetPtr));
d1834 1
a1834 1
    rfh->valid = 1;
d1874 3
a1876 3
    vol = (FsysVolume *)ioq->private;
    syn = (FsysSyncT *)&vol->sync_work;
    qio = &vol->reader;
a1887 1
		if (!syn->buffer_size) {	/* grab some buffers */
a1890 1
		    qio->c_arg = (void *)ioq;	/* ioq is the argument */
d1953 1
a1953 1
			    lim = dst + 2*syn->buffer_size;
d1980 1
a1980 1
		    if (def < FSYS_DEFAULT_EXTEND) def = FSYS_DEFAULT_EXTEND;
d1984 1
a1984 1
			    sts = extend_file(vol, rfh, def, rfh->ramrp+ii, ii);
d1997 2
a1998 2
		qio->seccnt = sects;		/* sector count */
		qio->buff = syn->input;		/* point to input buffer */
d2017 2
a2018 2
		qio->seccnt = (rfh->size+511)/512; /* file headers are always 1 sector long */
		qio->buff = syn->input;		/* point to output buffer */
d2024 1
a2024 1
	    case SYNC_READ_FIRSTFH:
d2032 1
a2032 1
		qio->seccnt = 1;		/* file headers are always 1 sector long */
d2067 1
a2067 1
		    qio->seccnt = 1;		/* file headers are always 1 sector long */
d2125 2
a2126 2
		qio->seccnt = 1;		/* file headers are always 1 sector long */
		qio->buff = syn->input;		/* point to input buffer */
d2148 2
a2149 2
		qio->seccnt = 1;		/* file headers are always 1 sector long */
		qio->buff = syn->input;		/* point to input buffer */
d2213 3
a2215 2
		qio->seccnt = syn->sects = sects; /* number of sectors to write */
		qio->buff = syn->output;	/* point to output buffer */
d2240 2
a2241 2
		qio->seccnt = syn->sects;	/* file headers are always 1 sector long */
		qio->buff = syn->output;	/* point to input buffer */
d2257 2
a2258 2
		qio->seccnt = syn->sects;	/* number of sectors to write */
		qio->buff = syn->output;	/* point to output buffer */
a2281 1
    if (syn->busy == FSYS_SYNC_BUSY_BORROWIOQ) qio_freeioq(ioq);
d2285 1
a2285 2
static int fsys_sync(QioIOQ *ioq, int how) {
    FsysSyncT *f;
d2287 1
a2287 1
    int sts = 0;
d2289 2
a2290 2
    vol = (FsysVolume *)ioq->private;
    f = &vol->sync_work;
d2293 2
a2294 1
	sts = qio_getmutex(&vol->mutex, fsys_sync_q, ioq);
d2302 1
d2308 7
a2314 5
    vol = (FsysVolume *)ioq->private;
    ioq->private = (void *)vol;
    fsys_sync(ioq, FSYS_SYNC_BUSY_TIMER);
    vol->sync_t.delta = FSYS_SYNC_TIMER; /* requeue the sync timer */
    tq_ins(&vol->sync_t);
a2319 1
    int sts;
d2326 2
a2327 4
    ioq->private = (void *)vol;
    sts = fsys_sync(ioq, FSYS_SYNC_BUSY_NONTIMER);
    if (sts >= 0) return sts;
    ioq->iostatus = FSYS_SYNC_SUCC|SEVERITY_INFO;
d2353 1
d2362 2
a2363 1
    vol = (FsysVolume *)ioq->private;
d2367 1
d2369 2
a2370 1
		vol->status = FSYS_MOUNT_FATAL;
d2376 2
a2378 1
		struct tq *qt;
d2380 5
a2384 17
		q = &vol->sync;
		if (!q->param) {
		    QioIOQ *timrioq;
		    timrioq = qio_getioq();
		    if (!timrioq) {
			vol->status = FSYS_MOUNT_NOIOQ;
			goto clean_up;
		    }
		    timrioq->file = ioq->file;
		    timrioq->private = (void *)vol;
		    q->action = fsys_sync_q;
		    q->param = (void *)timrioq;
		    q->next = q->que = 0;
		    qt = &vol->sync_t;
		    qt->func = (void (*)(void *))fsys_sync_t;
		    qt->vars = (void *)timrioq;
		}
d2387 1
a2387 1
		    vol->buff = qmount_alloc(vol, 512);	/* get a temporary sector buffer */
d2410 4
a2413 5
		vol->reader.ramrp = &vol->tmpramrp;	/* init the reader stuff */
		vol->reader.seccnt = 1;		/* always read a single sector */
		vol->reader.buff = vol->buff;	 /* into our buffer */
		vol->reader.compl = fsys_qmount; /* come back to us when done */
		vol->reader.c_arg = ioq;	/* with our argument */
d2438 3
a2440 3
		vol->reader.sector = FSYS_HB_ALG(vol->substate, vol->maxlba); /* relative sector number */
		vol->reader.seccnt = 1;		/* always read a single sector */
		vol->reader.buff = vol->buff;	/* into our buffer */
d2455 1
a2455 2
			fsys_qmount(ioq);		/* recurse (read next home block) */
			return;
d2458 1
a2458 1
    clean_up:
d2468 3
d2530 4
a2533 4
		    vol->reader.sector = ulp[vol->substate++];
		    vol->reader.ramrp = &vol->tmpramrp; /* init the reader stuff */
		    vol->reader.seccnt = 1;		/* file header is a single sector */
		    vol->reader.buff = vol->buff;	/* into our local header buffer */
d2557 1
a2557 1
		    vol->files = qmount_alloc(vol, ii*sizeof(FsysRamRP));
d2561 1
a2561 1
			vol->files = qmount_alloc(vol, ii*sizeof(FsysRamRP));
d2569 1
a2569 1
		    vol->index = qmount_alloc(vol, vol->files_elems*FSYS_MAX_ALTS*sizeof(long)); /* room to read the whole file */
d2609 1
a2609 1
			qmount_realloc(vol, (void *)vol->buff, vol->buff_size); /* give back old buffer */
d2636 4
a2639 4
		    vol->reader.ramrp = rrp;
		    vol->reader.sector = 0;		/* read file starting at relative sector 0 */
		    vol->reader.seccnt = (vol->rw_amt+511)/512;; /* number of sectors to read */
		    vol->reader.buff = vol->contents;
d2667 2
d2678 3
a2680 1
    if (sts) vol->status = sts;    
d2699 1
a2699 1
    QioIOQ *ioq;
d2726 8
a2733 4
    vol->maxlba = fs.st_size;		/* keep device size in sectors */
    ioq->private = (void *)vol;
    fsys_qmount(ioq);			/* queue the mount */
    while (vol->state) { ; }		/* wait for mount to complete */
d2735 1
a2735 1
    return vol->status;			/* return with whatever status was reported */
a2738 84
/************************************************************
 * fsys_findfree - find the next free n sectors. This function
 * walks the freelist and tries to find a block of sectors that
 * matches the request'ed amount or an amount nearest. This
 * function is used internally by the filesystem and not expected
 * to be used by the casual user.
 * 
 * At entry:
 *	freet - pointer to FsysFindFreeT struct.
 *
 * At exit:
 *	returns 0 if success, 1 if nothing available.
 *	updates freelist accordingly.
 */
int fsys_findfree( FsysFindFreeT *ft ) {
    int ii;
    int nearest_over, nearest_under;
    long diff_over, diff_under;
    FsysRetPtr *fp, *free;

#if (FSYS_OPTIONS&FSYS_FEATURES&FSYS_FEATURES_SKIP_REPEAT)
# error You need to rewrite fsys_findfree and add repeat/skip support.
#endif

    if (!ft) return 0;

    ft->which_elem = INT_MAX;
    fp = ft->freelist;
    free = ft->reply;

    if (!ft->request || !fp || !free) return 0;

    nearest_over = nearest_under = -1;
    diff_over = LONG_MAX;
    diff_under = LONG_MIN;
    for (ii=0; ii < ft->nelts; ++ii, ++fp) { /* look through the list for one that fits */
	long d;
	int size;
	size = fp->nblocks;
	if (!size) continue;		/* empty entry */
	if (fp->start < ft->where) continue; /* keep looking */
	d = fp->nblocks - ft->request;
	if (d == 0) {			/* if there's one that exactly fits */
	    nearest_over = ii;
	    break;			/* use it directly */
	}
	if (d > 0) {			/* if the size is over.. */
	    if (d < diff_over) {	/* ..but difference is closer */
		nearest_over = ii;	/* remember this entry */
		diff_over = d;		/* and the difference */
	    }
	} else {
	    if (d > diff_under) {	/* size of under but difference is closer */
		nearest_under = ii;	/* remember this entry */
		diff_under = d;		/* and the difference */
	    }
	}	    
    }
    if (nearest_over >= 0) {		/* there's a nearest over */
	fp = ft->freelist + nearest_over;
	free->start = fp->start;
	free->nblocks = ft->request;
	if (fp->nblocks < ft->request) fp->nblocks = 0;
	else fp->nblocks -= ft->request;
	if (fp->nblocks) {
	    fp->start += ft->request;		/* skip the amount we gave away */
	} else {
	    fp->start = 0;
	}
	ft->which_elem = nearest_over;	/* tell 'em which one we modified */
    } else if (!ft->exact && nearest_under >= 0) {
	fp = ft->freelist + nearest_under;
	free->start = fp->start;
	free->nblocks = fp->nblocks;
	fp->start = 0;
	fp->nblocks = 0;
	ft->which_elem = nearest_under;
    } else {
	free->start = 0;
	free->nblocks = 0;
    }
    return (free->start == 0);
}
        
d2789 24
a2812 1
static void compute_home_blocks(FsysHomeBlock *hb, int size, unsigned long *ips) {
d2816 4
d2851 1
a2856 20
typedef struct {
    FsysQio q;			/* !!! this absolutely needs to be the first member !!! */
    int drv;			/* FD of device to do read/write */
    FsysInitVol *iv;
    QioMutex *mutex;		/* mutex for initfs to use */
    int state;
    int substate;
    int status;
    FsysHomeBlock *hb;
    FsysHeader ihdr, fhdr, rhdr;
    FsysRetPtr *fake_free;
    FsysRetPtr freep, tmprp;
    FsysRamRP ramrp;
    unsigned long *dir;
    unsigned long *index;
    unsigned long ilbas[FSYS_MAX_ALTS];
    unsigned long max_lba;
    int free_nelts;
} FsysFinit;

d2876 1
a2876 1
    fin = (FsysFinit *)ioq->private;
d2884 1
d2888 5
d2896 1
d2921 3
a2923 10
		sts = qio_getmutex(fin->mutex, init_file_system, ioq); /* jump to AST level */
		if (sts) {
		    fin->status = sts;
		    fin->state = 0;
		    QIOfree(fin->fake_free);
		    QIOfree(fin->index);
		    QIOfree(fin->dir);
		    QIOfree(fin->hb);
		    return;
		}
d2946 1
d2951 2
a2952 1
		    freet.where = FSYS_HB_ALG(bcnt, fin->max_lba);
d3005 1
a3005 1
		compute_home_blocks(fin->hb, fin->max_lba, fin->ilbas);
a3044 1
		fin->q.c_arg = ioq;
d3052 1
a3052 1
		fin->q.buff = (unsigned long *)fin->hb;
d3054 1
a3054 1
		fin->q.seccnt = 1;
d3066 1
a3066 1
		fin->q.buff = (unsigned long *)&fin->ihdr;
d3068 1
a3068 1
		fin->q.seccnt = 1;
d3080 1
a3080 1
		fin->q.buff = fin->index;
d3082 1
a3082 1
		fin->q.seccnt = iv->index_sectors;
d3095 1
a3095 1
		fin->q.buff = (unsigned long *)&fin->fhdr;
d3097 1
a3097 1
		fin->q.seccnt = 1;
d3109 1
a3109 1
		fin->q.buff = (unsigned long *)fin->fake_free;
d3111 1
a3111 1
		fin->q.seccnt = iv->free_sectors;
d3124 1
a3124 1
		fin->q.buff = (unsigned long *)&fin->rhdr;
d3126 1
a3126 1
		fin->q.seccnt = 1;
d3138 1
a3138 1
		fin->q.buff = fin->dir;
d3140 1
a3140 1
		fin->q.seccnt = iv->root_sectors;
d3168 3
a3170 1
    qio_freemutex(fin->mutex, ioq);
d3175 1
d3177 78
a3254 1
    return (ioq->iostatus = FSYS_IO_NOSUPP);
d3258 2
d3261 61
a3321 1
    return (ioq->iostatus = FSYS_IO_NOSUPP);
d3325 2
d3328 2
a3329 1
    return (ioq->iostatus = FSYS_IO_NOSUPP);
d3345 5
d3351 21
a3371 1
    return (ioq->iostatus = FSYS_IO_NOSUPP);
d3428 3
a3430 1
    fsys_isatty	/* maybe a tty */
a3483 1
    fin.drv = -1;
d3491 1
a3491 1
	    if (!file || !(dvc=file->dvc) || !(fin.mutex=dvc->mutex)) {
d3494 1
a3494 1
		fin.drv = ioq->file;
d3500 5
a3504 4
		    ioq->private = (void *)&fin;
		    init_file_system(ioq);
		    while (fin.state) { ; }
		    sts = fin.status;
@


1.3
log
@Still under development. Not ready for prime time.
@
text
@d294 1
a294 1
		++arg->state;
d304 14
a317 3
		++arg->state;
		qio_lseek(ioq, ltop.phys, SEEK_SET);
		qio_read(ioq, arg->buff, ltop.cnt*512);
a319 1
	    }
d321 1
a321 1
	    case 2: {
d323 1
a323 1
		if (QIO_ERR_CODE(ioq->iostatus) == 0) {
d326 5
a330 4
		    t /= 512;
		    arg->seccnt -= t;
		    arg->sector += t;
		    arg->buff += t*512/4;
d332 1
a332 1
		    --arg->state;
d335 1
d341 1
a341 1
    arg->state = 0;		/* clean up after ourselves */
d343 1
a343 1
    if (arg->compl) arg->compl(arg->c_arg); /* call back caller's completion routine */
d391 10
a400 2
		qio_lseek(ioq, ltop.phys, SEEK_SET);
		qio_write(ioq, arg->buff, ltop.cnt*512);
d402 3
a405 1
	    }
d407 1
a407 1
	    case 2: {
d412 5
a416 4
		    t /= 512;
		    arg->seccnt -= t;
		    arg->sector += t;
		    arg->buff += t*512/4;
d629 1
a629 1
static int fsys_sync(FsysVolume *vol, int how);
d648 6
a653 1
	fsys_sync(vol, FSYS_SYNC_BUSY_NONTIMER); /* startup a sync task */
d990 1
a990 1
    qio_freemutex(vol->mutex, ioq);
d1014 1
a1014 1
    return qio_getmutex(del->vol->mutex, delete_q, ioq);
d1017 1
a1017 1
static void fcreate_q(void *arg) {
a1018 1
    QioIOQ *ioq;
d1028 1
a1028 1
    t = (FsysOpenFileT *)arg;
d1189 1
a1189 2
    qio_freemutex(vol->mutex, ioq);	/* done with volume mutex */
    QIOfree(arg);			/* done with this memory */
d1196 2
d1265 1
a1265 1
    qio_freemutex(vol->mutex, ioq);	/* done with volume mutex */
a1284 1
 *	mode - mode bits as defined in fcntl.h
d1356 2
a1357 1
	    his->path = name;
d1372 1
a1372 1
	sts = qio_getmutex(vol->mutex, fopen_q, ioq);
d1421 2
a1422 1
	his->path = name;
d1435 1
a1435 1
	sts = qio_getmutex(vol->mutex, fopen_q, ioq);
d2021 1
d2025 1
a2025 1
    sts = qio_freemutex(vol->mutex, ioq);	/* done with the mutex */
d2031 1
d2035 1
a2035 1
static int fsys_sync(FsysVolume *vol, int how) {
d2037 1
d2040 1
d2044 1
a2044 1
	sts = qio_getmutex(vol->mutex, fsys_sync_q, (void *)vol);
d2058 4
a2061 3
    fsys_sync(vol, FSYS_SYNC_BUSY_TIMER);
    vol->sync_t->delta = FSYS_SYNC_TIMER; /* requeue the sync timer */
    tq_ins(vol->sync_t);
d2074 2
a2075 1
    sts = fsys_sync(vol, FSYS_SYNC_BUSY_NONTIMER);
a2077 1
    qio_complete(ioq);
a2123 1
		QioIOQ *timrioq;
d2125 6
a2130 10
		if (!vol->mutex) {
		    vol->mutex = qmount_alloc(vol,
    				sizeof(QioMutex)+	/* need a mutex queue */
    				sizeof(struct act_q)+	/* need a tmp queue for mount */
    				sizeof(struct act_q)+	/* need a ast queue for sync */
    				sizeof(struct tq)+	/* need a timer queue for sync */
				sizeof(QioIOQ)		/* place for Qio to use */
    				);
		    if (!vol->mutex) {
			vol->status = FSYS_MOUNT_NOMEM;
a2132 4
		    vol->sync = (struct act_q *)(vol->mutex+1);
		    vol->tmpq = vol->sync+1;
		    vol->sync_t = (struct tq *)(vol->tmpq+1);
		    timrioq = (QioIOQ *)(vol->sync_t+1);
a2134 1
		    q = vol->sync;
d2138 1
a2138 1
		    qt = vol->sync_t;
d2146 1
a2146 2
			qmount_free(vol, vol->mutex);
			vol->mutex = 0;
d2172 1
a2172 1
		q = vol->tmpq;
d2179 1
a2179 1
		sts = qio_getmutex(vol->mutex, fsys_qmount, ioq);
d2226 1
a2226 1
		    qio_freemutex(vol->mutex, ioq);
d2357 6
d2431 1
a2431 1
    sts = qio_freemutex(vol->mutex, ioq);
d2478 1
a2478 1
    vol->maxlba = fs.st_size;		/* convert device size in bytes to sectors */
d2848 1
d2867 1
a2867 1
		fin->q.c_arg = (void *)fin;
d3151 1
a3151 1
		    fin.max_lba = drvstat.st_size/512;
@


1.2
log
@Corrected gcc complaints.
@
text
@a2 1
#include "fsys.h"
d13 1
d280 2
a281 2
static void fsys_qread(FsysQio *arg) {
    QioIOQ *ioq;
d283 1
a283 1
    ioq = arg->ioq;
d291 1
a291 2
		ioq->complete = (void (*)(void *))fsys_qread;
		ioq->param = (void *)arg;
d301 1
a301 1
		    if (!ioq->iocount) ioq->iostatus = FSYS_IO_EOF;
d305 3
a307 4
		if (qio_read(ioq, ltop.phys*512, arg->buff, ltop.cnt*512)) {
		    ioq->iostatus = FSYS_IO_RDERR;
		    break;
		}
d355 4
a358 3
static void fsys_qwrite(FsysQio *arg) {
    QioIOQ *ioq;
    ioq = arg->ioq;
d366 1
a366 2
		ioq->complete = (void (*)(void *))fsys_qwrite;
		ioq->param = (void *)arg;
d375 1
a375 1
		    ioq->iostatus = FSYS_IO_EOF; /* always return an EOF if tried to write too much */
d379 3
a381 4
		if (qio_write(ioq, ltop.phys*512, arg->buff, ltop.cnt*512)) {
		    ioq->iostatus = FSYS_IO_WRTERR;
		    break;
		}
d547 1
a547 1
    if (*fname == FSYS_FNAME_SEPARATOR) ++fname; /* eat leading '/' */
d549 1
a549 1
    while ((path=strchr(fname, FSYS_FNAME_SEPARATOR))) { /* see if we have to traverse a directory */
d942 1
a942 1
static void delete_q(void *arg) {
a945 1
    QioIOQ *ioq;
d947 1
a947 1
    del = (FsysDeleteT *)arg;
a951 1
    ioq = del->ioq;
d961 2
a962 1
    qio_freemutex(vol->mutex);
d985 2
a986 1
    return qio_getmutex(del->vol->mutex, (void (*)(void *))delete_q, (void *)del, QIO_MUTEX_QUEUEIT);
d1016 1
a1016 1
	fname = strrchr(t->path, FSYS_FNAME_SEPARATOR); /* isolate the name from the path */
d1162 1
a1162 1
    qio_freemutex(vol->mutex);		/* done with volume mutex */
d1175 1
a1175 1
static void fopen_q(void *arg) {
a1176 1
    QioIOQ *ioq;
d1184 1
a1184 1
    t = (FsysOpenFileT *)arg;
d1188 1
a1188 1
	fcreate_q(arg);			/* open for writing */
a1192 1
    ioq = t->ioq;
d1237 3
a1239 2
    qio_freemutex(vol->mutex);		/* done with volume mutex */
    QIOfree(arg);			/* done with this memory */
d1290 1
a1290 1
static int fsys_open( QioIOQ *ioq, const char *name, int mode ) {
d1310 1
a1310 1
	if ((mode&O_CREAT)) {
d1342 3
a1344 2
	ours->mode = mode;
	sts = qio_getmutex(vol->mutex, fopen_q, (void *)ours, QIO_MUTEX_QUEUEIT);
d1354 1
d1406 1
a1406 1
	sts = qio_getmutex(vol->mutex, fopen_q, (void *)ours, QIO_MUTEX_QUEUEIT);
d1574 1
a1574 1
    syn->buffers = (unsigned long *)QIOrealloc(syn->buffers, 2*syn->buffer_size+FSYS_CACHE_LINE_SIZE);
d1578 1
a1578 1
    syn->input = (unsigned long *)((FSYS_MK_NONCACHE(syn->buffers)+FSYS_CACHE_LINE_SIZE-1)&-FSYS_CACHE_LINE_SIZE);
d1584 1
a1584 1
static void fsys_sync_q(void *arg) {
d1588 1
a1589 2
    FsysRamFH *rfh=0;
    QioIOQ *ioq;
d1593 1
a1593 1
    vol = (FsysVolume *)arg;
d1595 1
a1595 2
    qio = &syn->qio;
    ioq = qio->ioq;
a1609 1
		    qio->dev = vol - volumes;
d1611 1
a1611 1
		    qio->c_arg = (void *)vol;	/* volume is the argument */
d1722 1
a1722 1
		fsys_qwrite(qio);
d1742 1
a1742 1
		fsys_qwrite(qio);
d1758 1
d1761 1
a1761 1
		fsys_qread(qio);
d1792 2
a1793 1
		    fsys_qread(qio);		/* read the next alternate */
d1850 1
a1850 1
		fsys_qwrite(qio);
d1873 1
a1873 1
		fsys_qwrite(qio);
d1938 1
a1938 1
		fsys_qwrite(qio);
d1963 1
a1963 1
		fsys_qwrite(qio);
d1981 1
a1981 1
		fsys_qwrite(qio);
d1995 1
a1995 1
    sts = qio_freemutex(vol->mutex);		/* done with the mutex */
d2011 1
a2011 1
	sts = qio_getmutex(vol->mutex, fsys_sync_q, (void *)vol, QIO_MUTEX_QUEUEIT);
d2022 1
a2022 1
static void fsys_sync_t(void *arg) {
d2024 1
a2024 1
    vol = (FsysVolume *)arg;
d2068 1
a2068 1
void fsys_qmount(FsysVolume *vol) {
d2073 1
d2077 1
d2090 2
d2098 1
a2098 1
				2*sizeof(QioIOQ)	/* places for Qio to use */
d2107 10
a2116 2
		    vol->reader.ioq = (QioIOQ *)(vol->sync_t+1);
		    vol->sync_work.qio.ioq = vol->reader.ioq + 1;
a2144 1
		vol->reader.dev = vol-volumes;
d2147 2
a2148 3
		vol->reader.compl = (void (*)(void *))fsys_qmount; /* come back to us when done */
		vol->reader.c_arg = (void *)vol; /* with our argument */
		vol->reader.ioq->file = vol->iofd;
d2151 1
a2151 1
		q->param = (void *)vol;
a2153 7
		q = vol->sync;
		q->action = fsys_sync_q;
		q->param = (void *)vol;
		q->next = q->que = 0;
		qt = vol->sync_t;
		qt->func = fsys_sync_t;
		qt->vars = (void *)vol;
d2156 1
a2156 1
		sts = qio_getmutex(vol->mutex, (void (*)(void *))fsys_qmount, (void *)vol, QIO_MUTEX_QUEUEIT);
d2177 1
a2177 1
		fsys_qread(&vol->reader);
d2186 1
a2186 1
		    QIO_ERR_CODE(vol->reader.ioq->iostatus) ||	/* no errors are expected or accepted */
d2190 1
a2190 1
			fsys_qmount(vol);		/* recurse (read next home block) */
d2203 1
a2203 1
		    qio_freemutex(vol->mutex);
d2268 1
a2268 1
		    fsys_qread(&vol->reader);		/* read the next copy of file header */
d2279 1
a2279 1
		if (QIO_ERR_CODE(vol->reader.ioq->iostatus) || 	/* can't have any input errors */
d2368 1
a2368 1
		    fsys_qread(&vol->reader);	/* read the whole damn file at once */
d2375 1
a2375 1
		if (QIO_ERR_CODE(vol->reader.ioq->iostatus)) {	/* can't have any input errors */
d2402 1
a2402 1
    sts = qio_freemutex(vol->mutex);
d2449 4
a2452 1
    vol->maxlba = fs.st_size/512;	/* convert device size in bytes to sectors */
a2453 2
    fsys_qmount(vol);			/* queue the mount */
    while (vol->state) { ; }		/* wait for mount to complete */
d2633 1
a2644 1
    FsysQio qio;
d2665 1
a2665 1
static void init_file_system(void *arg) {
d2671 1
a2671 1
    fin = (FsysFinit *)arg;
d2679 1
a2679 1
		    fin->status = FSYS_INITFS_INVARG;
d2685 1
a2685 1
		    fin->status = FSYS_INITFS_NOMEM;
d2709 1
a2709 1
		sts = qio_getmutex(fin->mutex, init_file_system, arg, QIO_MUTEX_QUEUEIT); /* jump to AST level */
d2835 3
a2837 4
		fin->qio.ramrp = &fin->ramrp;
		fin->qio.dev = fin->drv;
		fin->qio.compl = init_file_system;
		fin->qio.c_arg = (void *)fin;
a2842 4
		if (QIO_ERR_CODE(fin->qio.ioq->iostatus)) {
		    fin->status = FSYS_INITFS_BADROOTF;
		    break;
		}
d2845 3
a2847 3
		fin->qio.buff = (unsigned long *)fin->hb;
		fin->qio.sector = FSYS_HB_ALG(fin->substate, fin->max_lba);
		fin->qio.seccnt = 1;
d2849 1
a2849 1
		fsys_qwrite(&fin->qio);
d2853 4
d2859 3
a2861 3
		fin->qio.buff = (unsigned long *)&fin->ihdr;
		fin->qio.sector = indxp[fin->substate];
		fin->qio.seccnt = 1;
d2863 1
a2863 1
		fsys_qwrite(&fin->qio);
d2867 1
a2867 1
		if (QIO_ERR_CODE(fin->qio.ioq->iostatus)) {
d2873 3
a2875 3
		fin->qio.buff = fin->index;
		fin->qio.sector = 0;
		fin->qio.seccnt = iv->index_sectors;
d2877 1
a2877 1
		fsys_qwrite(&fin->qio);
d2881 1
a2881 1
		if (QIO_ERR_CODE(fin->qio.ioq->iostatus)) {
d2888 3
a2890 3
		fin->qio.buff = (unsigned long *)&fin->fhdr;
		fin->qio.sector = indxp[fin->substate];
		fin->qio.seccnt = 1;
d2892 1
a2892 1
		fsys_qwrite(&fin->qio);
d2896 1
a2896 1
		if (QIO_ERR_CODE(fin->qio.ioq->iostatus)) {
d2902 3
a2904 3
		fin->qio.buff = (unsigned long *)fin->fake_free;
		fin->qio.sector = 0;
		fin->qio.seccnt = iv->free_sectors;
d2906 1
a2906 1
		fsys_qwrite(&fin->qio);
d2910 1
a2910 1
		if (QIO_ERR_CODE(fin->qio.ioq->iostatus)) {
d2917 3
a2919 3
		fin->qio.buff = (unsigned long *)&fin->rhdr;
		fin->qio.sector = indxp[fin->substate];
		fin->qio.seccnt = 1;
d2921 1
a2921 1
		fsys_qwrite(&fin->qio);
d2925 1
a2925 1
		if (QIO_ERR_CODE(fin->qio.ioq->iostatus)) {
d2931 3
a2933 3
		fin->qio.buff = fin->dir;
		fin->qio.sector = 0;
		fin->qio.seccnt = iv->root_sectors;
d2935 1
a2935 1
		fsys_qwrite(&fin->qio);
d2939 2
a2940 2
		if (QIO_ERR_CODE(fin->qio.ioq->iostatus)) {
		    fin->status = FSYS_INITFS_BADHB;
d2961 1
a2961 1
    qio_freemutex(fin->mutex);
d2970 1
a2970 1
static int fsys_read( QioIOQ *ioq, size_t where, char *buf, int len ) {
d2975 1
a2975 1
static int fsys_write( QioIOQ *ioq, size_t where, char *buf, int len ) {
d2980 3
a2982 1
static int fsys_readdir( QioIOQ *ioq, struct dirent *dir, int flags ) {
d3012 3
a3014 1
static int fsys_statfs( QioIOQ *ioq, const char *name, struct statfs *sfs ) {
d3024 10
d3049 3
a3051 1
    fsys_fstat	/* stat a file */
d3122 2
a3123 2
		    fin.qio.ioq = ioq;
		    init_file_system((void *)&fin);
@


1.1
log
@Initial revision
@
text
@d1591 1
a1591 1
    FsysRamFH *rfh;
d2665 1
a2665 1
    int ii, bcnt, sts;
@
